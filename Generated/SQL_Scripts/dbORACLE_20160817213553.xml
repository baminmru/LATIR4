<?xml version="1.0"?>
<root>
  <ModuleHolder ModuleName="--PreInstall" File="">
    <BlockHolder BlockName="--body" BlockCode="
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Tables" File="">
    <BlockHolder BlockName="--kernel" BlockCode=" 

-- Kernel Tables --
drop table MTZ.sysoptions
/
create table MTZ.sysoptions(
sysoptionsID CHAR(38) primary key,
Name varchar2(255) null,
TheValue varchar2(255) null,
OptionType VarChar2(255) null
)
/
drop table MTZ.typelist
/
create  table MTZ.typelist(
typelistID CHAR(38) primary key  ,
Name varchar2(255) not null,
SecurityStyleID CHAR(38) null, 
RegisterProc varchar2(255) null,
DeleteProc varchar2(255) null,
HCLProc varchar2(255) null ,
PropagateProc varchar2(255) null 
)
/
drop table MTZ.Instance
/
create table MTZ.Instance(
InstanceID CHAR(38) not null primary key,
LockUserID CHAR(38) null, 
LockSessionID CHAR(38) null, 
SecurityStyleID CHAR(38) null, 
Name varchar2(255) null,
ObjType varchar2(255) null
)
/
alter table instance add OwnerPartName varchar2(255) null
/
alter table instance add OwnerRowID CHAR(38) null
/
alter  table instance add status CHAR(38) null
/
alter  table instance add archived NUMBER null
/
drop table MTZ.QueryResult
/
CREATE TABLE MTZ.QueryResult (
  QueryResultid CHAR(38) NOT NULL ,
  result CHAR(38) NULL 
)
/
drop table MTZ.RPRESULT
/
CREATE TABLE MTZ.RPRESULT (
  RPRESULTID CHAR(38) NOT NULL ,
  PARENTLEVEL NUMBER NOT NULL ,
  PARTNAME varchar2 (255) NULL ,
  THEROWID CHAR(38) NULL 
)
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--body" BlockCode=" 

/*Пакет генерации*/
drop table MTZ.GENPACKAGE/*Пакет генерации*/ 
/
create table MTZ.GENPACKAGE/*Пакет генерации*/ (
InstanceID CHAR(38) ,
GENPACKAGEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GENPACKAGE add 
Name
 VARCHAR2 (255) null /* Название */
/

/*Генераторы*/
drop table MTZ.GENERATOR_TARGET/*Генераторы*/ 
/
create table MTZ.GENERATOR_TARGET/*Генераторы*/ (
ParentStructRowID CHAR(38) not null,
GENERATOR_TARGETid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GENERATOR_TARGET add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.GENERATOR_TARGET add 
TargetType
 NUMBER null 
 check (TargetType in ( 0/* СУБД */
, 3/* Документация */
, 1/* МОДЕЛЬ */
, 2/* Приложение */
, 4/* АРМ */ )) /* Тип платформы */
/
alter  table MTZ.GENERATOR_TARGET add 
QueueName
 VARCHAR2 (255) null /* Очередь */
/
alter  table MTZ.GENERATOR_TARGET add 
GeneratorProgID
 VARCHAR2 (255) null /* COM класс */
/
alter  table MTZ.GENERATOR_TARGET add 
GeneratorStyle
 NUMBER null 
 check (GeneratorStyle in ( 0/* Один тип */
, 1/* Все типы сразу */ )) /* Вариант */
/
alter  table MTZ.GENERATOR_TARGET add 
TheDevelopmentEnv
 NUMBER null 
 check (TheDevelopmentEnv in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Среда разработки */
/

/*Библиотеки*/
drop table MTZ.GENREFERENCE/*Библиотеки, которые используются при генерации*/ 
/
create table MTZ.GENREFERENCE/*Библиотеки, которые используются при генерации*/ (
ParentStructRowID CHAR(38) not null,
GENREFERENCEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GENREFERENCE add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.GENREFERENCE add 
RefClassID
 VARCHAR2 (40) null /* Класс ссылки */
/
alter  table MTZ.GENREFERENCE add 
VersionMajor
 NUMBER null /* Номер версии */
/
alter  table MTZ.GENREFERENCE add 
VersionMinor
 NUMBER null /* Подверсия */
/

/*Ручной код*/
drop table MTZ.GENMANUALCODE/*Код, который не укладывается в описание модели*/ 
/
create table MTZ.GENMANUALCODE/*Код, который не укладывается в описание модели*/ (
ParentStructRowID CHAR(38) not null,
GENMANUALCODEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GENMANUALCODE add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.GENMANUALCODE add 
the_Alias
 VARCHAR2 (80) null /* Псевдоним */
/
alter  table MTZ.GENMANUALCODE add 
Code VARCHAR2(4000) null /* Код */
/

/*Контрольные элементы*/
drop table MTZ.GENCONTROLS/*Контрольные элементы, которые используются при генерации*/ 
/
create table MTZ.GENCONTROLS/*Контрольные элементы, которые используются при генерации*/ (
ParentStructRowID CHAR(38) not null,
GENCONTROLSid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GENCONTROLS add 
ControlProgID
 VARCHAR2 (255) null /* ProgID контрольконо элемента */
/
alter  table MTZ.GENCONTROLS add 
ControlClassID
 VARCHAR2 (40) null /* Класс контрольногоэлемента */
/
alter  table MTZ.GENCONTROLS add 
VersionMajor
 NUMBER null /* Версия */
/
alter  table MTZ.GENCONTROLS add 
VersionMinor
 NUMBER null /* Подверсия */
/

/*Локализация*/
drop table MTZ.LocalizeInfo/**/ 
/
create table MTZ.LocalizeInfo/**/ (
InstanceID CHAR(38) ,
LocalizeInfoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.LocalizeInfo add 
LangFull
 VARCHAR2 (255) null /* Язык - название */
/
alter  table MTZ.LocalizeInfo add 
LangShort
 VARCHAR2 (255) null /* Код языка */
/

/*Тип поля*/
drop table MTZ.FIELDTYPE/*Типы полей, перечисления, интервалы*/ 
/
create table MTZ.FIELDTYPE/*Типы полей, перечисления, интервалы*/ (
InstanceID CHAR(38) ,
FIELDTYPEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDTYPE add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.FIELDTYPE add 
TypeStyle
 NUMBER null 
 check (TypeStyle in ( 4/* Ссылка */
, 1/* Выражение */
, 5/* Элемент оформления */
, 3/* Интервал */
, 2/* Перечисление */
, 0/* Скалярный тип */ )) /* Трактовка */
/
alter  table MTZ.FIELDTYPE add 
the_Comment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.FIELDTYPE add 
AllowSize
 NUMBER null 
 check (AllowSize in ( -1/* Да */
, 0/* Нет */ )) /* Нужен размер */
/
alter  table MTZ.FIELDTYPE add 
Minimum
 VARCHAR2 (64) null /* Минимум */
/
alter  table MTZ.FIELDTYPE add 
Maximum
 VARCHAR2 (64) null /* Максимум */
/
alter  table MTZ.FIELDTYPE add 
AllowLikeSearch
 NUMBER null 
 check (AllowLikeSearch in ( -1/* Да */
, 0/* Нет */ )) /* Поиск текста */
/
alter  table MTZ.FIELDTYPE add 
GridSortType
 NUMBER null 
 check (GridSortType in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Вариант сортировки в табличном представлении */
/
alter  table MTZ.FIELDTYPE add 
DelayedSave
 NUMBER null 
 check (DelayedSave in ( -1/* Да */
, 0/* Нет */ )) /* Отложенное сохранение */
/

/*Зачения*/
drop table MTZ.ENUMITEM/*Для описания Enum типов*/ 
/
create table MTZ.ENUMITEM/*Для описания Enum типов*/ (
ParentStructRowID CHAR(38) not null,
ENUMITEMid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ENUMITEM add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ENUMITEM add 
NameValue
 NUMBER null /* Значение */
/
alter  table MTZ.ENUMITEM add 
NameInCode
 VARCHAR2 (100) null /* Название в коде */
/

/*Отображение*/
drop table MTZ.FIELDTYPEMAP/*Отображение типа поля на физический тип хранения*/ 
/
create table MTZ.FIELDTYPEMAP/*Отображение типа поля на физический тип хранения*/ (
ParentStructRowID CHAR(38) not null,
FIELDTYPEMAPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDTYPEMAP add 
Target CHAR(38) null /* Платформа */
/
alter  table MTZ.FIELDTYPEMAP add 
StoageType
 VARCHAR2 (255) null /* Тип хранения */
/
alter  table MTZ.FIELDTYPEMAP add 
FixedSize
 NUMBER null /* Размер */
/

/*Методы и процедуры*/
drop table MTZ.SHAREDMETHOD/*Методы и процедуры*/ 
/
create table MTZ.SHAREDMETHOD/*Методы и процедуры*/ (
InstanceID CHAR(38) ,
SHAREDMETHODid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.SHAREDMETHOD add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.SHAREDMETHOD add 
the_Comment VARCHAR2(4000) null /* Описание метода */
/
alter  table MTZ.SHAREDMETHOD add 
ReturnType CHAR(38) null /* Возвращаемый тип */
/

/*Реализация*/
drop table MTZ.SCRIPT/*Код метода на понятном конкретному генератору языке*/ 
/
create table MTZ.SCRIPT/*Код метода на понятном конкретному генератору языке*/ (
ParentStructRowID CHAR(38) not null,
SCRIPTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.SCRIPT add 
Target CHAR(38) null /* Целевая платформа */
/
alter  table MTZ.SCRIPT add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Параметры*/
drop table MTZ.PARAMETERS/*Параметры метода*/ 
/
create table MTZ.PARAMETERS/*Параметры метода*/ (
ParentStructRowID CHAR(38) not null,
PARAMETERSid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.PARAMETERS add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTZ.PARAMETERS add 
Name
 VARCHAR2 (80) null /* Имя */
/
alter  table MTZ.PARAMETERS add 
Caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTZ.PARAMETERS add 
TypeOfParm CHAR(38) null /* Тип данных */
/
alter  table MTZ.PARAMETERS add 
DataSize
 NUMBER null /* Размер */
/
alter  table MTZ.PARAMETERS add 
AllowNull
 NUMBER null 
 check (AllowNull in ( -1/* Да */
, 0/* Нет */ )) /* Можно не задавать */
/
alter  table MTZ.PARAMETERS add 
OutParam
 NUMBER null 
 check (OutParam in ( -1/* Да */
, 0/* Нет */ )) /* Возвращает значение */
/
alter  table MTZ.PARAMETERS add 
ReferenceType
 NUMBER null 
 check (ReferenceType in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTZ.PARAMETERS add 
RefToType CHAR(38) null /* Ссылка на тип */
/
alter  table MTZ.PARAMETERS add 
RefToPart CHAR(38) null /* Ссылка на раздел */
/

/*Тип объекта*/
drop table MTZ.OBJECTTYPE/*Тип объекта (карточки)*/ 
/
create table MTZ.OBJECTTYPE/*Тип объекта (карточки)*/ (
InstanceID CHAR(38) ,
OBJECTTYPEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.OBJECTTYPE add 
Package CHAR(38) null /* Приложение */
/
alter  table MTZ.OBJECTTYPE add 
the_Comment
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.OBJECTTYPE add 
Name
 VARCHAR2 (14) null /* Код */
/
alter  table MTZ.OBJECTTYPE add 
IsSingleInstance
 NUMBER null 
 check (IsSingleInstance in ( -1/* Да */
, 0/* Нет */ )) /* Допускается только один объект */
/
alter  table MTZ.OBJECTTYPE add 
ChooseView CHAR(38) null /* Представление для выбора */
/
alter  table MTZ.OBJECTTYPE add 
OnRun CHAR(38) null /* При запуске */
/
alter  table MTZ.OBJECTTYPE add 
OnCreate CHAR(38) null /* При создании */
/
alter  table MTZ.OBJECTTYPE add 
OnDelete CHAR(38) null /* При удалении */
/
alter  table MTZ.OBJECTTYPE add 
AllowRefToObject
 NUMBER null 
 check (AllowRefToObject in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при выборе ссылки */
/
alter  table MTZ.OBJECTTYPE add 
AllowSearch
 NUMBER null 
 check (AllowSearch in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при поиске */
/
alter  table MTZ.OBJECTTYPE add 
ReplicaType
 NUMBER null 
 check (ReplicaType in ( 1/* Построчно */
, 0/* Весь документ */
, 2/* Локальный */ )) /* Тип репликации */
/
alter  table MTZ.OBJECTTYPE add 
TheComment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.OBJECTTYPE add 
UseOwnership
 NUMBER null 
 check (UseOwnership in ( -1/* Да */
, 0/* Нет */ )) /* Видмость зависит от пользователя */
/
alter  table MTZ.OBJECTTYPE add 
UseArchiving
 NUMBER null 
 check (UseArchiving in ( -1/* Да */
, 0/* Нет */ )) /* Архивировать вместо удаления */
/
alter  table MTZ.OBJECTTYPE add 
CommitFullObject
 NUMBER null 
 check (CommitFullObject in ( -1/* Да */
, 0/* Нет */ )) /* Сохранять объект целиком */
/
alter  table MTZ.OBJECTTYPE add 
objIconCls
 VARCHAR2 (80) null /* Иконка объекта */
/

/*Состояния*/
drop table MTZ.OBJSTATUS/*Возможные логические состояния документа*/ 
/
create table MTZ.OBJSTATUS/*Возможные логические состояния документа*/ (
ParentStructRowID CHAR(38) not null,
OBJSTATUSid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.OBJSTATUS add 
name
 VARCHAR2 (80) null /* Название */
/
alter  table MTZ.OBJSTATUS add 
isStartup
 NUMBER null 
 check (isStartup in ( -1/* Да */
, 0/* Нет */ )) /* Начальное */
/
alter  table MTZ.OBJSTATUS add 
IsArchive
 NUMBER null 
 check (IsArchive in ( -1/* Да */
, 0/* Нет */ )) /* Архивное */
/
alter  table MTZ.OBJSTATUS add 
the_comment VARCHAR2(4000) null /* Описание */
/

/*Разрешенные переходы*/
drop table MTZ.NEXTSTATE/*Матрица переходов */ 
/
create table MTZ.NEXTSTATE/*Матрица переходов */ (
ParentStructRowID CHAR(38) not null,
NEXTSTATEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.NEXTSTATE add 
TheState CHAR(38) null /* Разрешенное состояние */
/

/*Режим работы*/
drop table MTZ.OBJECTMODE/*Режим работы*/ 
/
create table MTZ.OBJECTMODE/*Режим работы*/ (
ParentStructRowID CHAR(38) not null,
OBJECTMODEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.OBJECTMODE add 
Name
 VARCHAR2 (5) null /* Название режима */
/
alter  table MTZ.OBJECTMODE add 
DefaultMode
 NUMBER null 
 check (DefaultMode in ( -1/* Да */
, 0/* Нет */ )) /* Этот режим является основным режимом работы объекта */
/
alter  table MTZ.OBJECTMODE add 
TheComment VARCHAR2(4000) null /* Описание */
/

/*Органичения разделов*/
drop table MTZ.STRUCTRESTRICTION/*Ораничения на доступ к разделу документа*/ 
/
create table MTZ.STRUCTRESTRICTION/*Ораничения на доступ к разделу документа*/ (
ParentStructRowID CHAR(38) not null,
STRUCTRESTRICTIONid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.STRUCTRESTRICTION add 
Struct CHAR(38) null /* структура, доступ к которой ограничен */
/
alter  table MTZ.STRUCTRESTRICTION add 
AllowRead
 NUMBER null 
 check (AllowRead in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
/
alter  table MTZ.STRUCTRESTRICTION add 
AllowAdd
 NUMBER null 
 check (AllowAdd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавлять */
/
alter  table MTZ.STRUCTRESTRICTION add 
AllowEdit
 NUMBER null 
 check (AllowEdit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено изменять */
/
alter  table MTZ.STRUCTRESTRICTION add 
AllowDelete
 NUMBER null 
 check (AllowDelete in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удалять */
/

/*Ограничения методов*/
drop table MTZ.METHODRESTRICTION/*Ограничение на использование методов раздела*/ 
/
create table MTZ.METHODRESTRICTION/*Ограничение на использование методов раздела*/ (
ParentStructRowID CHAR(38) not null,
METHODRESTRICTIONid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.METHODRESTRICTION add 
Part CHAR(38) null /* Структура, которой принадлежит метод */
/
alter  table MTZ.METHODRESTRICTION add 
Method CHAR(38) null /* Метод */
/
alter  table MTZ.METHODRESTRICTION add 
IsRestricted
 NUMBER null 
 check (IsRestricted in ( -1/* Да */
, 0/* Нет */ )) /* Запрещено использовать */
/

/*Ограничения полей*/
drop table MTZ.FIELDRESTRICTION/*Ограничения на доступ к полям раздела*/ 
/
create table MTZ.FIELDRESTRICTION/*Ограничения на доступ к полям раздела*/ (
ParentStructRowID CHAR(38) not null,
FIELDRESTRICTIONid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDRESTRICTION add 
ThePart CHAR(38) null /* Структура, которой принадлежит поле */
/
alter  table MTZ.FIELDRESTRICTION add 
TheField CHAR(38) null /* Поле, на которое накладывается ограничение */
/
alter  table MTZ.FIELDRESTRICTION add 
AllowRead
 NUMBER null 
 check (AllowRead in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
/
alter  table MTZ.FIELDRESTRICTION add 
AllowModify
 NUMBER null 
 check (AllowModify in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена модификация */
/
alter  table MTZ.FIELDRESTRICTION add 
MandatoryField
 NUMBER null 
 check (MandatoryField in ( -1/* Не существенно */
, 1/* Да */
, 0/* Нет */ )) /* Обязательное поле */
/

/*Методы типа*/
drop table MTZ.TYPEMENU/*Методы уровня типа*/ 
/
create table MTZ.TYPEMENU/*Методы уровня типа*/ (
ParentStructRowID CHAR(38) not null,
TYPEMENUid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.TYPEMENU add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.TYPEMENU add 
Caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTZ.TYPEMENU add 
ToolTip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTZ.TYPEMENU add 
the_Action CHAR(38) null /* Метод */
/
alter  table MTZ.TYPEMENU add 
IsMenuItem
 NUMBER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
/
alter  table MTZ.TYPEMENU add 
IsToolBarButton
 NUMBER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* Включать в тулбар */
/
alter  table MTZ.TYPEMENU add 
HotKey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Проверка правильности*/
drop table MTZ.INSTANCEVALIDATOR/*Проверка правильности для объекта в целом*/ 
/
create table MTZ.INSTANCEVALIDATOR/*Проверка правильности для объекта в целом*/ (
ParentStructRowID CHAR(38) not null,
INSTANCEVALIDATORid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.INSTANCEVALIDATOR add 
Target CHAR(38) null /* Платформа */
/
alter  table MTZ.INSTANCEVALIDATOR add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Раздел*/
drop table MTZ.PART/*Раздел объекта*/ 
/
create table MTZ.PART/*Раздел объекта*/ (
ParentStructRowID CHAR(38) not null,
PARTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTZ.PART add 
Sequence
 NUMBER null /* № п/п */
/
alter  table MTZ.PART add 
PartType
 NUMBER null 
 check (PartType in ( 1/* Коллекция */
, 2/* Дерево */
, 0/* Строка */
, 4/* Расширение с данными */
, 3/* Расширение */ )) /* Тип структры */
/
alter  table MTZ.PART add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.PART add 
Name
 VARCHAR2 (20) null /* Название */
/
alter  table MTZ.PART add 
the_Comment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.PART add 
NoLog
 NUMBER null 
 check (NoLog in ( -1/* Да */
, 0/* Нет */ )) /* Не записывать в журнал */
/
alter  table MTZ.PART add 
ManualRegister
 NUMBER null 
 check (ManualRegister in ( -1/* Да */
, 0/* Нет */ )) /* Исключить из индексирования */
/
alter  table MTZ.PART add 
OnCreate CHAR(38) null /* При создании */
/
alter  table MTZ.PART add 
OnSave CHAR(38) null /* При сохранении */
/
alter  table MTZ.PART add 
OnRun CHAR(38) null /* При открытии */
/
alter  table MTZ.PART add 
OnDelete CHAR(38) null /* При удалении */
/
alter  table MTZ.PART add 
AddBehaivor
 NUMBER null 
 check (AddBehaivor in ( 0/* AddForm */
, 2/* RunAction */
, 1/* RefreshOnly */ )) /* Поведение при добавлении */
/
alter  table MTZ.PART add 
ExtenderObject CHAR(38) null /* Объект расширения */
/
alter  table MTZ.PART add 
shablonBrief
 VARCHAR2 (100) null /* Шаблон для краткого отображения */
/
alter  table MTZ.PART add 
ruleBrief
 VARCHAR2 (500) null /* Правило составления BRIEF поля */
/
alter  table MTZ.PART add 
IsJormalChange
 NUMBER null 
 check (IsJormalChange in ( -1/* Да */
, 0/* Нет */ )) /* Вести журнал изменений */
/
alter  table MTZ.PART add 
UseArchiving
 NUMBER null 
 check (UseArchiving in ( -1/* Да */
, 0/* Нет */ )) /* Архивировать вместо удаления */
/
alter  table MTZ.PART add 
integerpkey
 NUMBER null 
 check (integerpkey in ( -1/* Да */
, 0/* Нет */ )) /* Целочисленный ключ */
/
alter  table MTZ.PART add 
partIconCls
 VARCHAR2 (80) null /* Иконка раздела */
/

/*Методы раздела*/
drop table MTZ.PARTMENU/*Методы уровня раздела*/ 
/
create table MTZ.PARTMENU/*Методы уровня раздела*/ (
ParentStructRowID CHAR(38) not null,
PARTMENUid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.PARTMENU add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.PARTMENU add 
Caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTZ.PARTMENU add 
ToolTip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTZ.PARTMENU add 
the_Action CHAR(38) null /* Метод */
/
alter  table MTZ.PARTMENU add 
IsMenuItem
 NUMBER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
/
alter  table MTZ.PARTMENU add 
IsToolBarButton
 NUMBER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
/
alter  table MTZ.PARTMENU add 
HotKey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Отображение параметров*/
drop table MTZ.PARTPARAMMAP/*отображение значений полей раздела на параметры метода*/ 
/
create table MTZ.PARTPARAMMAP/*отображение значений полей раздела на параметры метода*/ (
ParentStructRowID CHAR(38) not null,
PARTPARAMMAPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.PARTPARAMMAP add 
FieldName
 VARCHAR2 (255) null /* Поле (значение) */
/
alter  table MTZ.PARTPARAMMAP add 
ParamName
 VARCHAR2 (80) null /* Параметр */
/
alter  table MTZ.PARTPARAMMAP add 
NoEdit
 NUMBER null 
 check (NoEdit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
/

/*Представление*/
drop table MTZ.PARTVIEW/*Вариант представления, который может использоваться для создания журнала*/ 
/
create table MTZ.PARTVIEW/*Вариант представления, который может использоваться для создания журнала*/ (
ParentStructRowID CHAR(38) not null,
PARTVIEWid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.PARTVIEW add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.PARTVIEW add 
the_Alias
 VARCHAR2 (64) null /* Псевдоним */
/
alter  table MTZ.PARTVIEW add 
ForChoose
 NUMBER null 
 check (ForChoose in ( -1/* Да */
, 0/* Нет */ )) /* Для поиска */
/
alter  table MTZ.PARTVIEW add 
FilterField0
 VARCHAR2 (255) null /* Поле - фильтр 0 */
/
alter  table MTZ.PARTVIEW add 
FilterField1
 VARCHAR2 (255) null /* Поле - фильтр 1 */
/
alter  table MTZ.PARTVIEW add 
FilterField2
 VARCHAR2 (255) null /* Поле - фильтр 2 */
/
alter  table MTZ.PARTVIEW add 
FilterField3
 VARCHAR2 (255) null /* Поле - фильтр 3 */
/

/*Колонка*/
drop table MTZ.ViewColumn/*Колонка пердставления*/ 
/
create table MTZ.ViewColumn/*Колонка пердставления*/ (
ParentStructRowID CHAR(38) not null,
ViewColumnid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ViewColumn add 
sequence
 NUMBER null /* № */
/
alter  table MTZ.ViewColumn add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ViewColumn add 
the_Alias
 VARCHAR2 (64) null /* Псвдоним */
/
alter  table MTZ.ViewColumn add 
FromPart CHAR(38) null /* Раздел */
/
alter  table MTZ.ViewColumn add 
Field CHAR(38) null /* Поле */
/
alter  table MTZ.ViewColumn add 
Aggregation
 NUMBER null 
 check (Aggregation in ( 3/* SUM */
, 1/* AVG */
, 6/* CUSTOM */
, 0/* none */
, 2/* COUNT */
, 5/* MAX */
, 4/* MIN */ )) /* Агрегация */
/
alter  table MTZ.ViewColumn add 
Expression VARCHAR2(4000) null /* Формула */
/
alter  table MTZ.ViewColumn add 
ForCombo
 NUMBER null 
 check (ForCombo in ( -1/* Да */
, 0/* Нет */ )) /* Для комбо */
/

/*Связанные представления*/
drop table MTZ.PARTVIEW_LNK/**/ 
/
create table MTZ.PARTVIEW_LNK/**/ (
ParentStructRowID CHAR(38) not null,
PARTVIEW_LNKid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.PARTVIEW_LNK add 
TheView CHAR(38) null /* Представление */
/
alter  table MTZ.PARTVIEW_LNK add 
TheJoinSource CHAR(38) null /* Связь: Поле для join источник */
/
alter  table MTZ.PARTVIEW_LNK add 
RefType
 NUMBER null 
 check (RefType in ( 0/* Нет */
, 4/* Связка ParentStructRowID  (в передлах объекта) */
, 3/* Связка InstanceID (в передлах объекта) */
, 1/* Ссылка на объект */
, 2/* Ссылка на строку */ )) /* Связывать как */
/
alter  table MTZ.PARTVIEW_LNK add 
TheJoinDestination CHAR(38) null /* Свзяь: Поле для join приемник */
/
alter  table MTZ.PARTVIEW_LNK add 
HandJoin
 VARCHAR2 (255) null /* Ручной join */
/
alter  table MTZ.PARTVIEW_LNK add 
SEQ
 NUMBER null /* Порядок */
/

/*Логика на форме*/
drop table MTZ.VALIDATOR/*Действия в впроцессе редактирования*/ 
/
create table MTZ.VALIDATOR/*Действия в впроцессе редактирования*/ (
ParentStructRowID CHAR(38) not null,
VALIDATORid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.VALIDATOR add 
Target CHAR(38) null /* Целевая платформа */
/
alter  table MTZ.VALIDATOR add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Ограничение уникальности*/
drop table MTZ.UNIQUECONSTRAINT/*Ограничение уникальности*/ 
/
create table MTZ.UNIQUECONSTRAINT/*Ограничение уникальности*/ (
ParentStructRowID CHAR(38) not null,
UNIQUECONSTRAINTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.UNIQUECONSTRAINT add 
Name
 VARCHAR2 (80) null /* Название */
/
alter  table MTZ.UNIQUECONSTRAINT add 
PerParent
 NUMBER null 
 check (PerParent in ( -1/* Да */
, 0/* Нет */ )) /* По родителю */
/
alter  table MTZ.UNIQUECONSTRAINT add 
TheComment VARCHAR2(4000) null /* Описание */
/

/*Поля ограничения*/
drop table MTZ.CONSTRAINTFIELD/*Поля ограничения*/ 
/
create table MTZ.CONSTRAINTFIELD/*Поля ограничения*/ (
ParentStructRowID CHAR(38) not null,
CONSTRAINTFIELDid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.CONSTRAINTFIELD add 
TheField CHAR(38) null /* Поле */
/

/*Интерфейсы расширения*/
drop table MTZ.ExtenderInterface/**/ 
/
create table MTZ.ExtenderInterface/**/ (
ParentStructRowID CHAR(38) not null,
ExtenderInterfaceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ExtenderInterface add 
TheName
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ExtenderInterface add 
TargetPlatform CHAR(38) null /* Целевая платформа */
/
alter  table MTZ.ExtenderInterface add 
TheObject
 VARCHAR2 (255) null /* Объект */
/
alter  table MTZ.ExtenderInterface add 
TheConfig
 VARCHAR2 (512) null /* Конфиг */
/

/*Поле*/
drop table MTZ.FIELD/*Поле*/ 
/
create table MTZ.FIELD/*Поле*/ (
ParentStructRowID CHAR(38) not null,
FIELDid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELD add 
TabName
 VARCHAR2 (60) null /* Имя вкладки */
/
alter  table MTZ.FIELD add 
FieldGroupBox
 VARCHAR2 (60) null /* Имя группы */
/
alter  table MTZ.FIELD add 
Sequence
 NUMBER null /* № п/п */
/
alter  table MTZ.FIELD add 
Caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTZ.FIELD add 
Name
 VARCHAR2 (64) null /* Имя поля */
/
alter  table MTZ.FIELD add 
FieldType CHAR(38) null /* Тип поля */
/
alter  table MTZ.FIELD add 
IsBrief
 NUMBER null 
 check (IsBrief in ( -1/* Да */
, 0/* Нет */ )) /* Краткая информация */
/
alter  table MTZ.FIELD add 
IsTabBrief
 NUMBER null 
 check (IsTabBrief in ( -1/* Да */
, 0/* Нет */ )) /* Для отображения в таблице */
/
alter  table MTZ.FIELD add 
AllowNull
 NUMBER null 
 check (AllowNull in ( -1/* Да */
, 0/* Нет */ )) /* Может быть пустым */
/
alter  table MTZ.FIELD add 
DataSize
 NUMBER null /* Размер поля */
/
alter  table MTZ.FIELD add 
ReferenceType
 NUMBER null 
 check (ReferenceType in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTZ.FIELD add 
RefToType CHAR(38) null /* Ссылка на тип */
/
alter  table MTZ.FIELD add 
RefToPart CHAR(38) null /* Ссылка на раздел */
/
alter  table MTZ.FIELD add 
TheStyle
 VARCHAR2 (50) null /* Стиль */
/
alter  table MTZ.FIELD add 
InternalReference
 NUMBER null 
 check (InternalReference in ( -1/* Да */
, 0/* Нет */ )) /* Ссылка в пределах объекта */
/
alter  table MTZ.FIELD add 
CreateRefOnly
 NUMBER null 
 check (CreateRefOnly in ( -1/* Да */
, 0/* Нет */ )) /* Только создание объекта */
/
alter  table MTZ.FIELD add 
IsAutoNumber
 NUMBER null 
 check (IsAutoNumber in ( -1/* Да */
, 0/* Нет */ )) /* Автонумерация */
/
alter  table MTZ.FIELD add 
TheNumerator CHAR(38) null /* Нумератор */
/
alter  table MTZ.FIELD add 
ZoneTemplate
 VARCHAR2 (255) null /* Шаблон зоны нумерации */
/
alter  table MTZ.FIELD add 
NumberDateField CHAR(38) null /* Поле для расчета даты */
/
alter  table MTZ.FIELD add 
TheComment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.FIELD add 
shablonBrief
 VARCHAR2 (100) null /* Шаблон для краткого отображения */
/
alter  table MTZ.FIELD add 
theNameClass
 VARCHAR2 (100) null /* Имя класса для мастера строк */
/
alter  table MTZ.FIELD add 
TheMask
 VARCHAR2 (64) null /* Маска */
/

/*Интерфейсы расширения*/
drop table MTZ.FldExtenders/**/ 
/
create table MTZ.FldExtenders/**/ (
ParentStructRowID CHAR(38) not null,
FldExtendersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FldExtenders add 
TheName
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.FldExtenders add 
TargetPlatform CHAR(38) null /* Целевая платформа */
/
alter  table MTZ.FldExtenders add 
TheObject
 VARCHAR2 (255) null /* Объект */
/
alter  table MTZ.FldExtenders add 
TheConfig
 VARCHAR2 (512) null /* Конфиг */
/

/*Описание источника данных*/
drop table MTZ.FIELDSRCDEF/*Описание источника данных для полей типа ReferenceSQL */ 
/
create table MTZ.FIELDSRCDEF/*Описание источника данных для полей типа ReferenceSQL */ (
ParentStructRowID CHAR(38) not null,
FIELDSRCDEFid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDSRCDEF add 
Provider
 VARCHAR2 (128) null /* Провайдер */
/
alter  table MTZ.FIELDSRCDEF add 
ConnectionString
 VARCHAR2 (512) null /* Строка соединения с источником */
/
alter  table MTZ.FIELDSRCDEF add 
DataSource
 VARCHAR2 (512) null /* Источник данных */
/
alter  table MTZ.FIELDSRCDEF add 
IDField
 VARCHAR2 (128) null /* ID */
/
alter  table MTZ.FIELDSRCDEF add 
BriefString
 VARCHAR2 (512) null /* Источник краткой информации */
/
alter  table MTZ.FIELDSRCDEF add 
FilterString
 VARCHAR2 (512) null /* Фильтр источника данных */
/
alter  table MTZ.FIELDSRCDEF add 
SortField
 VARCHAR2 (512) null /* Сортировка источника данных */
/
alter  table MTZ.FIELDSRCDEF add 
DescriptionString VARCHAR2(4000) null /* Примечания */
/
alter  table MTZ.FIELDSRCDEF add 
DontShowDialog
 NUMBER null 
 check (DontShowDialog in ( 1/* Да */
, 0/* Нет */ )) /* Не показывать форму выбора */
/

/*Динамический фильтр*/
drop table MTZ.DINAMICFILTERSCRIPT/*Выражение для построения дополнительного фильтра для ссылочных полей*/ 
/
create table MTZ.DINAMICFILTERSCRIPT/*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
ParentStructRowID CHAR(38) not null,
DINAMICFILTERSCRIPTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.DINAMICFILTERSCRIPT add 
Target CHAR(38) null /* Целевая платформа */
/
alter  table MTZ.DINAMICFILTERSCRIPT add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Значение по умолчанию*/
drop table MTZ.FIELDEXPRESSION/*Выражение для вычисления поля
или значение по умолчанию*/ 
/
create table MTZ.FIELDEXPRESSION/*Выражение для вычисления поля
или значение по умолчанию*/ (
ParentStructRowID CHAR(38) not null,
FIELDEXPRESSIONid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDEXPRESSION add 
Target CHAR(38) null /* Платформа */
/
alter  table MTZ.FIELDEXPRESSION add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Логика поля на форме*/
drop table MTZ.FIELDVALIDATOR/*Логика взаимосвязей на форме при изменении поля*/ 
/
create table MTZ.FIELDVALIDATOR/*Логика взаимосвязей на форме при изменении поля*/ (
ParentStructRowID CHAR(38) not null,
FIELDVALIDATORid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDVALIDATOR add 
Target CHAR(38) null /* Платформа */
/
alter  table MTZ.FIELDVALIDATOR add 
Code VARCHAR2(4000) null /* Скрипт */
/

/*Методы поля*/
drop table MTZ.FIELDMENU/*Методы, ассоциированные с полем*/ 
/
create table MTZ.FIELDMENU/*Методы, ассоциированные с полем*/ (
ParentStructRowID CHAR(38) not null,
FIELDMENUid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDMENU add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.FIELDMENU add 
Caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTZ.FIELDMENU add 
ToolTip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTZ.FIELDMENU add 
ActionID CHAR(38) null /* Идентификатор вызываемого метода */
/
alter  table MTZ.FIELDMENU add 
IsMenuItem
 NUMBER null 
 check (IsMenuItem in ( -1/* Да */
, 0/* Нет */ )) /* В меню */
/
alter  table MTZ.FIELDMENU add 
IsToolBarButton
 NUMBER null 
 check (IsToolBarButton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
/
alter  table MTZ.FIELDMENU add 
HotKey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Отображение параметров*/
drop table MTZ.FIELDPARAMMAP/*Отображение значений на параметры метода*/ 
/
create table MTZ.FIELDPARAMMAP/*Отображение значений на параметры метода*/ (
ParentStructRowID CHAR(38) not null,
FIELDPARAMMAPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FIELDPARAMMAP add 
FieldName
 VARCHAR2 (255) null /* Поле (значение) */
/
alter  table MTZ.FIELDPARAMMAP add 
ParamName
 VARCHAR2 (80) null /* Параметр */
/
alter  table MTZ.FIELDPARAMMAP add 
NoEdit
 NUMBER null 
 check (NoEdit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
/

/*Приложение*/
drop table MTZ.MTZAPP/*Группа взаимосвязных документов*/ 
/
create table MTZ.MTZAPP/*Группа взаимосвязных документов*/ (
InstanceID CHAR(38) ,
MTZAPPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.MTZAPP add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.MTZAPP add 
DBName
 VARCHAR2 (64) null /* База данных */
/
alter  table MTZ.MTZAPP add 
TheComment VARCHAR2(4000) null /* Описание */
/

/*Обязательные приложения*/
drop table MTZ.ParentPackage/*Приложения от которых зависит данное приложение*/ 
/
create table MTZ.ParentPackage/*Приложения от которых зависит данное приложение*/ (
ParentStructRowID CHAR(38) not null,
ParentPackageid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ParentPackage add 
Package CHAR(38) null /* Приложение */
/

/*Колонки журнала*/
drop table MTZ.JournalColumn/*Колонки журнала*/ 
/
create table MTZ.JournalColumn/*Колонки журнала*/ (
InstanceID CHAR(38) ,
JournalColumnid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.JournalColumn add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTZ.JournalColumn add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.JournalColumn add 
ColumnAlignment
 NUMBER null 
 check (ColumnAlignment in ( 6/* Right Top */
, 7/* Right Center */
, 8/* Right Bottom */
, 3/* Center Top */
, 0/* Left Top */
, 4/* Center Center */
, 1/* Left Center */
, 5/* Center Bottom */
, 2/* Left Bottom */ )) /* Выравнивание */
/
alter  table MTZ.JournalColumn add 
ColSort
 NUMBER null 
 check (ColSort in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Сортировка колонки */
/
alter  table MTZ.JournalColumn add 
GroupAggregation
 NUMBER null 
 check (GroupAggregation in ( 3/* SUM */
, 1/* AVG */
, 6/* CUSTOM */
, 0/* none */
, 2/* COUNT */
, 5/* MAX */
, 4/* MIN */ )) /* Аггрегация при группировке */
/

/*Состав колонки*/
drop table MTZ.JColumnSource/*Состав колонки*/ 
/
create table MTZ.JColumnSource/*Состав колонки*/ (
ParentStructRowID CHAR(38) not null,
JColumnSourceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.JColumnSource add 
SrcPartView CHAR(38) null /* Представление */
/
alter  table MTZ.JColumnSource add 
ViewField
 VARCHAR2 (255) null /* Поле представления */
/

/*Источники журнала*/
drop table MTZ.JournalSrc/*Источники журнала*/ 
/
create table MTZ.JournalSrc/*Источники журнала*/ (
InstanceID CHAR(38) ,
JournalSrcid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.JournalSrc add 
PartView CHAR(38) null /* Представление */
/
alter  table MTZ.JournalSrc add 
OnRun
 NUMBER null 
 check (OnRun in ( 2/* Открыть документ */
, 0/* Ничего не делать */
, 1/* Открыть строку */ )) /* При открытии */
/
alter  table MTZ.JournalSrc add 
OpenMode
 VARCHAR2 (64) null /* Режим открытия */
/
alter  table MTZ.JournalSrc add 
ViewAlias
 VARCHAR2 (255) null /* Псевдоним представления */
/

/*Журнал*/
drop table MTZ.Journal/*Журнал*/ 
/
create table MTZ.Journal/*Журнал*/ (
InstanceID CHAR(38) ,
Journalid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Journal add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.Journal add 
the_Alias
 VARCHAR2 (32) null /* Псевдоним */
/
alter  table MTZ.Journal add 
TheComment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.Journal add 
jrnlIconCls
 VARCHAR2 (80) null /* Иконка журнала */
/
alter  table MTZ.Journal add 
UseFavorites
 NUMBER null 
 check (UseFavorites in ( -1/* Да */
, 0/* Нет */ )) /* Массовое выделение */
/

/*Типичные проблемы*/
drop table MTZ.tod_bug/**/ 
/
create table MTZ.tod_bug/**/ (
InstanceID CHAR(38) ,
tod_bugid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/

/*Станки*/
drop table MTZ.tod_st/**/ 
/
create table MTZ.tod_st/**/ (
InstanceID CHAR(38) ,
tod_stid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/

/*Папка*/
drop table MTZ.Folder/*Папка каталога*/ 
/
create table MTZ.Folder/*Папка каталога*/ (
InstanceID CHAR(38) ,
Folderid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTZ.Folder add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.Folder add 
FolderType
 NUMBER null 
 check (FolderType in ( 3/* Удаленные */
, 1/* Входящие */
, 9/* Отложенные */
, 4/* Журнал */
, 2/* Исходящие */
, 7/* Черновики */
, 6/* Отправленные */
, 8/* В работе */
, 5/* Календарь */
, 10/* Завершенные */
, 0/* cls__ */ )) /* Тип папки */
/

/*Документы*/
drop table MTZ.Shortcut/*Ярлыки документов*/ 
/
create table MTZ.Shortcut/*Ярлыки документов*/ (
ParentStructRowID CHAR(38) not null,
Shortcutid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Shortcut add 
DocItem CHAR(38) null /* Документ */
/
alter  table MTZ.Shortcut add 
StartMode
 VARCHAR2 (255) null /* Режим */
/

/*Описание*/
drop table MTZ.InfoStoreDef/*Описание каталога*/ 
/
create table MTZ.InfoStoreDef/*Описание каталога*/ (
InstanceID CHAR(38) ,
InfoStoreDefid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.InfoStoreDef add 
TheGroup CHAR(38) null /* Группа */
/
alter  table MTZ.InfoStoreDef add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.InfoStoreDef add 
InfoStoreType
 NUMBER null 
 check (InfoStoreType in ( 2/* Групповой */
, 0/*  Общий */
, 1/* Персональный */ )) /* Тип каталога */
/
alter  table MTZ.InfoStoreDef add 
TheUser CHAR(38) null /* Пользователь */
/

/*Сессия пользователя*/
drop table MTZ.the_Session/*Зарегистрированные сессии пользователей*/ 
/
create table MTZ.the_Session/*Зарегистрированные сессии пользователей*/ (
InstanceID CHAR(38) ,
the_Sessionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.the_Session add 
ApplicationID CHAR(38) null /* Приложение */
/
alter  table MTZ.the_Session add 
UserRole CHAR(38) null /* Текущая роль пользователя */
/
alter  table MTZ.the_Session add 
ClosedAt
 DATE null /* Момент закрытия */
/
alter  table MTZ.the_Session add 
Closed
 NUMBER null 
 check (Closed in ( 1/* Да */
, 0/* Нет */ )) /* Закрыта */
/
alter  table MTZ.the_Session add 
Usersid CHAR(38) null /* Пользователь */
/
alter  table MTZ.the_Session add 
LastAccess
 DATE null /* Последнее подтверждение */
/
alter  table MTZ.the_Session add 
StartAt
 DATE null /* Момент открытия */
/
alter  table MTZ.the_Session add 
Lang
 VARCHAR2 (25) null /* Локализация */
/
alter  table MTZ.the_Session add 
Login
 VARCHAR2 (255) null /* Login */
/

/*Разрешенные владельцы*/
drop table MTZ.SysRefCache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ 
/
create table MTZ.SysRefCache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
InstanceID CHAR(38) ,
SysRefCacheid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.SysRefCache add 
CacheType
 NUMBER null 
 check (CacheType in ( 2/* Все */
, 0/* Только свои */
, 1/* Подчиненные */ )) /* Тип кеширования */
/
alter  table MTZ.SysRefCache add 
ObjectOwnerID CHAR(38) null /* Идентификатор владельца */
/
alter  table MTZ.SysRefCache add 
SessionID CHAR(38) null /* Сессия */
/
alter  table MTZ.SysRefCache add 
modulename
 VARCHAR2 (40) null /* модуль */
/

/*Журнал событий*/
drop table MTZ.SysLog/*Журнал событий, которые произошли в системе*/ 
/
create table MTZ.SysLog/*Журнал событий, которые произошли в системе*/ (
InstanceID CHAR(38) ,
SysLogid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.SysLog add 
TheSession CHAR(38) null /* Сессия */
/
alter  table MTZ.SysLog add 
the_Resource
 VARCHAR2 (255) null /* Ресурс */
/
alter  table MTZ.SysLog add 
LogStructID
 VARCHAR2 (255) null /* Раздел с которым происхоит действие */
/
alter  table MTZ.SysLog add 
VERB
 VARCHAR2 (80) null /* Действие */
/
alter  table MTZ.SysLog add 
LogInstanceID CHAR(38) null /* Идентификатор документа */
/

/*Поведение журналов*/
drop table MTZ.ARMJournal/*Описание действий журанлов*/ 
/
create table MTZ.ARMJournal/*Описание действий журанлов*/ (
InstanceID CHAR(38) ,
ARMJournalid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ARMJournal add 
TheJournal CHAR(38) null /* Журнал */
/

/*Отчеты*/
drop table MTZ.ARMJRNLREP/*Отчеты из журнала*/ 
/
create table MTZ.ARMJRNLREP/*Отчеты из журнала*/ (
ParentStructRowID CHAR(38) not null,
ARMJRNLREPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ARMJRNLREP add 
repname
 VARCHAR2 (255) null /* Название отчета */
/
alter  table MTZ.ARMJRNLREP add 
TheReport CHAR(38) null /* Отчет */
/

/*Действия*/
drop table MTZ.ARMJRNLRUN/*Дополнительные действия в журнале*/ 
/
create table MTZ.ARMJRNLRUN/*Дополнительные действия в журнале*/ (
ParentStructRowID CHAR(38) not null,
ARMJRNLRUNid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ARMJRNLRUN add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ARMJRNLRUN add 
TheExtention CHAR(38) null /* Расширение */
/

/*Добавление*/
drop table MTZ.ARMJRNLADD/*Варианты обработки добавления*/ 
/
create table MTZ.ARMJRNLADD/*Варианты обработки добавления*/ (
ParentStructRowID CHAR(38) not null,
ARMJRNLADDid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ARMJRNLADD add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ARMJRNLADD add 
TheExtention CHAR(38) null /* Расширение */
/

/*Меню*/
drop table MTZ.EntryPoints/*Меню*/ 
/
create table MTZ.EntryPoints/*Меню*/ (
InstanceID CHAR(38) ,
EntryPointsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTZ.EntryPoints add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTZ.EntryPoints add 
Name
 VARCHAR2 (38) null /* Название */
/
alter  table MTZ.EntryPoints add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.EntryPoints add 
AsToolbarItem
 NUMBER null 
 check (AsToolbarItem in ( -1/* Да */
, 0/* Нет */ )) /* Включить в тулбар */
/
alter  table MTZ.EntryPoints add 
ActionType
 NUMBER null 
 check (ActionType in ( 4/* Запустить АРМ */
, 2/* Выполнить метод */
, 5/* Открыть отчет */
, 0/* Ничего не делать */
, 1/* Открыть документ */
, 3/* Открыть журнал */ )) /* Вариант действия */
/
alter  table MTZ.EntryPoints add 
TheFilter CHAR(38) null /* Фильтр */
/
alter  table MTZ.EntryPoints add 
Journal CHAR(38) null /* Журнал */
/
alter  table MTZ.EntryPoints add 
Report CHAR(38) null /* Отчет */
/
alter  table MTZ.EntryPoints add 
Document CHAR(38) null /* Документ */
/
alter  table MTZ.EntryPoints add 
Method CHAR(38) null /* Метод */
/
alter  table MTZ.EntryPoints add 
IconFile
 VARCHAR2 (2000) null /* Файл картинки */
/
alter  table MTZ.EntryPoints add 
TheExtention CHAR(38) null /* Расширение */
/
alter  table MTZ.EntryPoints add 
ARM CHAR(38) null /* АРМ */
/
alter  table MTZ.EntryPoints add 
TheComment VARCHAR2(4000) null /* Примечание */
/
alter  table MTZ.EntryPoints add 
ObjectType CHAR(38) null /* Тип документа */
/
alter  table MTZ.EntryPoints add 
JournalFixedQuery VARCHAR2(4000) null /* Ограничения к журналу */
/
alter  table MTZ.EntryPoints add 
AllowAdd
 NUMBER null 
 check (AllowAdd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавление */
/
alter  table MTZ.EntryPoints add 
AllowEdit
 NUMBER null 
 check (AllowEdit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено редактирование */
/
alter  table MTZ.EntryPoints add 
AllowDel
 NUMBER null 
 check (AllowDel in ( -1/* Да */
, 0/* Нет */ )) /* Рарешено удаление */
/
alter  table MTZ.EntryPoints add 
AllowFilter
 NUMBER null 
 check (AllowFilter in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен фильтр */
/
alter  table MTZ.EntryPoints add 
AllowPrint
 NUMBER null 
 check (AllowPrint in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена печать */
/

/*Привязка фильтра*/
drop table MTZ.EPFilterLink/*Привязка фильтра к журналу*/ 
/
create table MTZ.EPFilterLink/*Привязка фильтра к журналу*/ (
ParentStructRowID CHAR(38) not null,
EPFilterLinkid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.EPFilterLink add 
RowSource
 VARCHAR2 (255) null /* Источник */
/
alter  table MTZ.EPFilterLink add 
TheExpression VARCHAR2(4000) null /* Выражение */
/
alter  table MTZ.EPFilterLink add 
FilterField
 VARCHAR2 (255) null /* Поле фильтра */
/

/*Арм*/
drop table MTZ.WorkPlace/*Арм*/ 
/
create table MTZ.WorkPlace/*Арм*/ (
InstanceID CHAR(38) ,
WorkPlaceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.WorkPlace add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.WorkPlace add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.WorkPlace add 
TheVersion
 VARCHAR2 (30) null /* Версия */
/
alter  table MTZ.WorkPlace add 
ThePlatform
 NUMBER null 
 check (ThePlatform in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Платформа реализации */
/
alter  table MTZ.WorkPlace add 
TheComment VARCHAR2(4000) null /* Примечание */
/

/*Список типов*/
drop table MTZ.ARMTypes/*Типы документов, которые подключаются в MDI режиме*/ 
/
create table MTZ.ARMTypes/*Типы документов, которые подключаются в MDI режиме*/ (
InstanceID CHAR(38) ,
ARMTypesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ARMTypes add 
TheDocumentType CHAR(38) null /* Тип документа */
/

/*Доступные действия*/
drop table MTZ.ROLES_OPERATIONS/*Именованные операции*/ 
/
create table MTZ.ROLES_OPERATIONS/*Именованные операции*/ (
InstanceID CHAR(38) ,
ROLES_OPERATIONSid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_OPERATIONS add 
info
 VARCHAR2 (256) null /* Описание */
/
alter  table MTZ.ROLES_OPERATIONS add 
AllowAction
 NUMBER null 
 check (AllowAction in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено */
/
alter  table MTZ.ROLES_OPERATIONS add 
Name
 VARCHAR2 (255) null /* Код */
/

/*Доступные приложения*/
drop table MTZ.ROLES_WP/*Доступные приложения*/ 
/
create table MTZ.ROLES_WP/*Доступные приложения*/ (
InstanceID CHAR(38) ,
ROLES_WPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_WP add 
WP CHAR(38) null /* Приложение */
/

/*Разрешенные пункты меню*/
drop table MTZ.ROLES_ACT/*Разрешенные пункты меню*/ 
/
create table MTZ.ROLES_ACT/*Разрешенные пункты меню*/ (
ParentStructRowID CHAR(38) not null,
ROLES_ACTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_ACT add 
Accesible
 NUMBER null 
 check (Accesible in ( 1/* Да */
, 0/* Нет */ )) /* Доступность */
/
alter  table MTZ.ROLES_ACT add 
MenuName
 VARCHAR2 (255) null /* Меню */
/
alter  table MTZ.ROLES_ACT add 
menuCode
 VARCHAR2 (255) null /* Код пункта меню */
/

/*Модули*/
drop table MTZ.ROLES2_MODULE/**/ 
/
create table MTZ.ROLES2_MODULE/**/ (
InstanceID CHAR(38) ,
ROLES2_MODULEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES2_MODULE add 
GroupName
 VARCHAR2 (60) null /* Имя группы */
/
alter  table MTZ.ROLES2_MODULE add 
Caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTZ.ROLES2_MODULE add 
Sequence
 NUMBER null /* № п/п */
/
alter  table MTZ.ROLES2_MODULE add 
ModuleAccessible
 NUMBER null 
 check (ModuleAccessible in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен */
/
alter  table MTZ.ROLES2_MODULE add 
CustomizeVisibility
 NUMBER null 
 check (CustomizeVisibility in ( -1/* Да */
, 0/* Нет */ )) /* Настраивать видимость */
/
alter  table MTZ.ROLES2_MODULE add 
TheIcon
 VARCHAR2 (64) null /* Иконка */
/
alter  table MTZ.ROLES2_MODULE add 
name
 VARCHAR2 (255) null /* Код модуля */
/
alter  table MTZ.ROLES2_MODULE add 
TheComment VARCHAR2(4000) null /* Описание */
/
alter  table MTZ.ROLES2_MODULE add 
AllObjects
 NUMBER null 
 check (AllObjects in ( -1/* Да */
, 0/* Нет */ )) /* Вся фирма */
/
alter  table MTZ.ROLES2_MODULE add 
ColegsObject
 NUMBER null 
 check (ColegsObject in ( -1/* Да */
, 0/* Нет */ )) /* Объекты коллег */
/
alter  table MTZ.ROLES2_MODULE add 
SubStructObjects
 NUMBER null 
 check (SubStructObjects in ( -1/* Да */
, 0/* Нет */ )) /* Подчиненные подразделения */
/

/*Действия и отчеты*/
drop table MTZ.ROLES2_MODREPORT/**/ 
/
create table MTZ.ROLES2_MODREPORT/**/ (
ParentStructRowID CHAR(38) not null,
ROLES2_MODREPORTid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES2_MODREPORT add 
Name
 VARCHAR2 (64) null /* Код */
/
alter  table MTZ.ROLES2_MODREPORT add 
AllowAction
 NUMBER null 
 check (AllowAction in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен */
/
alter  table MTZ.ROLES2_MODREPORT add 
Caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTZ.ROLES2_MODREPORT add 
Sequence
 NUMBER null /* № п/п */
/
alter  table MTZ.ROLES2_MODREPORT add 
TheIcon
 VARCHAR2 (64) null /* Иконка */
/
alter  table MTZ.ROLES2_MODREPORT add 
IsReport
 NUMBER null 
 check (IsReport in ( -1/* Да */
, 0/* Нет */ )) /* Это отчет */
/
alter  table MTZ.ROLES2_MODREPORT add 
selectType
 NUMBER null /* Вариант выбора */
/

/*Доступные документы*/
drop table MTZ.ROLES_DOC/**/ 
/
create table MTZ.ROLES_DOC/**/ (
InstanceID CHAR(38) ,
ROLES_DOCid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_DOC add 
The_Document CHAR(38) null /* Тип документа */
/
alter  table MTZ.ROLES_DOC add 
The_Denied
 NUMBER null 
 check (The_Denied in ( 1/* Да */
, 0/* Нет */ )) /* Запрещен */
/
alter  table MTZ.ROLES_DOC add 
AllowDeleteDoc
 NUMBER null 
 check (AllowDeleteDoc in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удаление */
/

/*Доступные состояния*/
drop table MTZ.ROLES_DOC_STATE/**/ 
/
create table MTZ.ROLES_DOC_STATE/**/ (
ParentStructRowID CHAR(38) not null,
ROLES_DOC_STATEid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_DOC_STATE add 
The_State CHAR(38) null /* Состояние */
/
alter  table MTZ.ROLES_DOC_STATE add 
The_Mode CHAR(38) null /* Режим */
/
alter  table MTZ.ROLES_DOC_STATE add 
AllowDelete
 NUMBER null 
 check (AllowDelete in ( -1/* Да */
, 0/* Нет */ )) /* Можно удалять */
/
alter  table MTZ.ROLES_DOC_STATE add 
StateChangeDisabled
 NUMBER null 
 check (StateChangeDisabled in ( -1/* Да */
, 0/* Нет */ )) /* Запрещена смена состояния */
/

/*Отчёты*/
drop table MTZ.ROLES_REPORTS/**/ 
/
create table MTZ.ROLES_REPORTS/**/ (
InstanceID CHAR(38) ,
ROLES_REPORTSid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_REPORTS add 
The_Report CHAR(38) null /* Отчёт */
/

/*Пользователи*/
drop table MTZ.ROLES_USER/*Пользователи*/ 
/
create table MTZ.ROLES_USER/*Пользователи*/ (
InstanceID CHAR(38) ,
ROLES_USERid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_USER add 
TheUser CHAR(38) null /* Пользователь */
/

/*Отображение на группы*/
drop table MTZ.ROLES_MAP/*Отображение на группы защиты*/ 
/
create table MTZ.ROLES_MAP/*Отображение на группы защиты*/ (
InstanceID CHAR(38) ,
ROLES_MAPid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_MAP add 
TheGroup CHAR(38) null /* Группа */
/

/*Определение роли*/
drop table MTZ.ROLES_DEF/*Определение роли*/ 
/
create table MTZ.ROLES_DEF/*Определение роли*/ (
InstanceID CHAR(38) ,
ROLES_DEFid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.ROLES_DEF add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.ROLES_DEF add 
AllObjects
 NUMBER null 
 check (AllObjects in ( -1/* Да */
, 0/* Нет */ )) /* Вся фирма */
/
alter  table MTZ.ROLES_DEF add 
ColegsObject
 NUMBER null 
 check (ColegsObject in ( -1/* Да */
, 0/* Нет */ )) /* Объекты коллег */
/
alter  table MTZ.ROLES_DEF add 
SubStructObjects
 NUMBER null 
 check (SubStructObjects in ( -1/* Да */
, 0/* Нет */ )) /* Подчиненные подразделения */
/

/*Пользователи*/
drop table MTZ.Users/*Пользователи*/ 
/
create table MTZ.Users/*Пользователи*/ (
InstanceID CHAR(38) ,
Usersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Users add 
Family
 VARCHAR2 (255) null /* Фамилия */
/
alter  table MTZ.Users add 
Name
 VARCHAR2 (64) null /* Имя */
/
alter  table MTZ.Users add 
SurName
 VARCHAR2 (255) null /* Отчество */
/
alter  table MTZ.Users add 
Login
 VARCHAR2 (64) null /* Имя для входа */
/
alter  table MTZ.Users add 
Password VARCHAR2(80) null /* Пароль */
/
alter  table MTZ.Users add 
DomaiName
 VARCHAR2 (255) null /* Доменное имя */
/
alter  table MTZ.Users add 
EMail VARCHAR2(255) null /* e-mail */
/
alter  table MTZ.Users add 
Phone
 VARCHAR2 (20) null /* Телефон */
/
alter  table MTZ.Users add 
LocalPhone
 VARCHAR2 (20) null /* Местный телефон */
/

/*Группы*/
drop table MTZ.Groups/*Группы*/ 
/
create table MTZ.Groups/*Группы*/ (
InstanceID CHAR(38) ,
Groupsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Groups add 
Name
 VARCHAR2 (80) null /* Название */
/
alter  table MTZ.Groups add 
ADGroup
 VARCHAR2 (255) null /* Группа AD */
/

/*Состав группы*/
drop table MTZ.GroupUser/*Состав группы*/ 
/
create table MTZ.GroupUser/*Состав группы*/ (
ParentStructRowID CHAR(38) not null,
GroupUserid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.GroupUser add 
TheUser CHAR(38) null /* Пользователь */
/

/*Зоны*/
drop table MTZ.Num_zones/*Зоны уникальных нумеров*/ 
/
create table MTZ.Num_zones/*Зоны уникальных нумеров*/ (
InstanceID CHAR(38) ,
Num_zonesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Num_zones add 
ZoneMask
 VARCHAR2 (255) null /* Маска зоны */
/

/*Номера*/
drop table MTZ.Num_Values/*уникальные номера*/ 
/
create table MTZ.Num_Values/*уникальные номера*/ (
ParentStructRowID CHAR(38) not null,
Num_Valuesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Num_Values add 
the_Value
 NUMBER null /* Значение */
/
alter  table MTZ.Num_Values add 
OwnerPartName
 VARCHAR2 (64) null /* Раздел */
/
alter  table MTZ.Num_Values add 
OwnerRowID CHAR(38) null /* Идентификатор строки */
/

/*Описание*/
drop table MTZ.Num_head/*Описание нумератора*/ 
/
create table MTZ.Num_head/*Описание нумератора*/ (
InstanceID CHAR(38) ,
Num_headid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Num_head add 
Name
 VARCHAR2 (80) null /* Название */
/
alter  table MTZ.Num_head add 
Shema
 NUMBER null 
 check (Shema in ( 2/* По кварталу */
, 3/* По месяцу */
, 0/* Единая зона */
, 4/* По дню */
, 1/* По году */
, 10/* Произвольные зоны */ )) /* Схема нумерации */
/

/*Описание*/
drop table MTZ.MTZExt_def/*Список зарегистрированных расширений*/ 
/
create table MTZ.MTZExt_def/*Список зарегистрированных расширений*/ (
InstanceID CHAR(38) ,
MTZExt_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.MTZExt_def add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.MTZExt_def add 
ExtType
 NUMBER null 
 check (ExtType in ( 6/* VerifyRowExt */
, 7/* CodeGenerator */
, 5/* DefaultExt */
, 0/* StatusExt */
, 4/* JrnlRunExt */
, 2/* CustomExt */
, 8/* ARMGenerator */
, 1/* OnFormExt */
, 3/* JrnlAddExt */ )) /* Тип расширения */
/
alter  table MTZ.MTZExt_def add 
TheDescription VARCHAR2(4000) null /* Описание */
/

/*Реализации расширения*/
drop table MTZ.MTZExtRel/*Реализации расширения для разных разработческих плаформ*/ 
/
create table MTZ.MTZExtRel/*Реализации расширения для разных разработческих плаформ*/ (
InstanceID CHAR(38) ,
MTZExtRelid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.MTZExtRel add 
ThePlatform
 NUMBER null 
 check (ThePlatform in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Реализация */
/
alter  table MTZ.MTZExtRel add 
TheClassName
 VARCHAR2 (255) null /* Название класса */
/
alter  table MTZ.MTZExtRel add 
TheLibraryName
 VARCHAR2 (255) null /* Название библиотеки */
/

/*Отложенное событие*/
drop table MTZ.MTZ2JOB_DEF/*Описание отложенного события*/ 
/
create table MTZ.MTZ2JOB_DEF/*Описание отложенного события*/ (
InstanceID CHAR(38) ,
MTZ2JOB_DEFid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.MTZ2JOB_DEF add 
EventDate
 DATE null /* Отложено до */
/
alter  table MTZ.MTZ2JOB_DEF add 
EvenType
 VARCHAR2 (255) null /* Тип события */
/
alter  table MTZ.MTZ2JOB_DEF add 
ThruObject CHAR(38) null /* Объект - причина события */
/
alter  table MTZ.MTZ2JOB_DEF add 
ThruState CHAR(38) null /* Состояние - причина */
/
alter  table MTZ.MTZ2JOB_DEF add 
NextState CHAR(38) null /* Состояние после обработки */
/
alter  table MTZ.MTZ2JOB_DEF add 
ProcessDate
 DATE null /* Момент обработки */
/
alter  table MTZ.MTZ2JOB_DEF add 
Processed
 NUMBER null 
 check (Processed in ( -1/* Да */
, 0/* Нет */ )) /* Обработан */
/

/*Группа полей фильтра*/
drop table MTZ.FilterFieldGroup/*Группа полей фильтра*/ 
/
create table MTZ.FilterFieldGroup/*Группа полей фильтра*/ (
InstanceID CHAR(38) ,
FilterFieldGroupid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FilterFieldGroup add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTZ.FilterFieldGroup add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.FilterFieldGroup add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.FilterFieldGroup add 
AllowIgnore
 NUMBER null 
 check (AllowIgnore in ( -1/* Да */
, 0/* Нет */ )) /* Можно отключать */
/

/*Поле фильтра*/
drop table MTZ.FileterField/*Поле фильтра*/ 
/
create table MTZ.FileterField/*Поле фильтра*/ (
ParentStructRowID CHAR(38) not null,
FileterFieldid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.FileterField add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTZ.FileterField add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.FileterField add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.FileterField add 
FieldType CHAR(38) null /* Тип поля */
/
alter  table MTZ.FileterField add 
FieldSize
 NUMBER null /* Размер */
/
alter  table MTZ.FileterField add 
RefType
 NUMBER null 
 check (RefType in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTZ.FileterField add 
RefToType CHAR(38) null /* Тип, куда ссылаемся */
/
alter  table MTZ.FileterField add 
RefToPart CHAR(38) null /* Раздел, куда ссылаемся */
/
alter  table MTZ.FileterField add 
ValueArray
 NUMBER null 
 check (ValueArray in ( -1/* Да */
, 0/* Нет */ )) /* Массив значений */
/

/*Фильтр*/
drop table MTZ.Filters/*Фильтр*/ 
/
create table MTZ.Filters/*Фильтр*/ (
InstanceID CHAR(38) ,
Filtersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Filters add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.Filters add 
TheCaption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTZ.Filters add 
TheComment VARCHAR2(4000) null /* Описание */
/

/*Секции*/
drop table MTZ.RPTStruct/*Секции*/ 
/
create table MTZ.RPTStruct/*Секции*/ (
InstanceID CHAR(38) ,
RPTStructid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTZ.RPTStruct add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.RPTStruct add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/

/*Поля секции*/
drop table MTZ.RPTFields/*Поля секции*/ 
/
create table MTZ.RPTFields/*Поля секции*/ (
ParentStructRowID CHAR(38) not null,
RPTFieldsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.RPTFields add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.RPTFields add 
FieldType CHAR(38) null /* Тип поля */
/
alter  table MTZ.RPTFields add 
FieldSize
 NUMBER null /* Размер */
/
alter  table MTZ.RPTFields add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/

/*Формулы*/
drop table MTZ.RPTFormula/*Формулы*/ 
/
create table MTZ.RPTFormula/*Формулы*/ (
InstanceID CHAR(38) ,
RPTFormulaid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.RPTFormula add 
Name
 VARCHAR2 (64) null /* Название */
/
alter  table MTZ.RPTFormula add 
Code VARCHAR2(4000) null /* Выражение */
/
alter  table MTZ.RPTFormula add 
Platform CHAR(38) null /* Платформа */
/

/*Описание*/
drop table MTZ.Reports/*Описание*/ 
/
create table MTZ.Reports/*Описание*/ (
InstanceID CHAR(38) ,
Reportsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTZ.Reports add 
Name
 VARCHAR2 (255) null /* Название */
/
alter  table MTZ.Reports add 
ReportFile VARCHAR2(4000) null /* Файл отчета */
/
alter  table MTZ.Reports add 
 ReportFile_EXT varchar2(4) null
/
alter  table MTZ.Reports add 
Caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTZ.Reports add 
PrepareMethod CHAR(38) null /* Метод для формирования */
/
alter  table MTZ.Reports add 
ReportType
 NUMBER null 
 check (ReportType in ( 4/* Экспорт по Excel шаблону */
, 0/* Таблица */
, 3/* Экспорт по WORD шаблону */
, 1/* Двумерная матрица */
, 2/* Только расчет */ )) /* Тип отчета */
/
alter  table MTZ.Reports add 
TheReportExt CHAR(38) null /* Расширение для создания отчета */
/
alter  table MTZ.Reports add 
ReportView
 VARCHAR2 (255) null /* Базовый запрос */
/
alter  table MTZ.Reports add 
TheComment VARCHAR2(4000) null /* Описание */
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ForeignKey" BlockCode=" 

alter  TABLE GENPACKAGE DROP CONSTRAINT fk_0
/
alter  table MTZ.GENPACKAGE add constraint fk_0 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE GENERATOR_TARGET DROP CONSTRAINT fk_1
/
alter  table MTZ.GENERATOR_TARGET add constraint fk_1 foreign key(ParentStructRowID) references MTZ.GENPACKAGE (GENPACKAGEID)
/

alter  TABLE GENREFERENCE DROP CONSTRAINT fk_2
/
alter  table MTZ.GENREFERENCE add constraint fk_2 foreign key(ParentStructRowID) references MTZ.GENERATOR_TARGET (GENERATOR_TARGETID)
/

alter  TABLE GENMANUALCODE DROP CONSTRAINT fk_3
/
alter  table MTZ.GENMANUALCODE add constraint fk_3 foreign key(ParentStructRowID) references MTZ.GENERATOR_TARGET (GENERATOR_TARGETID)
/

alter  TABLE GENCONTROLS DROP CONSTRAINT fk_4
/
alter  table MTZ.GENCONTROLS add constraint fk_4 foreign key(ParentStructRowID) references MTZ.GENERATOR_TARGET (GENERATOR_TARGETID)
/

alter  TABLE LocalizeInfo DROP CONSTRAINT fk_5
/
alter  table MTZ.LocalizeInfo add constraint fk_5 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE FIELDTYPE DROP CONSTRAINT fk_6
/
alter  table MTZ.FIELDTYPE add constraint fk_6 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ENUMITEM DROP CONSTRAINT fk_7
/
alter  table MTZ.ENUMITEM add constraint fk_7 foreign key(ParentStructRowID) references MTZ.FIELDTYPE (FIELDTYPEID)
/

alter  TABLE FIELDTYPEMAP DROP CONSTRAINT fk_8
/
alter  table MTZ.FIELDTYPEMAP add constraint fk_8 foreign key(ParentStructRowID) references MTZ.FIELDTYPE (FIELDTYPEID)
/

alter  TABLE SHAREDMETHOD DROP CONSTRAINT fk_9
/
alter  table MTZ.SHAREDMETHOD add constraint fk_9 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE SCRIPT DROP CONSTRAINT fk_10
/
alter  table MTZ.SCRIPT add constraint fk_10 foreign key(ParentStructRowID) references MTZ.SHAREDMETHOD (SHAREDMETHODID)
/

alter  TABLE PARAMETERS DROP CONSTRAINT fk_11
/
alter  table MTZ.PARAMETERS add constraint fk_11 foreign key(ParentStructRowID) references MTZ.SCRIPT (SCRIPTID)
/

alter  TABLE OBJECTTYPE DROP CONSTRAINT fk_12
/
alter  table MTZ.OBJECTTYPE add constraint fk_12 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE OBJSTATUS DROP CONSTRAINT fk_13
/
alter  table MTZ.OBJSTATUS add constraint fk_13 foreign key(ParentStructRowID) references MTZ.OBJECTTYPE (OBJECTTYPEID)
/

alter  TABLE NEXTSTATE DROP CONSTRAINT fk_14
/
alter  table MTZ.NEXTSTATE add constraint fk_14 foreign key(ParentStructRowID) references MTZ.OBJSTATUS (OBJSTATUSID)
/

alter  TABLE OBJECTMODE DROP CONSTRAINT fk_15
/
alter  table MTZ.OBJECTMODE add constraint fk_15 foreign key(ParentStructRowID) references MTZ.OBJECTTYPE (OBJECTTYPEID)
/

alter  TABLE STRUCTRESTRICTION DROP CONSTRAINT fk_16
/
alter  table MTZ.STRUCTRESTRICTION add constraint fk_16 foreign key(ParentStructRowID) references MTZ.OBJECTMODE (OBJECTMODEID)
/

alter  TABLE METHODRESTRICTION DROP CONSTRAINT fk_17
/
alter  table MTZ.METHODRESTRICTION add constraint fk_17 foreign key(ParentStructRowID) references MTZ.OBJECTMODE (OBJECTMODEID)
/

alter  TABLE FIELDRESTRICTION DROP CONSTRAINT fk_18
/
alter  table MTZ.FIELDRESTRICTION add constraint fk_18 foreign key(ParentStructRowID) references MTZ.OBJECTMODE (OBJECTMODEID)
/

alter  TABLE TYPEMENU DROP CONSTRAINT fk_19
/
alter  table MTZ.TYPEMENU add constraint fk_19 foreign key(ParentStructRowID) references MTZ.OBJECTTYPE (OBJECTTYPEID)
/

alter  TABLE INSTANCEVALIDATOR DROP CONSTRAINT fk_20
/
alter  table MTZ.INSTANCEVALIDATOR add constraint fk_20 foreign key(ParentStructRowID) references MTZ.OBJECTTYPE (OBJECTTYPEID)
/

alter  TABLE PART DROP CONSTRAINT fk_21
/
alter  table MTZ.PART add constraint fk_21 foreign key(ParentStructRowID) references MTZ.OBJECTTYPE (OBJECTTYPEID)
/

alter  TABLE PARTMENU DROP CONSTRAINT fk_22
/
alter  table MTZ.PARTMENU add constraint fk_22 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE PARTPARAMMAP DROP CONSTRAINT fk_23
/
alter  table MTZ.PARTPARAMMAP add constraint fk_23 foreign key(ParentStructRowID) references MTZ.PARTMENU (PARTMENUID)
/

alter  TABLE PARTVIEW DROP CONSTRAINT fk_24
/
alter  table MTZ.PARTVIEW add constraint fk_24 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE ViewColumn DROP CONSTRAINT fk_25
/
alter  table MTZ.ViewColumn add constraint fk_25 foreign key(ParentStructRowID) references MTZ.PARTVIEW (PARTVIEWID)
/

alter  TABLE PARTVIEW_LNK DROP CONSTRAINT fk_26
/
alter  table MTZ.PARTVIEW_LNK add constraint fk_26 foreign key(ParentStructRowID) references MTZ.PARTVIEW (PARTVIEWID)
/

alter  TABLE VALIDATOR DROP CONSTRAINT fk_27
/
alter  table MTZ.VALIDATOR add constraint fk_27 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE UNIQUECONSTRAINT DROP CONSTRAINT fk_28
/
alter  table MTZ.UNIQUECONSTRAINT add constraint fk_28 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE CONSTRAINTFIELD DROP CONSTRAINT fk_29
/
alter  table MTZ.CONSTRAINTFIELD add constraint fk_29 foreign key(ParentStructRowID) references MTZ.UNIQUECONSTRAINT (UNIQUECONSTRAINTID)
/

alter  TABLE ExtenderInterface DROP CONSTRAINT fk_30
/
alter  table MTZ.ExtenderInterface add constraint fk_30 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE FIELD DROP CONSTRAINT fk_31
/
alter  table MTZ.FIELD add constraint fk_31 foreign key(ParentStructRowID) references MTZ.PART (PARTID)
/

alter  TABLE FldExtenders DROP CONSTRAINT fk_32
/
alter  table MTZ.FldExtenders add constraint fk_32 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE FIELDSRCDEF DROP CONSTRAINT fk_33
/
alter  table MTZ.FIELDSRCDEF add constraint fk_33 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE DINAMICFILTERSCRIPT DROP CONSTRAINT fk_34
/
alter  table MTZ.DINAMICFILTERSCRIPT add constraint fk_34 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE FIELDEXPRESSION DROP CONSTRAINT fk_35
/
alter  table MTZ.FIELDEXPRESSION add constraint fk_35 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE FIELDVALIDATOR DROP CONSTRAINT fk_36
/
alter  table MTZ.FIELDVALIDATOR add constraint fk_36 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE FIELDMENU DROP CONSTRAINT fk_37
/
alter  table MTZ.FIELDMENU add constraint fk_37 foreign key(ParentStructRowID) references MTZ.FIELD (FIELDID)
/

alter  TABLE FIELDPARAMMAP DROP CONSTRAINT fk_38
/
alter  table MTZ.FIELDPARAMMAP add constraint fk_38 foreign key(ParentStructRowID) references MTZ.FIELDMENU (FIELDMENUID)
/

alter  TABLE MTZAPP DROP CONSTRAINT fk_39
/
alter  table MTZ.MTZAPP add constraint fk_39 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ParentPackage DROP CONSTRAINT fk_40
/
alter  table MTZ.ParentPackage add constraint fk_40 foreign key(ParentStructRowID) references MTZ.MTZAPP (MTZAPPID)
/

alter  TABLE JournalColumn DROP CONSTRAINT fk_41
/
alter  table MTZ.JournalColumn add constraint fk_41 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE JColumnSource DROP CONSTRAINT fk_42
/
alter  table MTZ.JColumnSource add constraint fk_42 foreign key(ParentStructRowID) references MTZ.JournalColumn (JournalColumnID)
/

alter  TABLE JournalSrc DROP CONSTRAINT fk_43
/
alter  table MTZ.JournalSrc add constraint fk_43 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Journal DROP CONSTRAINT fk_44
/
alter  table MTZ.Journal add constraint fk_44 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE tod_bug DROP CONSTRAINT fk_113
/
alter  table MTZ.tod_bug add constraint fk_113 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE tod_st DROP CONSTRAINT fk_114
/
alter  table MTZ.tod_st add constraint fk_114 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Folder DROP CONSTRAINT fk_53
/
alter  table MTZ.Folder add constraint fk_53 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Shortcut DROP CONSTRAINT fk_54
/
alter  table MTZ.Shortcut add constraint fk_54 foreign key(ParentStructRowID) references MTZ.Folder (FolderID)
/

alter  TABLE InfoStoreDef DROP CONSTRAINT fk_55
/
alter  table MTZ.InfoStoreDef add constraint fk_55 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE the_Session DROP CONSTRAINT fk_60
/
alter  table MTZ.the_Session add constraint fk_60 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE SysRefCache DROP CONSTRAINT fk_61
/
alter  table MTZ.SysRefCache add constraint fk_61 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE SysLog DROP CONSTRAINT fk_62
/
alter  table MTZ.SysLog add constraint fk_62 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ARMJournal DROP CONSTRAINT fk_63
/
alter  table MTZ.ARMJournal add constraint fk_63 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ARMJRNLREP DROP CONSTRAINT fk_64
/
alter  table MTZ.ARMJRNLREP add constraint fk_64 foreign key(ParentStructRowID) references MTZ.ARMJournal (ARMJournalID)
/

alter  TABLE ARMJRNLRUN DROP CONSTRAINT fk_65
/
alter  table MTZ.ARMJRNLRUN add constraint fk_65 foreign key(ParentStructRowID) references MTZ.ARMJournal (ARMJournalID)
/

alter  TABLE ARMJRNLADD DROP CONSTRAINT fk_66
/
alter  table MTZ.ARMJRNLADD add constraint fk_66 foreign key(ParentStructRowID) references MTZ.ARMJournal (ARMJournalID)
/

alter  TABLE EntryPoints DROP CONSTRAINT fk_67
/
alter  table MTZ.EntryPoints add constraint fk_67 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE EPFilterLink DROP CONSTRAINT fk_68
/
alter  table MTZ.EPFilterLink add constraint fk_68 foreign key(ParentStructRowID) references MTZ.EntryPoints (EntryPointsID)
/

alter  TABLE WorkPlace DROP CONSTRAINT fk_69
/
alter  table MTZ.WorkPlace add constraint fk_69 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ARMTypes DROP CONSTRAINT fk_70
/
alter  table MTZ.ARMTypes add constraint fk_70 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_OPERATIONS DROP CONSTRAINT fk_71
/
alter  table MTZ.ROLES_OPERATIONS add constraint fk_71 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_WP DROP CONSTRAINT fk_72
/
alter  table MTZ.ROLES_WP add constraint fk_72 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_ACT DROP CONSTRAINT fk_73
/
alter  table MTZ.ROLES_ACT add constraint fk_73 foreign key(ParentStructRowID) references MTZ.ROLES_WP (ROLES_WPID)
/

alter  TABLE ROLES2_MODULE DROP CONSTRAINT fk_74
/
alter  table MTZ.ROLES2_MODULE add constraint fk_74 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES2_MODREPORT DROP CONSTRAINT fk_75
/
alter  table MTZ.ROLES2_MODREPORT add constraint fk_75 foreign key(ParentStructRowID) references MTZ.ROLES2_MODULE (ROLES2_MODULEID)
/

alter  TABLE ROLES_DOC DROP CONSTRAINT fk_76
/
alter  table MTZ.ROLES_DOC add constraint fk_76 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_DOC_STATE DROP CONSTRAINT fk_77
/
alter  table MTZ.ROLES_DOC_STATE add constraint fk_77 foreign key(ParentStructRowID) references MTZ.ROLES_DOC (ROLES_DOCID)
/

alter  TABLE ROLES_REPORTS DROP CONSTRAINT fk_78
/
alter  table MTZ.ROLES_REPORTS add constraint fk_78 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_USER DROP CONSTRAINT fk_79
/
alter  table MTZ.ROLES_USER add constraint fk_79 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_MAP DROP CONSTRAINT fk_80
/
alter  table MTZ.ROLES_MAP add constraint fk_80 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE ROLES_DEF DROP CONSTRAINT fk_81
/
alter  table MTZ.ROLES_DEF add constraint fk_81 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Users DROP CONSTRAINT fk_85
/
alter  table MTZ.Users add constraint fk_85 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Groups DROP CONSTRAINT fk_86
/
alter  table MTZ.Groups add constraint fk_86 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE GroupUser DROP CONSTRAINT fk_87
/
alter  table MTZ.GroupUser add constraint fk_87 foreign key(ParentStructRowID) references MTZ.Groups (GroupsID)
/

alter  TABLE Num_zones DROP CONSTRAINT fk_88
/
alter  table MTZ.Num_zones add constraint fk_88 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Num_Values DROP CONSTRAINT fk_89
/
alter  table MTZ.Num_Values add constraint fk_89 foreign key(ParentStructRowID) references MTZ.Num_zones (Num_zonesID)
/

alter  TABLE Num_head DROP CONSTRAINT fk_90
/
alter  table MTZ.Num_head add constraint fk_90 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE MTZExt_def DROP CONSTRAINT fk_92
/
alter  table MTZ.MTZExt_def add constraint fk_92 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE MTZExtRel DROP CONSTRAINT fk_93
/
alter  table MTZ.MTZExtRel add constraint fk_93 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE MTZ2JOB_DEF DROP CONSTRAINT fk_105
/
alter  table MTZ.MTZ2JOB_DEF add constraint fk_105 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE FilterFieldGroup DROP CONSTRAINT fk_106
/
alter  table MTZ.FilterFieldGroup add constraint fk_106 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE FileterField DROP CONSTRAINT fk_107
/
alter  table MTZ.FileterField add constraint fk_107 foreign key(ParentStructRowID) references MTZ.FilterFieldGroup (FilterFieldGroupID)
/

alter  TABLE Filters DROP CONSTRAINT fk_108
/
alter  table MTZ.Filters add constraint fk_108 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE RPTStruct DROP CONSTRAINT fk_109
/
alter  table MTZ.RPTStruct add constraint fk_109 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE RPTFields DROP CONSTRAINT fk_110
/
alter  table MTZ.RPTFields add constraint fk_110 foreign key(ParentStructRowID) references MTZ.RPTStruct (RPTStructID)
/

alter  TABLE RPTFormula DROP CONSTRAINT fk_111
/
alter  table MTZ.RPTFormula add constraint fk_111 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/

alter  TABLE Reports DROP CONSTRAINT fk_112
/
alter  table MTZ.Reports add constraint fk_112 foreign key(INSTANCEID) references MTZ.INSTANCE (INSTANCEID)
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--index" BlockCode=" 

drop index parent_GENPACKAGE
/
create index MTZ.parent_GENPACKAGE on MTZ.GENPACKAGE(&quot;INSTANCEID&quot;)
/

drop index parent_GENERATOR_TARGET
/
create index MTZ.parent_GENERATOR_TARGET on MTZ.GENERATOR_TARGET(ParentStructRowID)
/

drop index parent_GENREFERENCE
/
create index MTZ.parent_GENREFERENCE on MTZ.GENREFERENCE(ParentStructRowID)
/

drop index parent_GENMANUALCODE
/
create index MTZ.parent_GENMANUALCODE on MTZ.GENMANUALCODE(ParentStructRowID)
/

drop index parent_GENCONTROLS
/
create index MTZ.parent_GENCONTROLS on MTZ.GENCONTROLS(ParentStructRowID)
/

drop index parent_LocalizeInfo
/
create index MTZ.parent_LocalizeInfo on MTZ.LocalizeInfo(&quot;INSTANCEID&quot;)
/

drop index parent_FIELDTYPE
/
create index MTZ.parent_FIELDTYPE on MTZ.FIELDTYPE(&quot;INSTANCEID&quot;)
/

drop index parent_ENUMITEM
/
create index MTZ.parent_ENUMITEM on MTZ.ENUMITEM(ParentStructRowID)
/

drop index parent_FIELDTYPEMAP
/
create index MTZ.parent_FIELDTYPEMAP on MTZ.FIELDTYPEMAP(ParentStructRowID)
/

drop index parent_SHAREDMETHOD
/
create index MTZ.parent_SHAREDMETHOD on MTZ.SHAREDMETHOD(&quot;INSTANCEID&quot;)
/

drop index parent_SCRIPT
/
create index MTZ.parent_SCRIPT on MTZ.SCRIPT(ParentStructRowID)
/

drop index parent_PARAMETERS
/
create index MTZ.parent_PARAMETERS on MTZ.PARAMETERS(ParentStructRowID)
/

drop index parent_OBJECTTYPE
/
create index MTZ.parent_OBJECTTYPE on MTZ.OBJECTTYPE(&quot;INSTANCEID&quot;)
/

drop index parent_OBJSTATUS
/
create index MTZ.parent_OBJSTATUS on MTZ.OBJSTATUS(ParentStructRowID)
/

drop index parent_NEXTSTATE
/
create index MTZ.parent_NEXTSTATE on MTZ.NEXTSTATE(ParentStructRowID)
/

drop index parent_OBJECTMODE
/
create index MTZ.parent_OBJECTMODE on MTZ.OBJECTMODE(ParentStructRowID)
/

drop index parent_STRUCTRESTRICTION
/
create index MTZ.parent_STRUCTRESTRICTION on MTZ.STRUCTRESTRICTION(ParentStructRowID)
/

drop index parent_METHODRESTRICTION
/
create index MTZ.parent_METHODRESTRICTION on MTZ.METHODRESTRICTION(ParentStructRowID)
/

drop index parent_FIELDRESTRICTION
/
create index MTZ.parent_FIELDRESTRICTION on MTZ.FIELDRESTRICTION(ParentStructRowID)
/

drop index parent_TYPEMENU
/
create index MTZ.parent_TYPEMENU on MTZ.TYPEMENU(ParentStructRowID)
/

drop index parent_INSTANCEVALIDATOR
/
create index MTZ.parent_INSTANCEVALIDATOR on MTZ.INSTANCEVALIDATOR(ParentStructRowID)
/

drop index parent_PART
/
create index MTZ.parent_PART on MTZ.PART(ParentStructRowID)
/

drop index parent_PARTMENU
/
create index MTZ.parent_PARTMENU on MTZ.PARTMENU(ParentStructRowID)
/

drop index parent_PARTPARAMMAP
/
create index MTZ.parent_PARTPARAMMAP on MTZ.PARTPARAMMAP(ParentStructRowID)
/

drop index parent_PARTVIEW
/
create index MTZ.parent_PARTVIEW on MTZ.PARTVIEW(ParentStructRowID)
/

drop index parent_ViewColumn
/
create index MTZ.parent_ViewColumn on MTZ.ViewColumn(ParentStructRowID)
/

drop index parent_PARTVIEW_LNK
/
create index MTZ.parent_PARTVIEW_LNK on MTZ.PARTVIEW_LNK(ParentStructRowID)
/

drop index parent_VALIDATOR
/
create index MTZ.parent_VALIDATOR on MTZ.VALIDATOR(ParentStructRowID)
/

drop index parent_UNIQUECONSTRAINT
/
create index MTZ.parent_UNIQUECONSTRAINT on MTZ.UNIQUECONSTRAINT(ParentStructRowID)
/

drop index parent_CONSTRAINTFIELD
/
create index MTZ.parent_CONSTRAINTFIELD on MTZ.CONSTRAINTFIELD(ParentStructRowID)
/

drop index parent_ExtenderInterface
/
create index MTZ.parent_ExtenderInterface on MTZ.ExtenderInterface(ParentStructRowID)
/

drop index parent_FIELD
/
create index MTZ.parent_FIELD on MTZ.FIELD(ParentStructRowID)
/

drop index parent_FldExtenders
/
create index MTZ.parent_FldExtenders on MTZ.FldExtenders(ParentStructRowID)
/

drop index parent_FIELDSRCDEF
/
create index MTZ.parent_FIELDSRCDEF on MTZ.FIELDSRCDEF(ParentStructRowID)
/

drop index parent_DINAMICFILTERSCRIPT
/
create index MTZ.parent_DINAMICFILTERSCRIPT on MTZ.DINAMICFILTERSCRIPT(ParentStructRowID)
/

drop index parent_FIELDEXPRESSION
/
create index MTZ.parent_FIELDEXPRESSION on MTZ.FIELDEXPRESSION(ParentStructRowID)
/

drop index parent_FIELDVALIDATOR
/
create index MTZ.parent_FIELDVALIDATOR on MTZ.FIELDVALIDATOR(ParentStructRowID)
/

drop index parent_FIELDMENU
/
create index MTZ.parent_FIELDMENU on MTZ.FIELDMENU(ParentStructRowID)
/

drop index parent_FIELDPARAMMAP
/
create index MTZ.parent_FIELDPARAMMAP on MTZ.FIELDPARAMMAP(ParentStructRowID)
/

drop index parent_MTZAPP
/
create index MTZ.parent_MTZAPP on MTZ.MTZAPP(&quot;INSTANCEID&quot;)
/

drop index parent_ParentPackage
/
create index MTZ.parent_ParentPackage on MTZ.ParentPackage(ParentStructRowID)
/

drop index parent_JournalColumn
/
create index MTZ.parent_JournalColumn on MTZ.JournalColumn(&quot;INSTANCEID&quot;)
/

drop index parent_JColumnSource
/
create index MTZ.parent_JColumnSource on MTZ.JColumnSource(ParentStructRowID)
/

drop index parent_JournalSrc
/
create index MTZ.parent_JournalSrc on MTZ.JournalSrc(&quot;INSTANCEID&quot;)
/

drop index parent_Journal
/
create index MTZ.parent_Journal on MTZ.Journal(&quot;INSTANCEID&quot;)
/

drop index parent_tod_bug
/
create index MTZ.parent_tod_bug on MTZ.tod_bug(&quot;INSTANCEID&quot;)
/

drop index parent_tod_st
/
create index MTZ.parent_tod_st on MTZ.tod_st(&quot;INSTANCEID&quot;)
/

drop index parent_Folder
/
create index MTZ.parent_Folder on MTZ.Folder(&quot;INSTANCEID&quot;)
/

drop index parent_Shortcut
/
create index MTZ.parent_Shortcut on MTZ.Shortcut(ParentStructRowID)
/

drop index parent_InfoStoreDef
/
create index MTZ.parent_InfoStoreDef on MTZ.InfoStoreDef(&quot;INSTANCEID&quot;)
/

drop index parent_the_Session
/
create index MTZ.parent_the_Session on MTZ.the_Session(&quot;INSTANCEID&quot;)
/

drop index parent_SysRefCache
/
create index MTZ.parent_SysRefCache on MTZ.SysRefCache(&quot;INSTANCEID&quot;)
/

drop index parent_SysLog
/
create index MTZ.parent_SysLog on MTZ.SysLog(&quot;INSTANCEID&quot;)
/

drop index parent_ARMJournal
/
create index MTZ.parent_ARMJournal on MTZ.ARMJournal(&quot;INSTANCEID&quot;)
/

drop index parent_ARMJRNLREP
/
create index MTZ.parent_ARMJRNLREP on MTZ.ARMJRNLREP(ParentStructRowID)
/

drop index parent_ARMJRNLRUN
/
create index MTZ.parent_ARMJRNLRUN on MTZ.ARMJRNLRUN(ParentStructRowID)
/

drop index parent_ARMJRNLADD
/
create index MTZ.parent_ARMJRNLADD on MTZ.ARMJRNLADD(ParentStructRowID)
/

drop index parent_EntryPoints
/
create index MTZ.parent_EntryPoints on MTZ.EntryPoints(&quot;INSTANCEID&quot;)
/

drop index parent_EPFilterLink
/
create index MTZ.parent_EPFilterLink on MTZ.EPFilterLink(ParentStructRowID)
/

drop index parent_WorkPlace
/
create index MTZ.parent_WorkPlace on MTZ.WorkPlace(&quot;INSTANCEID&quot;)
/

drop index parent_ARMTypes
/
create index MTZ.parent_ARMTypes on MTZ.ARMTypes(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_OPERATIONS
/
create index MTZ.parent_ROLES_OPERATIONS on MTZ.ROLES_OPERATIONS(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_WP
/
create index MTZ.parent_ROLES_WP on MTZ.ROLES_WP(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_ACT
/
create index MTZ.parent_ROLES_ACT on MTZ.ROLES_ACT(ParentStructRowID)
/

drop index parent_ROLES2_MODULE
/
create index MTZ.parent_ROLES2_MODULE on MTZ.ROLES2_MODULE(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES2_MODREPORT
/
create index MTZ.parent_ROLES2_MODREPORT on MTZ.ROLES2_MODREPORT(ParentStructRowID)
/

drop index parent_ROLES_DOC
/
create index MTZ.parent_ROLES_DOC on MTZ.ROLES_DOC(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_DOC_STATE
/
create index MTZ.parent_ROLES_DOC_STATE on MTZ.ROLES_DOC_STATE(ParentStructRowID)
/

drop index parent_ROLES_REPORTS
/
create index MTZ.parent_ROLES_REPORTS on MTZ.ROLES_REPORTS(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_USER
/
create index MTZ.parent_ROLES_USER on MTZ.ROLES_USER(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_MAP
/
create index MTZ.parent_ROLES_MAP on MTZ.ROLES_MAP(&quot;INSTANCEID&quot;)
/

drop index parent_ROLES_DEF
/
create index MTZ.parent_ROLES_DEF on MTZ.ROLES_DEF(&quot;INSTANCEID&quot;)
/

drop index parent_Users
/
create index MTZ.parent_Users on MTZ.Users(&quot;INSTANCEID&quot;)
/

drop index parent_Groups
/
create index MTZ.parent_Groups on MTZ.Groups(&quot;INSTANCEID&quot;)
/

drop index parent_GroupUser
/
create index MTZ.parent_GroupUser on MTZ.GroupUser(ParentStructRowID)
/

drop index parent_Num_zones
/
create index MTZ.parent_Num_zones on MTZ.Num_zones(&quot;INSTANCEID&quot;)
/

drop index parent_Num_Values
/
create index MTZ.parent_Num_Values on MTZ.Num_Values(ParentStructRowID)
/

drop index parent_Num_head
/
create index MTZ.parent_Num_head on MTZ.Num_head(&quot;INSTANCEID&quot;)
/

drop index parent_MTZExt_def
/
create index MTZ.parent_MTZExt_def on MTZ.MTZExt_def(&quot;INSTANCEID&quot;)
/

drop index parent_MTZExtRel
/
create index MTZ.parent_MTZExtRel on MTZ.MTZExtRel(&quot;INSTANCEID&quot;)
/

drop index parent_MTZ2JOB_DEF
/
create index MTZ.parent_MTZ2JOB_DEF on MTZ.MTZ2JOB_DEF(&quot;INSTANCEID&quot;)
/

drop index parent_FilterFieldGroup
/
create index MTZ.parent_FilterFieldGroup on MTZ.FilterFieldGroup(&quot;INSTANCEID&quot;)
/

drop index parent_FileterField
/
create index MTZ.parent_FileterField on MTZ.FileterField(ParentStructRowID)
/

drop index parent_Filters
/
create index MTZ.parent_Filters on MTZ.Filters(&quot;INSTANCEID&quot;)
/

drop index parent_RPTStruct
/
create index MTZ.parent_RPTStruct on MTZ.RPTStruct(&quot;INSTANCEID&quot;)
/

drop index parent_RPTFields
/
create index MTZ.parent_RPTFields on MTZ.RPTFields(ParentStructRowID)
/

drop index parent_RPTFormula
/
create index MTZ.parent_RPTFormula on MTZ.RPTFormula(&quot;INSTANCEID&quot;)
/

drop index parent_Reports
/
create index MTZ.parent_Reports on MTZ.Reports(&quot;INSTANCEID&quot;)
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package Func as

  function instance_BRIEF_F  (
 ainstanceid CHAR
)return varchar2;
 function GENPACKAGE_BRIEF_F  (
 aGENPACKAGEid CHAR
) return varchar2;

 function GENERATOR_TARGET_BRIEF_F  (
 aGENERATOR_TARGETid CHAR
) return varchar2;

 function GENREFERENCE_BRIEF_F  (
 aGENREFERENCEid CHAR
) return varchar2;

 function GENMANUALCODE_BRIEF_F  (
 aGENMANUALCODEid CHAR
) return varchar2;

 function GENCONTROLS_BRIEF_F  (
 aGENCONTROLSid CHAR
) return varchar2;

 function LocalizeInfo_BRIEF_F  (
 aLocalizeInfoid CHAR
) return varchar2;

 function FIELDTYPE_BRIEF_F  (
 aFIELDTYPEid CHAR
) return varchar2;

 function ENUMITEM_BRIEF_F  (
 aENUMITEMid CHAR
) return varchar2;

 function FIELDTYPEMAP_BRIEF_F  (
 aFIELDTYPEMAPid CHAR
) return varchar2;

 function SHAREDMETHOD_BRIEF_F  (
 aSHAREDMETHODid CHAR
) return varchar2;

 function SCRIPT_BRIEF_F  (
 aSCRIPTid CHAR
) return varchar2;

 function PARAMETERS_BRIEF_F  (
 aPARAMETERSid CHAR
) return varchar2;

 function OBJECTTYPE_BRIEF_F  (
 aOBJECTTYPEid CHAR
) return varchar2;

 function OBJSTATUS_BRIEF_F  (
 aOBJSTATUSid CHAR
) return varchar2;

 function NEXTSTATE_BRIEF_F  (
 aNEXTSTATEid CHAR
) return varchar2;

 function OBJECTMODE_BRIEF_F  (
 aOBJECTMODEid CHAR
) return varchar2;

 function STRUCTRESTRICTION_BRIEF_F  (
 aSTRUCTRESTRICTIONid CHAR
) return varchar2;

 function METHODRESTRICTION_BRIEF_F  (
 aMETHODRESTRICTIONid CHAR
) return varchar2;

 function FIELDRESTRICTION_BRIEF_F  (
 aFIELDRESTRICTIONid CHAR
) return varchar2;

 function TYPEMENU_BRIEF_F  (
 aTYPEMENUid CHAR
) return varchar2;

 function INSTANCEVALIDATOR_BRIEF_F  (
 aINSTANCEVALIDATORid CHAR
) return varchar2;

 function PART_BRIEF_F  (
 aPARTid CHAR
) return varchar2;

 function PARTMENU_BRIEF_F  (
 aPARTMENUid CHAR
) return varchar2;

 function PARTPARAMMAP_BRIEF_F  (
 aPARTPARAMMAPid CHAR
) return varchar2;

 function PARTVIEW_BRIEF_F  (
 aPARTVIEWid CHAR
) return varchar2;

 function ViewColumn_BRIEF_F  (
 aViewColumnid CHAR
) return varchar2;

 function PARTVIEW_LNK_BRIEF_F  (
 aPARTVIEW_LNKid CHAR
) return varchar2;

 function VALIDATOR_BRIEF_F  (
 aVALIDATORid CHAR
) return varchar2;

 function UNIQUECONSTRAINT_BRIEF_F  (
 aUNIQUECONSTRAINTid CHAR
) return varchar2;

 function CONSTRAINTFIELD_BRIEF_F  (
 aCONSTRAINTFIELDid CHAR
) return varchar2;

 function ExtenderInterface_BRIEF_F  (
 aExtenderInterfaceid CHAR
) return varchar2;

 function FIELD_BRIEF_F  (
 aFIELDid CHAR
) return varchar2;

 function FldExtenders_BRIEF_F  (
 aFldExtendersid CHAR
) return varchar2;

 function FIELDSRCDEF_BRIEF_F  (
 aFIELDSRCDEFid CHAR
) return varchar2;

 function DINAMICFILTERSCRIPT_BRIEF_F  (
 aDINAMICFILTERSCRIPTid CHAR
) return varchar2;

 function FIELDEXPRESSION_BRIEF_F  (
 aFIELDEXPRESSIONid CHAR
) return varchar2;

 function FIELDVALIDATOR_BRIEF_F  (
 aFIELDVALIDATORid CHAR
) return varchar2;

 function FIELDMENU_BRIEF_F  (
 aFIELDMENUid CHAR
) return varchar2;

 function FIELDPARAMMAP_BRIEF_F  (
 aFIELDPARAMMAPid CHAR
) return varchar2;

 function MTZAPP_BRIEF_F  (
 aMTZAPPid CHAR
) return varchar2;

 function ParentPackage_BRIEF_F  (
 aParentPackageid CHAR
) return varchar2;

 function JournalColumn_BRIEF_F  (
 aJournalColumnid CHAR
) return varchar2;

 function JColumnSource_BRIEF_F  (
 aJColumnSourceid CHAR
) return varchar2;

 function JournalSrc_BRIEF_F  (
 aJournalSrcid CHAR
) return varchar2;

 function Journal_BRIEF_F  (
 aJournalid CHAR
) return varchar2;

 function tod_bug_BRIEF_F  (
 atod_bugid CHAR
) return varchar2;

 function tod_st_BRIEF_F  (
 atod_stid CHAR
) return varchar2;

 function Folder_BRIEF_F  (
 aFolderid CHAR
) return varchar2;

 function Shortcut_BRIEF_F  (
 aShortcutid CHAR
) return varchar2;

 function InfoStoreDef_BRIEF_F  (
 aInfoStoreDefid CHAR
) return varchar2;

 function the_Session_BRIEF_F  (
 athe_Sessionid CHAR
) return varchar2;

 function SysRefCache_BRIEF_F  (
 aSysRefCacheid CHAR
) return varchar2;

 function SysLog_BRIEF_F  (
 aSysLogid CHAR
) return varchar2;

 function ARMJournal_BRIEF_F  (
 aARMJournalid CHAR
) return varchar2;

 function ARMJRNLREP_BRIEF_F  (
 aARMJRNLREPid CHAR
) return varchar2;

 function ARMJRNLRUN_BRIEF_F  (
 aARMJRNLRUNid CHAR
) return varchar2;

 function ARMJRNLADD_BRIEF_F  (
 aARMJRNLADDid CHAR
) return varchar2;

 function EntryPoints_BRIEF_F  (
 aEntryPointsid CHAR
) return varchar2;

 function EPFilterLink_BRIEF_F  (
 aEPFilterLinkid CHAR
) return varchar2;

 function WorkPlace_BRIEF_F  (
 aWorkPlaceid CHAR
) return varchar2;

 function ARMTypes_BRIEF_F  (
 aARMTypesid CHAR
) return varchar2;

 function ROLES_OPERATIONS_BRIEF_F  (
 aROLES_OPERATIONSid CHAR
) return varchar2;

 function ROLES_WP_BRIEF_F  (
 aROLES_WPid CHAR
) return varchar2;

 function ROLES_ACT_BRIEF_F  (
 aROLES_ACTid CHAR
) return varchar2;

 function ROLES2_MODULE_BRIEF_F  (
 aROLES2_MODULEid CHAR
) return varchar2;

 function ROLES2_MODREPORT_BRIEF_F  (
 aROLES2_MODREPORTid CHAR
) return varchar2;

 function ROLES_DOC_BRIEF_F  (
 aROLES_DOCid CHAR
) return varchar2;

 function ROLES_DOC_STATE_BRIEF_F  (
 aROLES_DOC_STATEid CHAR
) return varchar2;

 function ROLES_REPORTS_BRIEF_F  (
 aROLES_REPORTSid CHAR
) return varchar2;

 function ROLES_USER_BRIEF_F  (
 aROLES_USERid CHAR
) return varchar2;

 function ROLES_MAP_BRIEF_F  (
 aROLES_MAPid CHAR
) return varchar2;

 function ROLES_DEF_BRIEF_F  (
 aROLES_DEFid CHAR
) return varchar2;

 function Users_BRIEF_F  (
 aUsersid CHAR
) return varchar2;

 function Groups_BRIEF_F  (
 aGroupsid CHAR
) return varchar2;

 function GroupUser_BRIEF_F  (
 aGroupUserid CHAR
) return varchar2;

 function Num_zones_BRIEF_F  (
 aNum_zonesid CHAR
) return varchar2;

 function Num_Values_BRIEF_F  (
 aNum_Valuesid CHAR
) return varchar2;

 function Num_head_BRIEF_F  (
 aNum_headid CHAR
) return varchar2;

 function MTZExt_def_BRIEF_F  (
 aMTZExt_defid CHAR
) return varchar2;

 function MTZExtRel_BRIEF_F  (
 aMTZExtRelid CHAR
) return varchar2;

 function MTZ2JOB_DEF_BRIEF_F  (
 aMTZ2JOB_DEFid CHAR
) return varchar2;

 function FilterFieldGroup_BRIEF_F  (
 aFilterFieldGroupid CHAR
) return varchar2;

 function FileterField_BRIEF_F  (
 aFileterFieldid CHAR
) return varchar2;

 function Filters_BRIEF_F  (
 aFiltersid CHAR
) return varchar2;

 function RPTStruct_BRIEF_F  (
 aRPTStructid CHAR
) return varchar2;

 function RPTFields_BRIEF_F  (
 aRPTFieldsid CHAR
) return varchar2;

 function RPTFormula_BRIEF_F  (
 aRPTFormulaid CHAR
) return varchar2;

 function Reports_BRIEF_F  (
 aReportsid CHAR
) return varchar2;
 end Func;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Views" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

create or replace view v_INSTANCE as
select instance.*,objstatus.name statusname,objstatus.IsArchive
from instance left join objstatus on instance.status=objstatus.objstatusid
/
create or replace view V_AUTOGENPACKAGE as 
select   GENPACKAGEID
, 
GENPACKAGE.Name 
GENPACKAGE_Name 
, GENPACKAGE.InstanceID InstanceID 
, GENPACKAGE.GENPACKAGEID ID 
, 'GENPACKAGE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GENPACKAGE
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGENERATOR_TARGET as 
select   GENERATOR_TARGETID,GENPACKAGEID
, 
 GENERATOR_TARGET.GeneratorStyle  
GENERATOR_TARGET_GeneratorStyle_VAL, 
 decode(GENERATOR_TARGET.GeneratorStyle 
, 0 ,'Один тип'
, 1 ,'Все типы сразу'
, '???') 
GENERATOR_TARGET_GeneratorStyle 
, 
 GENERATOR_TARGET.TargetType  
GENERATOR_TARGET_TargetType_VAL, 
 decode(GENERATOR_TARGET.TargetType 
, 0 ,'СУБД'
, 3 ,'Документация'
, 1 ,'МОДЕЛЬ'
, 2 ,'Приложение'
, 4 ,'АРМ'
, '???') 
GENERATOR_TARGET_TargetType 
, 
GENERATOR_TARGET.Name 
GENERATOR_TARGET_Name 
, 
GENERATOR_TARGET.QueueName 
GENERATOR_TARGET_QueueName 
, 
GENERATOR_TARGET.GeneratorProgID 
GENERATOR_TARGET_GeneratorProgID 
, 
 GENERATOR_TARGET.TheDevelopmentEnv  
GENERATOR_TARGET_TheDevelopmentEnv_VAL, 
 decode(GENERATOR_TARGET.TheDevelopmentEnv 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
GENERATOR_TARGET_TheDevelopmentEnv 
, GENPACKAGE.InstanceID InstanceID 
, GENERATOR_TARGET.GENERATOR_TARGETID ID 
, 'GENERATOR_TARGET' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GENERATOR_TARGET
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGENREFERENCE as 
select   GENREFERENCEID,GENERATOR_TARGETID,GENPACKAGEID
, 
GENREFERENCE.VersionMajor 
GENREFERENCE_VersionMajor 
, 
GENREFERENCE.VersionMinor 
GENREFERENCE_VersionMinor 
, 
GENREFERENCE.RefClassID 
GENREFERENCE_RefClassID 
, 
GENREFERENCE.Name 
GENREFERENCE_Name 
, GENPACKAGE.InstanceID InstanceID 
, GENREFERENCE.GENREFERENCEID ID 
, 'GENREFERENCE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GENREFERENCE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENREFERENCE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGENMANUALCODE as 
select   GENMANUALCODEID,GENERATOR_TARGETID,GENPACKAGEID
, 
GENMANUALCODE.Name 
GENMANUALCODE_Name 
, 
GENMANUALCODE.Code 
GENMANUALCODE_Code 
, 
GENMANUALCODE.the_Alias 
GENMANUALCODE_the_Alias 
, GENPACKAGE.InstanceID InstanceID 
, GENMANUALCODE.GENMANUALCODEID ID 
, 'GENMANUALCODE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GENMANUALCODE
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENMANUALCODE.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGENCONTROLS as 
select   GENCONTROLSID,GENERATOR_TARGETID,GENPACKAGEID
, 
GENCONTROLS.VersionMajor 
GENCONTROLS_VersionMajor 
, 
GENCONTROLS.VersionMinor 
GENCONTROLS_VersionMinor 
, 
GENCONTROLS.ControlClassID 
GENCONTROLS_ControlClassID 
, 
GENCONTROLS.ControlProgID 
GENCONTROLS_ControlProgID 
, GENPACKAGE.InstanceID InstanceID 
, GENCONTROLS.GENCONTROLSID ID 
, 'GENCONTROLS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GENCONTROLS
 join GENERATOR_TARGET on GENERATOR_TARGET.GENERATOR_TARGETID=GENCONTROLS.ParentStructRowID 
 join GENPACKAGE on GENPACKAGE.GENPACKAGEID=GENERATOR_TARGET.ParentStructRowID 
 join INSTANCE on GENPACKAGE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOLocalizeInfo as 
select   LocalizeInfoID
, 
LocalizeInfo.LangFull 
LocalizeInfo_LangFull 
, 
LocalizeInfo.LangShort 
LocalizeInfo_LangShort 
, LocalizeInfo.InstanceID InstanceID 
, LocalizeInfo.LocalizeInfoID ID 
, 'LocalizeInfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from LocalizeInfo
 join INSTANCE on LocalizeInfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDTYPE as 
select   FIELDTYPEID
, 
 FIELDTYPE.DelayedSave  
FIELDTYPE_DelayedSave_VAL, 
 decode(FIELDTYPE.DelayedSave 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDTYPE_DelayedSave 
, 
FIELDTYPE.Minimum 
FIELDTYPE_Minimum 
, 
 FIELDTYPE.AllowSize  
FIELDTYPE_AllowSize_VAL, 
 decode(FIELDTYPE.AllowSize 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDTYPE_AllowSize 
, 
 FIELDTYPE.AllowLikeSearch  
FIELDTYPE_AllowLikeSearch_VAL, 
 decode(FIELDTYPE.AllowLikeSearch 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDTYPE_AllowLikeSearch 
, 
FIELDTYPE.Maximum 
FIELDTYPE_Maximum 
, 
FIELDTYPE.the_Comment 
FIELDTYPE_the_Comment 
, 
FIELDTYPE.Name 
FIELDTYPE_Name 
, 
 FIELDTYPE.GridSortType  
FIELDTYPE_GridSortType_VAL, 
 decode(FIELDTYPE.GridSortType 
, 0 ,'As String'
, 1 ,'As Numeric'
, 2 ,'As Date'
, '???') 
FIELDTYPE_GridSortType 
, 
 FIELDTYPE.TypeStyle  
FIELDTYPE_TypeStyle_VAL, 
 decode(FIELDTYPE.TypeStyle 
, 4 ,'Ссылка'
, 1 ,'Выражение'
, 5 ,'Элемент оформления'
, 3 ,'Интервал'
, 2 ,'Перечисление'
, 0 ,'Скалярный тип'
, '???') 
FIELDTYPE_TypeStyle 
, FIELDTYPE.InstanceID InstanceID 
, FIELDTYPE.FIELDTYPEID ID 
, 'FIELDTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDTYPE
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOENUMITEM as 
select   ENUMITEMID,FIELDTYPEID
, 
ENUMITEM.Name 
ENUMITEM_Name 
, 
ENUMITEM.NameInCode 
ENUMITEM_NameInCode 
, 
ENUMITEM.NameValue 
ENUMITEM_NameValue 
, FIELDTYPE.InstanceID InstanceID 
, ENUMITEM.ENUMITEMID ID 
, 'ENUMITEM' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ENUMITEM
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=ENUMITEM.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDTYPEMAP as 
select   FIELDTYPEMAPID,FIELDTYPEID
, 
 FIELDTYPEMAP.Target  
FIELDTYPEMAP_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(FIELDTYPEMAP.Target) 
FIELDTYPEMAP_Target 
, 
FIELDTYPEMAP.FixedSize 
FIELDTYPEMAP_FixedSize 
, 
FIELDTYPEMAP.StoageType 
FIELDTYPEMAP_StoageType 
, FIELDTYPE.InstanceID InstanceID 
, FIELDTYPEMAP.FIELDTYPEMAPID ID 
, 'FIELDTYPEMAP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDTYPEMAP
 join FIELDTYPE on FIELDTYPE.FIELDTYPEID=FIELDTYPEMAP.ParentStructRowID 
 join INSTANCE on FIELDTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOSHAREDMETHOD as 
select   SHAREDMETHODID
, 
 SHAREDMETHOD.ReturnType  
SHAREDMETHOD_ReturnType_ID, 
 MTZ.Func.FIELDTYPE_BRIEF_F(SHAREDMETHOD.ReturnType) 
SHAREDMETHOD_ReturnType 
, 
SHAREDMETHOD.Name 
SHAREDMETHOD_Name 
, 
SHAREDMETHOD.the_Comment 
SHAREDMETHOD_the_Comment 
, SHAREDMETHOD.InstanceID InstanceID 
, SHAREDMETHOD.SHAREDMETHODID ID 
, 'SHAREDMETHOD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from SHAREDMETHOD
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOSCRIPT as 
select   SCRIPTID,SHAREDMETHODID
, 
 SCRIPT.Target  
SCRIPT_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(SCRIPT.Target) 
SCRIPT_Target 
, 
SCRIPT.Code 
SCRIPT_Code 
, SHAREDMETHOD.InstanceID InstanceID 
, SCRIPT.SCRIPTID ID 
, 'SCRIPT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from SCRIPT
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPARAMETERS as 
select   PARAMETERSID,SCRIPTID,SHAREDMETHODID
, 
 PARAMETERS.RefToType  
PARAMETERS_RefToType_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(PARAMETERS.RefToType) 
PARAMETERS_RefToType 
, 
PARAMETERS.sequence 
PARAMETERS_sequence 
, 
PARAMETERS.DataSize 
PARAMETERS_DataSize 
, 
 PARAMETERS.RefToPart  
PARAMETERS_RefToPart_ID, 
 MTZ.Func.PART_BRIEF_F(PARAMETERS.RefToPart) 
PARAMETERS_RefToPart 
, 
 PARAMETERS.ReferenceType  
PARAMETERS_ReferenceType_VAL, 
 decode(PARAMETERS.ReferenceType 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
PARAMETERS_ReferenceType 
, 
PARAMETERS.Caption 
PARAMETERS_Caption 
, 
 PARAMETERS.OutParam  
PARAMETERS_OutParam_VAL, 
 decode(PARAMETERS.OutParam 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARAMETERS_OutParam 
, 
 PARAMETERS.TypeOfParm  
PARAMETERS_TypeOfParm_ID, 
 MTZ.Func.FIELDTYPE_BRIEF_F(PARAMETERS.TypeOfParm) 
PARAMETERS_TypeOfParm 
, 
PARAMETERS.Name 
PARAMETERS_Name 
, 
 PARAMETERS.AllowNull  
PARAMETERS_AllowNull_VAL, 
 decode(PARAMETERS.AllowNull 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARAMETERS_AllowNull 
, SHAREDMETHOD.InstanceID InstanceID 
, PARAMETERS.PARAMETERSID ID 
, 'PARAMETERS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PARAMETERS
 join SCRIPT on SCRIPT.SCRIPTID=PARAMETERS.ParentStructRowID 
 join SHAREDMETHOD on SHAREDMETHOD.SHAREDMETHODID=SCRIPT.ParentStructRowID 
 join INSTANCE on SHAREDMETHOD.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOOBJECTTYPE as 
select   OBJECTTYPEID
, 
OBJECTTYPE.objIconCls 
OBJECTTYPE_objIconCls 
, 
 OBJECTTYPE.Package  
OBJECTTYPE_Package_ID, 
 MTZ.Func.MTZAPP_BRIEF_F(OBJECTTYPE.Package) 
OBJECTTYPE_Package 
, 
 OBJECTTYPE.ReplicaType  
OBJECTTYPE_ReplicaType_VAL, 
 decode(OBJECTTYPE.ReplicaType 
, 1 ,'Построчно'
, 0 ,'Весь документ'
, 2 ,'Локальный'
, '???') 
OBJECTTYPE_ReplicaType 
, 
OBJECTTYPE.the_Comment 
OBJECTTYPE_the_Comment 
, 
 OBJECTTYPE.OnRun  
OBJECTTYPE_OnRun_ID, 
 MTZ.Func.TYPEMENU_BRIEF_F(OBJECTTYPE.OnRun) 
OBJECTTYPE_OnRun 
, 
 OBJECTTYPE.ChooseView  
OBJECTTYPE_ChooseView_ID, 
 MTZ.Func.PARTVIEW_BRIEF_F(OBJECTTYPE.ChooseView) 
OBJECTTYPE_ChooseView 
, 
 OBJECTTYPE.CommitFullObject  
OBJECTTYPE_CommitFullObject_VAL, 
 decode(OBJECTTYPE.CommitFullObject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_CommitFullObject 
, 
 OBJECTTYPE.UseArchiving  
OBJECTTYPE_UseArchiving_VAL, 
 decode(OBJECTTYPE.UseArchiving 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_UseArchiving 
, 
 OBJECTTYPE.UseOwnership  
OBJECTTYPE_UseOwnership_VAL, 
 decode(OBJECTTYPE.UseOwnership 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_UseOwnership 
, 
 OBJECTTYPE.OnCreate  
OBJECTTYPE_OnCreate_ID, 
 MTZ.Func.TYPEMENU_BRIEF_F(OBJECTTYPE.OnCreate) 
OBJECTTYPE_OnCreate 
, 
 OBJECTTYPE.AllowRefToObject  
OBJECTTYPE_AllowRefToObject_VAL, 
 decode(OBJECTTYPE.AllowRefToObject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_AllowRefToObject 
, 
OBJECTTYPE.TheComment 
OBJECTTYPE_TheComment 
, 
OBJECTTYPE.Name 
OBJECTTYPE_Name 
, 
 OBJECTTYPE.AllowSearch  
OBJECTTYPE_AllowSearch_VAL, 
 decode(OBJECTTYPE.AllowSearch 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_AllowSearch 
, 
 OBJECTTYPE.OnDelete  
OBJECTTYPE_OnDelete_ID, 
 MTZ.Func.TYPEMENU_BRIEF_F(OBJECTTYPE.OnDelete) 
OBJECTTYPE_OnDelete 
, 
 OBJECTTYPE.IsSingleInstance  
OBJECTTYPE_IsSingleInstance_VAL, 
 decode(OBJECTTYPE.IsSingleInstance 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTTYPE_IsSingleInstance 
, OBJECTTYPE.InstanceID InstanceID 
, OBJECTTYPE.OBJECTTYPEID ID 
, 'OBJECTTYPE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from OBJECTTYPE
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOOBJSTATUS as 
select   OBJSTATUSID,OBJECTTYPEID
, 
OBJSTATUS.the_comment 
OBJSTATUS_the_comment 
, 
 OBJSTATUS.isStartup  
OBJSTATUS_isStartup_VAL, 
 decode(OBJSTATUS.isStartup 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJSTATUS_isStartup 
, 
OBJSTATUS.name 
OBJSTATUS_name 
, 
 OBJSTATUS.IsArchive  
OBJSTATUS_IsArchive_VAL, 
 decode(OBJSTATUS.IsArchive 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJSTATUS_IsArchive 
, OBJECTTYPE.InstanceID InstanceID 
, OBJSTATUS.OBJSTATUSID ID 
, 'OBJSTATUS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from OBJSTATUS
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTONEXTSTATE as 
select   NEXTSTATEID,OBJSTATUSID,OBJECTTYPEID
, 
 NEXTSTATE.TheState  
NEXTSTATE_TheState_ID, 
 MTZ.Func.OBJSTATUS_BRIEF_F(NEXTSTATE.TheState) 
NEXTSTATE_TheState 
, OBJECTTYPE.InstanceID InstanceID 
, NEXTSTATE.NEXTSTATEID ID 
, 'NEXTSTATE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from NEXTSTATE
 join OBJSTATUS on OBJSTATUS.OBJSTATUSID=NEXTSTATE.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJSTATUS.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOOBJECTMODE as 
select   OBJECTMODEID,OBJECTTYPEID
, 
OBJECTMODE.Name 
OBJECTMODE_Name 
, 
OBJECTMODE.TheComment 
OBJECTMODE_TheComment 
, 
 OBJECTMODE.DefaultMode  
OBJECTMODE_DefaultMode_VAL, 
 decode(OBJECTMODE.DefaultMode 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
OBJECTMODE_DefaultMode 
, OBJECTTYPE.InstanceID InstanceID 
, OBJECTMODE.OBJECTMODEID ID 
, 'OBJECTMODE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from OBJECTMODE
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOSTRUCTRESTRICTION as 
select   STRUCTRESTRICTIONID,OBJECTMODEID,OBJECTTYPEID
, 
 STRUCTRESTRICTION.AllowDelete  
STRUCTRESTRICTION_AllowDelete_VAL, 
 decode(STRUCTRESTRICTION.AllowDelete 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
STRUCTRESTRICTION_AllowDelete 
, 
 STRUCTRESTRICTION.AllowAdd  
STRUCTRESTRICTION_AllowAdd_VAL, 
 decode(STRUCTRESTRICTION.AllowAdd 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
STRUCTRESTRICTION_AllowAdd 
, 
 STRUCTRESTRICTION.Struct  
STRUCTRESTRICTION_Struct_ID, 
 MTZ.Func.PART_BRIEF_F(STRUCTRESTRICTION.Struct) 
STRUCTRESTRICTION_Struct 
, 
 STRUCTRESTRICTION.AllowEdit  
STRUCTRESTRICTION_AllowEdit_VAL, 
 decode(STRUCTRESTRICTION.AllowEdit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
STRUCTRESTRICTION_AllowEdit 
, 
 STRUCTRESTRICTION.AllowRead  
STRUCTRESTRICTION_AllowRead_VAL, 
 decode(STRUCTRESTRICTION.AllowRead 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
STRUCTRESTRICTION_AllowRead 
, OBJECTTYPE.InstanceID InstanceID 
, STRUCTRESTRICTION.STRUCTRESTRICTIONID ID 
, 'STRUCTRESTRICTION' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from STRUCTRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=STRUCTRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOMETHODRESTRICTION as 
select   METHODRESTRICTIONID,OBJECTMODEID,OBJECTTYPEID
, 
 METHODRESTRICTION.IsRestricted  
METHODRESTRICTION_IsRestricted_VAL, 
 decode(METHODRESTRICTION.IsRestricted 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
METHODRESTRICTION_IsRestricted 
, 
 METHODRESTRICTION.Method  
METHODRESTRICTION_Method_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(METHODRESTRICTION.Method) 
METHODRESTRICTION_Method 
, 
 METHODRESTRICTION.Part  
METHODRESTRICTION_Part_ID, 
 MTZ.Func.PART_BRIEF_F(METHODRESTRICTION.Part) 
METHODRESTRICTION_Part 
, OBJECTTYPE.InstanceID InstanceID 
, METHODRESTRICTION.METHODRESTRICTIONID ID 
, 'METHODRESTRICTION' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from METHODRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=METHODRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDRESTRICTION as 
select   FIELDRESTRICTIONID,OBJECTMODEID,OBJECTTYPEID
, 
 FIELDRESTRICTION.AllowRead  
FIELDRESTRICTION_AllowRead_VAL, 
 decode(FIELDRESTRICTION.AllowRead 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDRESTRICTION_AllowRead 
, 
 FIELDRESTRICTION.AllowModify  
FIELDRESTRICTION_AllowModify_VAL, 
 decode(FIELDRESTRICTION.AllowModify 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDRESTRICTION_AllowModify 
, 
 FIELDRESTRICTION.TheField  
FIELDRESTRICTION_TheField_ID, 
 MTZ.Func.FIELD_BRIEF_F(FIELDRESTRICTION.TheField) 
FIELDRESTRICTION_TheField 
, 
 FIELDRESTRICTION.MandatoryField  
FIELDRESTRICTION_MandatoryField_VAL, 
 decode(FIELDRESTRICTION.MandatoryField 
, -1 ,'Не существенно'
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDRESTRICTION_MandatoryField 
, 
 FIELDRESTRICTION.ThePart  
FIELDRESTRICTION_ThePart_ID, 
 MTZ.Func.PART_BRIEF_F(FIELDRESTRICTION.ThePart) 
FIELDRESTRICTION_ThePart 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDRESTRICTION.FIELDRESTRICTIONID ID 
, 'FIELDRESTRICTION' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDRESTRICTION
 join OBJECTMODE on OBJECTMODE.OBJECTMODEID=FIELDRESTRICTION.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=OBJECTMODE.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOTYPEMENU as 
select   TYPEMENUID,OBJECTTYPEID
, 
TYPEMENU.Name 
TYPEMENU_Name 
, 
TYPEMENU.ToolTip 
TYPEMENU_ToolTip 
, 
 TYPEMENU.the_Action  
TYPEMENU_the_Action_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(TYPEMENU.the_Action) 
TYPEMENU_the_Action 
, 
 TYPEMENU.IsMenuItem  
TYPEMENU_IsMenuItem_VAL, 
 decode(TYPEMENU.IsMenuItem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
TYPEMENU_IsMenuItem 
, 
TYPEMENU.HotKey 
TYPEMENU_HotKey 
, 
 TYPEMENU.IsToolBarButton  
TYPEMENU_IsToolBarButton_VAL, 
 decode(TYPEMENU.IsToolBarButton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
TYPEMENU_IsToolBarButton 
, 
TYPEMENU.Caption 
TYPEMENU_Caption 
, OBJECTTYPE.InstanceID InstanceID 
, TYPEMENU.TYPEMENUID ID 
, 'TYPEMENU' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from TYPEMENU
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=TYPEMENU.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOINSTANCEVALIDATOR as 
select   INSTANCEVALIDATORID,OBJECTTYPEID
, 
INSTANCEVALIDATOR.Code 
INSTANCEVALIDATOR_Code 
, 
 INSTANCEVALIDATOR.Target  
INSTANCEVALIDATOR_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(INSTANCEVALIDATOR.Target) 
INSTANCEVALIDATOR_Target 
, OBJECTTYPE.InstanceID InstanceID 
, INSTANCEVALIDATOR.INSTANCEVALIDATORID ID 
, 'INSTANCEVALIDATOR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from INSTANCEVALIDATOR
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=INSTANCEVALIDATOR.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPART as 
select   PARTID,OBJECTTYPEID
, 
 PART.ExtenderObject  
PART_ExtenderObject_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(PART.ExtenderObject) 
PART_ExtenderObject 
, 
PART.the_Comment 
PART_the_Comment 
, 
PART.ruleBrief 
PART_ruleBrief 
, 
PART.Name 
PART_Name 
, 
PART.partIconCls 
PART_partIconCls 
, 
 PART.OnDelete  
PART_OnDelete_ID, 
 MTZ.Func.PARTMENU_BRIEF_F(PART.OnDelete) 
PART_OnDelete 
, 
 PART.OnRun  
PART_OnRun_ID, 
 MTZ.Func.PARTMENU_BRIEF_F(PART.OnRun) 
PART_OnRun 
, 
 PART.OnSave  
PART_OnSave_ID, 
 MTZ.Func.PARTMENU_BRIEF_F(PART.OnSave) 
PART_OnSave 
, 
PART.shablonBrief 
PART_shablonBrief 
, 
 PART.IsJormalChange  
PART_IsJormalChange_VAL, 
 decode(PART.IsJormalChange 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PART_IsJormalChange 
, 
PART.Caption 
PART_Caption 
, 
PART.Sequence 
PART_Sequence 
, 
 PART.ManualRegister  
PART_ManualRegister_VAL, 
 decode(PART.ManualRegister 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PART_ManualRegister 
, 
 PART.NoLog  
PART_NoLog_VAL, 
 decode(PART.NoLog 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PART_NoLog 
, 
 PART.AddBehaivor  
PART_AddBehaivor_VAL, 
 decode(PART.AddBehaivor 
, 0 ,'AddForm'
, 2 ,'RunAction'
, 1 ,'RefreshOnly'
, '???') 
PART_AddBehaivor 
, 
 PART.integerpkey  
PART_integerpkey_VAL, 
 decode(PART.integerpkey 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PART_integerpkey 
, 
 PART.OnCreate  
PART_OnCreate_ID, 
 MTZ.Func.PARTMENU_BRIEF_F(PART.OnCreate) 
PART_OnCreate 
, 
 PART.PartType  
PART_PartType_VAL, 
 decode(PART.PartType 
, 1 ,'Коллекция'
, 2 ,'Дерево'
, 0 ,'Строка'
, 4 ,'Расширение с данными'
, 3 ,'Расширение'
, '???') 
PART_PartType 
, 
 PART.UseArchiving  
PART_UseArchiving_VAL, 
 decode(PART.UseArchiving 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PART_UseArchiving 
, OBJECTTYPE.InstanceID InstanceID 
, PART.PARTID ID 
, 'PART' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PART
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPARTMENU as 
select   PARTMENUID,PARTID,OBJECTTYPEID
, 
 PARTMENU.IsToolBarButton  
PARTMENU_IsToolBarButton_VAL, 
 decode(PARTMENU.IsToolBarButton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARTMENU_IsToolBarButton 
, 
 PARTMENU.the_Action  
PARTMENU_the_Action_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(PARTMENU.the_Action) 
PARTMENU_the_Action 
, 
PARTMENU.Name 
PARTMENU_Name 
, 
 PARTMENU.IsMenuItem  
PARTMENU_IsMenuItem_VAL, 
 decode(PARTMENU.IsMenuItem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARTMENU_IsMenuItem 
, 
PARTMENU.Caption 
PARTMENU_Caption 
, 
PARTMENU.HotKey 
PARTMENU_HotKey 
, 
PARTMENU.ToolTip 
PARTMENU_ToolTip 
, OBJECTTYPE.InstanceID InstanceID 
, PARTMENU.PARTMENUID ID 
, 'PARTMENU' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PARTMENU
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPARTPARAMMAP as 
select   PARTPARAMMAPID,PARTMENUID,PARTID,OBJECTTYPEID
, 
 PARTPARAMMAP.NoEdit  
PARTPARAMMAP_NoEdit_VAL, 
 decode(PARTPARAMMAP.NoEdit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARTPARAMMAP_NoEdit 
, 
PARTPARAMMAP.FieldName 
PARTPARAMMAP_FieldName 
, 
PARTPARAMMAP.ParamName 
PARTPARAMMAP_ParamName 
, OBJECTTYPE.InstanceID InstanceID 
, PARTPARAMMAP.PARTPARAMMAPID ID 
, 'PARTPARAMMAP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PARTPARAMMAP
 join PARTMENU on PARTMENU.PARTMENUID=PARTPARAMMAP.ParentStructRowID 
 join PART on PART.PARTID=PARTMENU.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPARTVIEW as 
select   PARTVIEWID,PARTID,OBJECTTYPEID
, 
PARTVIEW.the_Alias 
PARTVIEW_the_Alias 
, 
PARTVIEW.FilterField3 
PARTVIEW_FilterField3 
, 
PARTVIEW.FilterField2 
PARTVIEW_FilterField2 
, 
 PARTVIEW.ForChoose  
PARTVIEW_ForChoose_VAL, 
 decode(PARTVIEW.ForChoose 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
PARTVIEW_ForChoose 
, 
PARTVIEW.FilterField1 
PARTVIEW_FilterField1 
, 
PARTVIEW.Name 
PARTVIEW_Name 
, 
PARTVIEW.FilterField0 
PARTVIEW_FilterField0 
, OBJECTTYPE.InstanceID InstanceID 
, PARTVIEW.PARTVIEWID ID 
, 'PARTVIEW' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PARTVIEW
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOViewColumn as 
select   ViewColumnID,PARTVIEWID,PARTID,OBJECTTYPEID
, 
ViewColumn.Name 
ViewColumn_Name 
, 
 ViewColumn.ForCombo  
ViewColumn_ForCombo_VAL, 
 decode(ViewColumn.ForCombo 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ViewColumn_ForCombo 
, 
 ViewColumn.FromPart  
ViewColumn_FromPart_ID, 
 MTZ.Func.PART_BRIEF_F(ViewColumn.FromPart) 
ViewColumn_FromPart 
, 
ViewColumn.Expression 
ViewColumn_Expression 
, 
ViewColumn.the_Alias 
ViewColumn_the_Alias 
, 
 ViewColumn.Aggregation  
ViewColumn_Aggregation_VAL, 
 decode(ViewColumn.Aggregation 
, 3 ,'SUM'
, 1 ,'AVG'
, 6 ,'CUSTOM'
, 0 ,'none'
, 2 ,'COUNT'
, 5 ,'MAX'
, 4 ,'MIN'
, '???') 
ViewColumn_Aggregation 
, 
 ViewColumn.Field  
ViewColumn_Field_ID, 
 MTZ.Func.FIELD_BRIEF_F(ViewColumn.Field) 
ViewColumn_Field 
, 
ViewColumn.sequence 
ViewColumn_sequence 
, OBJECTTYPE.InstanceID InstanceID 
, ViewColumn.ViewColumnID ID 
, 'ViewColumn' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ViewColumn
 join PARTVIEW on PARTVIEW.PARTVIEWID=ViewColumn.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOPARTVIEW_LNK as 
select   PARTVIEW_LNKID,PARTVIEWID,PARTID,OBJECTTYPEID
, 
 PARTVIEW_LNK.RefType  
PARTVIEW_LNK_RefType_VAL, 
 decode(PARTVIEW_LNK.RefType 
, 0 ,'Нет'
, 4 ,'Связка ParentStructRowID  (в передлах объекта)'
, 3 ,'Связка InstanceID (в передлах объекта)'
, 1 ,'Ссылка на объект'
, 2 ,'Ссылка на строку'
, '???') 
PARTVIEW_LNK_RefType 
, 
 PARTVIEW_LNK.TheJoinDestination  
PARTVIEW_LNK_TheJoinDestination_ID, 
 MTZ.Func.ViewColumn_BRIEF_F(PARTVIEW_LNK.TheJoinDestination) 
PARTVIEW_LNK_TheJoinDestination 
, 
 PARTVIEW_LNK.TheView  
PARTVIEW_LNK_TheView_ID, 
 MTZ.Func.PARTVIEW_BRIEF_F(PARTVIEW_LNK.TheView) 
PARTVIEW_LNK_TheView 
, 
PARTVIEW_LNK.SEQ 
PARTVIEW_LNK_SEQ 
, 
 PARTVIEW_LNK.TheJoinSource  
PARTVIEW_LNK_TheJoinSource_ID, 
 MTZ.Func.ViewColumn_BRIEF_F(PARTVIEW_LNK.TheJoinSource) 
PARTVIEW_LNK_TheJoinSource 
, 
PARTVIEW_LNK.HandJoin 
PARTVIEW_LNK_HandJoin 
, OBJECTTYPE.InstanceID InstanceID 
, PARTVIEW_LNK.PARTVIEW_LNKID ID 
, 'PARTVIEW_LNK' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from PARTVIEW_LNK
 join PARTVIEW on PARTVIEW.PARTVIEWID=PARTVIEW_LNK.ParentStructRowID 
 join PART on PART.PARTID=PARTVIEW.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOVALIDATOR as 
select   VALIDATORID,PARTID,OBJECTTYPEID
, 
 VALIDATOR.Target  
VALIDATOR_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(VALIDATOR.Target) 
VALIDATOR_Target 
, 
VALIDATOR.Code 
VALIDATOR_Code 
, OBJECTTYPE.InstanceID InstanceID 
, VALIDATOR.VALIDATORID ID 
, 'VALIDATOR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from VALIDATOR
 join PART on PART.PARTID=VALIDATOR.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOUNIQUECONSTRAINT as 
select   UNIQUECONSTRAINTID,PARTID,OBJECTTYPEID
, 
UNIQUECONSTRAINT.Name 
UNIQUECONSTRAINT_Name 
, 
 UNIQUECONSTRAINT.PerParent  
UNIQUECONSTRAINT_PerParent_VAL, 
 decode(UNIQUECONSTRAINT.PerParent 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
UNIQUECONSTRAINT_PerParent 
, 
UNIQUECONSTRAINT.TheComment 
UNIQUECONSTRAINT_TheComment 
, OBJECTTYPE.InstanceID InstanceID 
, UNIQUECONSTRAINT.UNIQUECONSTRAINTID ID 
, 'UNIQUECONSTRAINT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from UNIQUECONSTRAINT
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOCONSTRAINTFIELD as 
select   CONSTRAINTFIELDID,UNIQUECONSTRAINTID,PARTID,OBJECTTYPEID
, 
 CONSTRAINTFIELD.TheField  
CONSTRAINTFIELD_TheField_ID, 
 MTZ.Func.FIELD_BRIEF_F(CONSTRAINTFIELD.TheField) 
CONSTRAINTFIELD_TheField 
, OBJECTTYPE.InstanceID InstanceID 
, CONSTRAINTFIELD.CONSTRAINTFIELDID ID 
, 'CONSTRAINTFIELD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from CONSTRAINTFIELD
 join UNIQUECONSTRAINT on UNIQUECONSTRAINT.UNIQUECONSTRAINTID=CONSTRAINTFIELD.ParentStructRowID 
 join PART on PART.PARTID=UNIQUECONSTRAINT.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOExtenderInterface as 
select   ExtenderInterfaceID,PARTID,OBJECTTYPEID
, 
ExtenderInterface.TheConfig 
ExtenderInterface_TheConfig 
, 
ExtenderInterface.TheName 
ExtenderInterface_TheName 
, 
 ExtenderInterface.TargetPlatform  
ExtenderInterface_TargetPlatform_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(ExtenderInterface.TargetPlatform) 
ExtenderInterface_TargetPlatform 
, 
ExtenderInterface.TheObject 
ExtenderInterface_TheObject 
, OBJECTTYPE.InstanceID InstanceID 
, ExtenderInterface.ExtenderInterfaceID ID 
, 'ExtenderInterface' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ExtenderInterface
 join PART on PART.PARTID=ExtenderInterface.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELD as 
select   FIELDID,PARTID,OBJECTTYPEID
, 
FIELD.Caption 
FIELD_Caption 
, 
 FIELD.AllowNull  
FIELD_AllowNull_VAL, 
 decode(FIELD.AllowNull 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_AllowNull 
, 
FIELD.FieldGroupBox 
FIELD_FieldGroupBox 
, 
FIELD.TheStyle 
FIELD_TheStyle 
, 
FIELD.theNameClass 
FIELD_theNameClass 
, 
FIELD.DataSize 
FIELD_DataSize 
, 
 FIELD.NumberDateField  
FIELD_NumberDateField_ID, 
 MTZ.Func.FIELD_BRIEF_F(FIELD.NumberDateField) 
FIELD_NumberDateField 
, 
 FIELD.IsAutoNumber  
FIELD_IsAutoNumber_VAL, 
 decode(FIELD.IsAutoNumber 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_IsAutoNumber 
, 
 FIELD.TheNumerator  
FIELD_TheNumerator_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(FIELD.TheNumerator) 
FIELD_TheNumerator 
, 
 FIELD.CreateRefOnly  
FIELD_CreateRefOnly_VAL, 
 decode(FIELD.CreateRefOnly 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_CreateRefOnly 
, 
FIELD.TheMask 
FIELD_TheMask 
, 
FIELD.TheComment 
FIELD_TheComment 
, 
FIELD.TabName 
FIELD_TabName 
, 
 FIELD.IsBrief  
FIELD_IsBrief_VAL, 
 decode(FIELD.IsBrief 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_IsBrief 
, 
 FIELD.ReferenceType  
FIELD_ReferenceType_VAL, 
 decode(FIELD.ReferenceType 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
FIELD_ReferenceType 
, 
 FIELD.RefToType  
FIELD_RefToType_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(FIELD.RefToType) 
FIELD_RefToType 
, 
 FIELD.RefToPart  
FIELD_RefToPart_ID, 
 MTZ.Func.PART_BRIEF_F(FIELD.RefToPart) 
FIELD_RefToPart 
, 
 FIELD.IsTabBrief  
FIELD_IsTabBrief_VAL, 
 decode(FIELD.IsTabBrief 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_IsTabBrief 
, 
 FIELD.FieldType  
FIELD_FieldType_ID, 
 MTZ.Func.FIELDTYPE_BRIEF_F(FIELD.FieldType) 
FIELD_FieldType 
, 
FIELD.ZoneTemplate 
FIELD_ZoneTemplate 
, 
 FIELD.InternalReference  
FIELD_InternalReference_VAL, 
 decode(FIELD.InternalReference 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELD_InternalReference 
, 
FIELD.Sequence 
FIELD_Sequence 
, 
FIELD.Name 
FIELD_Name 
, 
FIELD.shablonBrief 
FIELD_shablonBrief 
, OBJECTTYPE.InstanceID InstanceID 
, FIELD.FIELDID ID 
, 'FIELD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELD
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFldExtenders as 
select   FldExtendersID,FIELDID,PARTID,OBJECTTYPEID
, 
 FldExtenders.TargetPlatform  
FldExtenders_TargetPlatform_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(FldExtenders.TargetPlatform) 
FldExtenders_TargetPlatform 
, 
FldExtenders.TheConfig 
FldExtenders_TheConfig 
, 
FldExtenders.TheName 
FldExtenders_TheName 
, 
FldExtenders.TheObject 
FldExtenders_TheObject 
, OBJECTTYPE.InstanceID InstanceID 
, FldExtenders.FldExtendersID ID 
, 'FldExtenders' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FldExtenders
 join FIELD on FIELD.FIELDID=FldExtenders.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDSRCDEF as 
select   FIELDSRCDEFID,FIELDID,PARTID,OBJECTTYPEID
, 
FIELDSRCDEF.IDField 
FIELDSRCDEF_IDField 
, 
FIELDSRCDEF.BriefString 
FIELDSRCDEF_BriefString 
, 
 FIELDSRCDEF.DontShowDialog  
FIELDSRCDEF_DontShowDialog_VAL, 
 decode(FIELDSRCDEF.DontShowDialog 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDSRCDEF_DontShowDialog 
, 
FIELDSRCDEF.FilterString 
FIELDSRCDEF_FilterString 
, 
FIELDSRCDEF.DescriptionString 
FIELDSRCDEF_DescriptionString 
, 
FIELDSRCDEF.DataSource 
FIELDSRCDEF_DataSource 
, 
FIELDSRCDEF.Provider 
FIELDSRCDEF_Provider 
, 
FIELDSRCDEF.ConnectionString 
FIELDSRCDEF_ConnectionString 
, 
FIELDSRCDEF.SortField 
FIELDSRCDEF_SortField 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDSRCDEF.FIELDSRCDEFID ID 
, 'FIELDSRCDEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDSRCDEF
 join FIELD on FIELD.FIELDID=FIELDSRCDEF.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTODINAMICFILTERSCRIPT as 
select   DINAMICFILTERSCRIPTID,FIELDID,PARTID,OBJECTTYPEID
, 
 DINAMICFILTERSCRIPT.Target  
DINAMICFILTERSCRIPT_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(DINAMICFILTERSCRIPT.Target) 
DINAMICFILTERSCRIPT_Target 
, 
DINAMICFILTERSCRIPT.Code 
DINAMICFILTERSCRIPT_Code 
, OBJECTTYPE.InstanceID InstanceID 
, DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTID ID 
, 'DINAMICFILTERSCRIPT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from DINAMICFILTERSCRIPT
 join FIELD on FIELD.FIELDID=DINAMICFILTERSCRIPT.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDEXPRESSION as 
select   FIELDEXPRESSIONID,FIELDID,PARTID,OBJECTTYPEID
, 
 FIELDEXPRESSION.Target  
FIELDEXPRESSION_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(FIELDEXPRESSION.Target) 
FIELDEXPRESSION_Target 
, 
FIELDEXPRESSION.Code 
FIELDEXPRESSION_Code 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDEXPRESSION.FIELDEXPRESSIONID ID 
, 'FIELDEXPRESSION' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDEXPRESSION
 join FIELD on FIELD.FIELDID=FIELDEXPRESSION.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDVALIDATOR as 
select   FIELDVALIDATORID,FIELDID,PARTID,OBJECTTYPEID
, 
 FIELDVALIDATOR.Target  
FIELDVALIDATOR_Target_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(FIELDVALIDATOR.Target) 
FIELDVALIDATOR_Target 
, 
FIELDVALIDATOR.Code 
FIELDVALIDATOR_Code 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDVALIDATOR.FIELDVALIDATORID ID 
, 'FIELDVALIDATOR' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDVALIDATOR
 join FIELD on FIELD.FIELDID=FIELDVALIDATOR.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDMENU as 
select   FIELDMENUID,FIELDID,PARTID,OBJECTTYPEID
, 
 FIELDMENU.IsMenuItem  
FIELDMENU_IsMenuItem_VAL, 
 decode(FIELDMENU.IsMenuItem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDMENU_IsMenuItem 
, 
 FIELDMENU.IsToolBarButton  
FIELDMENU_IsToolBarButton_VAL, 
 decode(FIELDMENU.IsToolBarButton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDMENU_IsToolBarButton 
, 
FIELDMENU.ToolTip 
FIELDMENU_ToolTip 
, 
FIELDMENU.HotKey 
FIELDMENU_HotKey 
, 
 FIELDMENU.ActionID  
FIELDMENU_ActionID_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(FIELDMENU.ActionID) 
FIELDMENU_ActionID 
, 
FIELDMENU.Name 
FIELDMENU_Name 
, 
FIELDMENU.Caption 
FIELDMENU_Caption 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDMENU.FIELDMENUID ID 
, 'FIELDMENU' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDMENU
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFIELDPARAMMAP as 
select   FIELDPARAMMAPID,FIELDMENUID,FIELDID,PARTID,OBJECTTYPEID
, 
 FIELDPARAMMAP.NoEdit  
FIELDPARAMMAP_NoEdit_VAL, 
 decode(FIELDPARAMMAP.NoEdit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FIELDPARAMMAP_NoEdit 
, 
FIELDPARAMMAP.ParamName 
FIELDPARAMMAP_ParamName 
, 
FIELDPARAMMAP.FieldName 
FIELDPARAMMAP_FieldName 
, OBJECTTYPE.InstanceID InstanceID 
, FIELDPARAMMAP.FIELDPARAMMAPID ID 
, 'FIELDPARAMMAP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FIELDPARAMMAP
 join FIELDMENU on FIELDMENU.FIELDMENUID=FIELDPARAMMAP.ParentStructRowID 
 join FIELD on FIELD.FIELDID=FIELDMENU.ParentStructRowID 
 join PART on PART.PARTID=FIELD.ParentStructRowID 
 join OBJECTTYPE on OBJECTTYPE.OBJECTTYPEID=PART.ParentStructRowID 
 join INSTANCE on OBJECTTYPE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOMTZAPP as 
select   MTZAPPID
, 
MTZAPP.Name 
MTZAPP_Name 
, 
MTZAPP.TheComment 
MTZAPP_TheComment 
, 
MTZAPP.DBName 
MTZAPP_DBName 
, MTZAPP.InstanceID InstanceID 
, MTZAPP.MTZAPPID ID 
, 'MTZAPP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from MTZAPP
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOParentPackage as 
select   ParentPackageID,MTZAPPID
, 
 ParentPackage.Package  
ParentPackage_Package_ID, 
 MTZ.Func.MTZAPP_BRIEF_F(ParentPackage.Package) 
ParentPackage_Package 
, MTZAPP.InstanceID InstanceID 
, ParentPackage.ParentPackageID ID 
, 'ParentPackage' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ParentPackage
 join MTZAPP on MTZAPP.MTZAPPID=ParentPackage.ParentStructRowID 
 join INSTANCE on MTZAPP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOJournalColumn as 
select   JournalColumnID
, 
JournalColumn.name 
JournalColumn_name 
, 
 JournalColumn.ColSort  
JournalColumn_ColSort_VAL, 
 decode(JournalColumn.ColSort 
, 0 ,'As String'
, 1 ,'As Numeric'
, 2 ,'As Date'
, '???') 
JournalColumn_ColSort 
, 
JournalColumn.sequence 
JournalColumn_sequence 
, 
 JournalColumn.ColumnAlignment  
JournalColumn_ColumnAlignment_VAL, 
 decode(JournalColumn.ColumnAlignment 
, 6 ,'Right Top'
, 7 ,'Right Center'
, 8 ,'Right Bottom'
, 3 ,'Center Top'
, 0 ,'Left Top'
, 4 ,'Center Center'
, 1 ,'Left Center'
, 5 ,'Center Bottom'
, 2 ,'Left Bottom'
, '???') 
JournalColumn_ColumnAlignment 
, 
 JournalColumn.GroupAggregation  
JournalColumn_GroupAggregation_VAL, 
 decode(JournalColumn.GroupAggregation 
, 3 ,'SUM'
, 1 ,'AVG'
, 6 ,'CUSTOM'
, 0 ,'none'
, 2 ,'COUNT'
, 5 ,'MAX'
, 4 ,'MIN'
, '???') 
JournalColumn_GroupAggregation 
, JournalColumn.InstanceID InstanceID 
, JournalColumn.JournalColumnID ID 
, 'JournalColumn' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from JournalColumn
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOJColumnSource as 
select   JColumnSourceID,JournalColumnID
, 
JColumnSource.ViewField 
JColumnSource_ViewField 
, 
 JColumnSource.SrcPartView  
JColumnSource_SrcPartView_ID, 
 MTZ.Func.JournalSrc_BRIEF_F(JColumnSource.SrcPartView) 
JColumnSource_SrcPartView 
, JournalColumn.InstanceID InstanceID 
, JColumnSource.JColumnSourceID ID 
, 'JColumnSource' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from JColumnSource
 join JournalColumn on JournalColumn.JournalColumnID=JColumnSource.ParentStructRowID 
 join INSTANCE on JournalColumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOJournalSrc as 
select   JournalSrcID
, 
 JournalSrc.OnRun  
JournalSrc_OnRun_VAL, 
 decode(JournalSrc.OnRun 
, 2 ,'Открыть документ'
, 0 ,'Ничего не делать'
, 1 ,'Открыть строку'
, '???') 
JournalSrc_OnRun 
, 
JournalSrc.PartView 
JournalSrc_PartView 
, 
JournalSrc.ViewAlias 
JournalSrc_ViewAlias 
, 
JournalSrc.OpenMode 
JournalSrc_OpenMode 
, JournalSrc.InstanceID InstanceID 
, JournalSrc.JournalSrcID ID 
, 'JournalSrc' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from JournalSrc
 join INSTANCE on JournalSrc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOJournal as 
select   JournalID
, 
 Journal.UseFavorites  
Journal_UseFavorites_VAL, 
 decode(Journal.UseFavorites 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
Journal_UseFavorites 
, 
Journal.TheComment 
Journal_TheComment 
, 
Journal.jrnlIconCls 
Journal_jrnlIconCls 
, 
Journal.Name 
Journal_Name 
, 
Journal.the_Alias 
Journal_the_Alias 
, Journal.InstanceID InstanceID 
, Journal.JournalID ID 
, 'Journal' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Journal
 join INSTANCE on Journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFolder as 
select   FolderID
, 
Folder.Name 
Folder_Name 
, 
 Folder.FolderType  
Folder_FolderType_VAL, 
 decode(Folder.FolderType 
, 3 ,'Удаленные'
, 1 ,'Входящие'
, 9 ,'Отложенные'
, 4 ,'Журнал'
, 2 ,'Исходящие'
, 7 ,'Черновики'
, 6 ,'Отправленные'
, 8 ,'В работе'
, 5 ,'Календарь'
, 10 ,'Завершенные'
, 0 ,'cls__'
, '???') 
Folder_FolderType 
, Folder.InstanceID InstanceID 
, Folder.FolderID ID 
, 'Folder' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Folder
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOShortcut as 
select   ShortcutID,FolderID
, 
 Shortcut.DocItem  
Shortcut_DocItem_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(Shortcut.DocItem) 
Shortcut_DocItem 
, 
Shortcut.StartMode 
Shortcut_StartMode 
, Folder.InstanceID InstanceID 
, Shortcut.ShortcutID ID 
, 'Shortcut' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Shortcut
 join Folder on Folder.FolderID=Shortcut.ParentStructRowID 
 join INSTANCE on Folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOInfoStoreDef as 
select   InfoStoreDefID
, 
 InfoStoreDef.InfoStoreType  
InfoStoreDef_InfoStoreType_VAL, 
 decode(InfoStoreDef.InfoStoreType 
, 2 ,'Групповой'
, 0 ,' Общий'
, 1 ,'Персональный'
, '???') 
InfoStoreDef_InfoStoreType 
, 
InfoStoreDef.Name 
InfoStoreDef_Name 
, 
 InfoStoreDef.TheUser  
InfoStoreDef_TheUser_ID, 
 MTZ.Func.Users_BRIEF_F(InfoStoreDef.TheUser) 
InfoStoreDef_TheUser 
, 
 InfoStoreDef.TheGroup  
InfoStoreDef_TheGroup_ID, 
 MTZ.Func.Groups_BRIEF_F(InfoStoreDef.TheGroup) 
InfoStoreDef_TheGroup 
, InfoStoreDef.InstanceID InstanceID 
, InfoStoreDef.InfoStoreDefID ID 
, 'InfoStoreDef' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from InfoStoreDef
 join INSTANCE on InfoStoreDef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOthe_Session as 
select   the_SessionID
, 
 the_Session.Closed  
the_Session_Closed_VAL, 
 decode(the_Session.Closed 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
the_Session_Closed 
, 
the_Session.StartAt 
the_Session_StartAt 
, 
the_Session.ClosedAt 
the_Session_ClosedAt 
, 
the_Session.Lang 
the_Session_Lang 
, 
 the_Session.UserRole  
the_Session_UserRole_ID, 
 MTZ.Func.Groups_BRIEF_F(the_Session.UserRole) 
the_Session_UserRole 
, 
the_Session.LastAccess 
the_Session_LastAccess 
, 
the_Session.Login 
the_Session_Login 
, 
 the_Session.Usersid  
the_Session_Usersid_ID, 
 MTZ.Func.Users_BRIEF_F(the_Session.Usersid) 
the_Session_Usersid 
, 
 the_Session.ApplicationID  
the_Session_ApplicationID_ID, 
 MTZ.Func.WorkPlace_BRIEF_F(the_Session.ApplicationID) 
the_Session_ApplicationID 
, the_Session.InstanceID InstanceID 
, the_Session.the_SessionID ID 
, 'the_Session' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from the_Session
 join INSTANCE on the_Session.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOSysRefCache as 
select   SysRefCacheID
, 
SysRefCache.modulename 
SysRefCache_modulename 
, 
 SysRefCache.CacheType  
SysRefCache_CacheType_VAL, 
 decode(SysRefCache.CacheType 
, 2 ,'Все'
, 0 ,'Только свои'
, 1 ,'Подчиненные'
, '???') 
SysRefCache_CacheType 
, 
SysRefCache.ObjectOwnerID 
SysRefCache_ObjectOwnerID 
, 
 SysRefCache.SessionID  
SysRefCache_SessionID_ID, 
 MTZ.Func.the_Session_BRIEF_F(SysRefCache.SessionID) 
SysRefCache_SessionID 
, SysRefCache.InstanceID InstanceID 
, SysRefCache.SysRefCacheID ID 
, 'SysRefCache' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from SysRefCache
 join INSTANCE on SysRefCache.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOSysLog as 
select   SysLogID
, 
 SysLog.TheSession  
SysLog_TheSession_ID, 
 MTZ.Func.the_Session_BRIEF_F(SysLog.TheSession) 
SysLog_TheSession 
, 
SysLog.LogInstanceID 
SysLog_LogInstanceID 
, 
SysLog.the_Resource 
SysLog_the_Resource 
, 
SysLog.VERB 
SysLog_VERB 
, 
SysLog.LogStructID 
SysLog_LogStructID 
, SysLog.InstanceID InstanceID 
, SysLog.SysLogID ID 
, 'SysLog' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from SysLog
 join INSTANCE on SysLog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOARMJournal as 
select   ARMJournalID
, 
 ARMJournal.TheJournal  
ARMJournal_TheJournal_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(ARMJournal.TheJournal) 
ARMJournal_TheJournal 
, ARMJournal.InstanceID InstanceID 
, ARMJournal.ARMJournalID ID 
, 'ARMJournal' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ARMJournal
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOARMJRNLREP as 
select   ARMJRNLREPID,ARMJournalID
, 
 ARMJRNLREP.TheReport  
ARMJRNLREP_TheReport_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(ARMJRNLREP.TheReport) 
ARMJRNLREP_TheReport 
, 
ARMJRNLREP.repname 
ARMJRNLREP_repname 
, ARMJournal.InstanceID InstanceID 
, ARMJRNLREP.ARMJRNLREPID ID 
, 'ARMJRNLREP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ARMJRNLREP
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLREP.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOARMJRNLRUN as 
select   ARMJRNLRUNID,ARMJournalID
, 
ARMJRNLRUN.Name 
ARMJRNLRUN_Name 
, 
 ARMJRNLRUN.TheExtention  
ARMJRNLRUN_TheExtention_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(ARMJRNLRUN.TheExtention) 
ARMJRNLRUN_TheExtention 
, ARMJournal.InstanceID InstanceID 
, ARMJRNLRUN.ARMJRNLRUNID ID 
, 'ARMJRNLRUN' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ARMJRNLRUN
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLRUN.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOARMJRNLADD as 
select   ARMJRNLADDID,ARMJournalID
, 
ARMJRNLADD.Name 
ARMJRNLADD_Name 
, 
 ARMJRNLADD.TheExtention  
ARMJRNLADD_TheExtention_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(ARMJRNLADD.TheExtention) 
ARMJRNLADD_TheExtention 
, ARMJournal.InstanceID InstanceID 
, ARMJRNLADD.ARMJRNLADDID ID 
, 'ARMJRNLADD' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ARMJRNLADD
 join ARMJournal on ARMJournal.ARMJournalID=ARMJRNLADD.ParentStructRowID 
 join INSTANCE on ARMJournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOEntryPoints as 
select   EntryPointsID
, 
EntryPoints.JournalFixedQuery 
EntryPoints_JournalFixedQuery 
, 
 EntryPoints.AllowDel  
EntryPoints_AllowDel_VAL, 
 decode(EntryPoints.AllowDel 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AllowDel 
, 
EntryPoints.IconFile 
EntryPoints_IconFile 
, 
EntryPoints.Caption 
EntryPoints_Caption 
, 
 EntryPoints.Method  
EntryPoints_Method_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(EntryPoints.Method) 
EntryPoints_Method 
, 
 EntryPoints.AllowAdd  
EntryPoints_AllowAdd_VAL, 
 decode(EntryPoints.AllowAdd 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AllowAdd 
, 
 EntryPoints.Document  
EntryPoints_Document_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.Document) 
EntryPoints_Document 
, 
 EntryPoints.AllowEdit  
EntryPoints_AllowEdit_VAL, 
 decode(EntryPoints.AllowEdit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AllowEdit 
, 
 EntryPoints.AllowFilter  
EntryPoints_AllowFilter_VAL, 
 decode(EntryPoints.AllowFilter 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AllowFilter 
, 
 EntryPoints.AllowPrint  
EntryPoints_AllowPrint_VAL, 
 decode(EntryPoints.AllowPrint 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AllowPrint 
, 
 EntryPoints.Journal  
EntryPoints_Journal_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.Journal) 
EntryPoints_Journal 
, 
 EntryPoints.ActionType  
EntryPoints_ActionType_VAL, 
 decode(EntryPoints.ActionType 
, 4 ,'Запустить АРМ'
, 2 ,'Выполнить метод'
, 5 ,'Открыть отчет'
, 0 ,'Ничего не делать'
, 1 ,'Открыть документ'
, 3 ,'Открыть журнал'
, '???') 
EntryPoints_ActionType 
, 
EntryPoints.TheComment 
EntryPoints_TheComment 
, 
 EntryPoints.TheExtention  
EntryPoints_TheExtention_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.TheExtention) 
EntryPoints_TheExtention 
, 
EntryPoints.Name 
EntryPoints_Name 
, 
 EntryPoints.AsToolbarItem  
EntryPoints_AsToolbarItem_VAL, 
 decode(EntryPoints.AsToolbarItem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
EntryPoints_AsToolbarItem 
, 
EntryPoints.sequence 
EntryPoints_sequence 
, 
 EntryPoints.ARM  
EntryPoints_ARM_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.ARM) 
EntryPoints_ARM 
, 
 EntryPoints.Report  
EntryPoints_Report_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.Report) 
EntryPoints_Report 
, 
 EntryPoints.ObjectType  
EntryPoints_ObjectType_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(EntryPoints.ObjectType) 
EntryPoints_ObjectType 
, 
 EntryPoints.TheFilter  
EntryPoints_TheFilter_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(EntryPoints.TheFilter) 
EntryPoints_TheFilter 
, EntryPoints.InstanceID InstanceID 
, EntryPoints.EntryPointsID ID 
, 'EntryPoints' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from EntryPoints
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOEPFilterLink as 
select   EPFilterLinkID,EntryPointsID
, 
EPFilterLink.RowSource 
EPFilterLink_RowSource 
, 
EPFilterLink.FilterField 
EPFilterLink_FilterField 
, 
EPFilterLink.TheExpression 
EPFilterLink_TheExpression 
, EntryPoints.InstanceID InstanceID 
, EPFilterLink.EPFilterLinkID ID 
, 'EPFilterLink' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from EPFilterLink
 join EntryPoints on EntryPoints.EntryPointsID=EPFilterLink.ParentStructRowID 
 join INSTANCE on EntryPoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOWorkPlace as 
select   WorkPlaceID
, 
 WorkPlace.ThePlatform  
WorkPlace_ThePlatform_VAL, 
 decode(WorkPlace.ThePlatform 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
WorkPlace_ThePlatform 
, 
WorkPlace.TheComment 
WorkPlace_TheComment 
, 
WorkPlace.Caption 
WorkPlace_Caption 
, 
WorkPlace.TheVersion 
WorkPlace_TheVersion 
, 
WorkPlace.Name 
WorkPlace_Name 
, WorkPlace.InstanceID InstanceID 
, WorkPlace.WorkPlaceID ID 
, 'WorkPlace' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from WorkPlace
 join INSTANCE on WorkPlace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOARMTypes as 
select   ARMTypesID
, 
 ARMTypes.TheDocumentType  
ARMTypes_TheDocumentType_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(ARMTypes.TheDocumentType) 
ARMTypes_TheDocumentType 
, ARMTypes.InstanceID InstanceID 
, ARMTypes.ARMTypesID ID 
, 'ARMTypes' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ARMTypes
 join INSTANCE on ARMTypes.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_OPERATIONS as 
select   ROLES_OPERATIONSID
, 
ROLES_OPERATIONS.info 
ROLES_OPERATIONS_info 
, 
 ROLES_OPERATIONS.AllowAction  
ROLES_OPERATIONS_AllowAction_VAL, 
 decode(ROLES_OPERATIONS.AllowAction 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_OPERATIONS_AllowAction 
, 
ROLES_OPERATIONS.Name 
ROLES_OPERATIONS_Name 
, ROLES_OPERATIONS.InstanceID InstanceID 
, ROLES_OPERATIONS.ROLES_OPERATIONSID ID 
, 'ROLES_OPERATIONS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_OPERATIONS
 join INSTANCE on ROLES_OPERATIONS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_WP as 
select   ROLES_WPID
, 
 ROLES_WP.WP  
ROLES_WP_WP_ID, 
 MTZ.Func.WorkPlace_BRIEF_F(ROLES_WP.WP) 
ROLES_WP_WP 
, ROLES_WP.InstanceID InstanceID 
, ROLES_WP.ROLES_WPID ID 
, 'ROLES_WP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_WP
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_ACT as 
select   ROLES_ACTID,ROLES_WPID
, 
 ROLES_ACT.Accesible  
ROLES_ACT_Accesible_VAL, 
 decode(ROLES_ACT.Accesible 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_ACT_Accesible 
, 
ROLES_ACT.menuCode 
ROLES_ACT_menuCode 
, 
ROLES_ACT.MenuName 
ROLES_ACT_MenuName 
, ROLES_WP.InstanceID InstanceID 
, ROLES_ACT.ROLES_ACTID ID 
, 'ROLES_ACT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_ACT
 join ROLES_WP on ROLES_WP.ROLES_WPID=ROLES_ACT.ParentStructRowID 
 join INSTANCE on ROLES_WP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES2_MODULE as 
select   ROLES2_MODULEID
, 
ROLES2_MODULE.name 
ROLES2_MODULE_name 
, 
 ROLES2_MODULE.ModuleAccessible  
ROLES2_MODULE_ModuleAccessible_VAL, 
 decode(ROLES2_MODULE.ModuleAccessible 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODULE_ModuleAccessible 
, 
ROLES2_MODULE.Caption 
ROLES2_MODULE_Caption 
, 
 ROLES2_MODULE.CustomizeVisibility  
ROLES2_MODULE_CustomizeVisibility_VAL, 
 decode(ROLES2_MODULE.CustomizeVisibility 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODULE_CustomizeVisibility 
, 
ROLES2_MODULE.Sequence 
ROLES2_MODULE_Sequence 
, 
ROLES2_MODULE.TheComment 
ROLES2_MODULE_TheComment 
, 
ROLES2_MODULE.GroupName 
ROLES2_MODULE_GroupName 
, 
 ROLES2_MODULE.AllObjects  
ROLES2_MODULE_AllObjects_VAL, 
 decode(ROLES2_MODULE.AllObjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODULE_AllObjects 
, 
ROLES2_MODULE.TheIcon 
ROLES2_MODULE_TheIcon 
, 
 ROLES2_MODULE.SubStructObjects  
ROLES2_MODULE_SubStructObjects_VAL, 
 decode(ROLES2_MODULE.SubStructObjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODULE_SubStructObjects 
, 
 ROLES2_MODULE.ColegsObject  
ROLES2_MODULE_ColegsObject_VAL, 
 decode(ROLES2_MODULE.ColegsObject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODULE_ColegsObject 
, ROLES2_MODULE.InstanceID InstanceID 
, ROLES2_MODULE.ROLES2_MODULEID ID 
, 'ROLES2_MODULE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES2_MODULE
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES2_MODREPORT as 
select   ROLES2_MODREPORTID,ROLES2_MODULEID
, 
ROLES2_MODREPORT.TheIcon 
ROLES2_MODREPORT_TheIcon 
, 
ROLES2_MODREPORT.Name 
ROLES2_MODREPORT_Name 
, 
ROLES2_MODREPORT.selectType 
ROLES2_MODREPORT_selectType 
, 
 ROLES2_MODREPORT.IsReport  
ROLES2_MODREPORT_IsReport_VAL, 
 decode(ROLES2_MODREPORT.IsReport 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODREPORT_IsReport 
, 
ROLES2_MODREPORT.Sequence 
ROLES2_MODREPORT_Sequence 
, 
 ROLES2_MODREPORT.AllowAction  
ROLES2_MODREPORT_AllowAction_VAL, 
 decode(ROLES2_MODREPORT.AllowAction 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES2_MODREPORT_AllowAction 
, 
ROLES2_MODREPORT.Caption 
ROLES2_MODREPORT_Caption 
, ROLES2_MODULE.InstanceID InstanceID 
, ROLES2_MODREPORT.ROLES2_MODREPORTID ID 
, 'ROLES2_MODREPORT' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES2_MODREPORT
 join ROLES2_MODULE on ROLES2_MODULE.ROLES2_MODULEID=ROLES2_MODREPORT.ParentStructRowID 
 join INSTANCE on ROLES2_MODULE.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_DOC as 
select   ROLES_DOCID
, 
 ROLES_DOC.The_Document  
ROLES_DOC_The_Document_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(ROLES_DOC.The_Document) 
ROLES_DOC_The_Document 
, 
 ROLES_DOC.The_Denied  
ROLES_DOC_The_Denied_VAL, 
 decode(ROLES_DOC.The_Denied 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DOC_The_Denied 
, 
 ROLES_DOC.AllowDeleteDoc  
ROLES_DOC_AllowDeleteDoc_VAL, 
 decode(ROLES_DOC.AllowDeleteDoc 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DOC_AllowDeleteDoc 
, ROLES_DOC.InstanceID InstanceID 
, ROLES_DOC.ROLES_DOCID ID 
, 'ROLES_DOC' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_DOC
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_DOC_STATE as 
select   ROLES_DOC_STATEID,ROLES_DOCID
, 
 ROLES_DOC_STATE.The_State  
ROLES_DOC_STATE_The_State_ID, 
 MTZ.Func.OBJSTATUS_BRIEF_F(ROLES_DOC_STATE.The_State) 
ROLES_DOC_STATE_The_State 
, 
 ROLES_DOC_STATE.AllowDelete  
ROLES_DOC_STATE_AllowDelete_VAL, 
 decode(ROLES_DOC_STATE.AllowDelete 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DOC_STATE_AllowDelete 
, 
 ROLES_DOC_STATE.StateChangeDisabled  
ROLES_DOC_STATE_StateChangeDisabled_VAL, 
 decode(ROLES_DOC_STATE.StateChangeDisabled 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DOC_STATE_StateChangeDisabled 
, 
 ROLES_DOC_STATE.The_Mode  
ROLES_DOC_STATE_The_Mode_ID, 
 MTZ.Func.OBJECTMODE_BRIEF_F(ROLES_DOC_STATE.The_Mode) 
ROLES_DOC_STATE_The_Mode 
, ROLES_DOC.InstanceID InstanceID 
, ROLES_DOC_STATE.ROLES_DOC_STATEID ID 
, 'ROLES_DOC_STATE' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_DOC_STATE
 join ROLES_DOC on ROLES_DOC.ROLES_DOCID=ROLES_DOC_STATE.ParentStructRowID 
 join INSTANCE on ROLES_DOC.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_REPORTS as 
select   ROLES_REPORTSID
, 
 ROLES_REPORTS.The_Report  
ROLES_REPORTS_The_Report_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(ROLES_REPORTS.The_Report) 
ROLES_REPORTS_The_Report 
, ROLES_REPORTS.InstanceID InstanceID 
, ROLES_REPORTS.ROLES_REPORTSID ID 
, 'ROLES_REPORTS' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_REPORTS
 join INSTANCE on ROLES_REPORTS.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_USER as 
select   ROLES_USERID
, 
 ROLES_USER.TheUser  
ROLES_USER_TheUser_ID, 
 MTZ.Func.Users_BRIEF_F(ROLES_USER.TheUser) 
ROLES_USER_TheUser 
, ROLES_USER.InstanceID InstanceID 
, ROLES_USER.ROLES_USERID ID 
, 'ROLES_USER' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_USER
 join INSTANCE on ROLES_USER.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_MAP as 
select   ROLES_MAPID
, 
 ROLES_MAP.TheGroup  
ROLES_MAP_TheGroup_ID, 
 MTZ.Func.Groups_BRIEF_F(ROLES_MAP.TheGroup) 
ROLES_MAP_TheGroup 
, ROLES_MAP.InstanceID InstanceID 
, ROLES_MAP.ROLES_MAPID ID 
, 'ROLES_MAP' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_MAP
 join INSTANCE on ROLES_MAP.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOROLES_DEF as 
select   ROLES_DEFID
, 
 ROLES_DEF.SubStructObjects  
ROLES_DEF_SubStructObjects_VAL, 
 decode(ROLES_DEF.SubStructObjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DEF_SubStructObjects 
, 
 ROLES_DEF.AllObjects  
ROLES_DEF_AllObjects_VAL, 
 decode(ROLES_DEF.AllObjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DEF_AllObjects 
, 
ROLES_DEF.name 
ROLES_DEF_name 
, 
 ROLES_DEF.ColegsObject  
ROLES_DEF_ColegsObject_VAL, 
 decode(ROLES_DEF.ColegsObject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
ROLES_DEF_ColegsObject 
, ROLES_DEF.InstanceID InstanceID 
, ROLES_DEF.ROLES_DEFID ID 
, 'ROLES_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from ROLES_DEF
 join INSTANCE on ROLES_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOUsers as 
select   UsersID
, 
Users.DomaiName 
Users_DomaiName 
, 
Users.EMail 
Users_EMail 
, 
Users.Family 
Users_Family 
, 
Users.Name 
Users_Name 
, 
Users.LocalPhone 
Users_LocalPhone 
, 
Users.SurName 
Users_SurName 
, 
Users.Login 
Users_Login 
, 
Users.Phone 
Users_Phone 
, Users.InstanceID InstanceID 
, Users.UsersID ID 
, 'Users' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Users
 join INSTANCE on Users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGroups as 
select   GroupsID
, 
Groups.ADGroup 
Groups_ADGroup 
, 
Groups.Name 
Groups_Name 
, Groups.InstanceID InstanceID 
, Groups.GroupsID ID 
, 'Groups' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Groups
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOGroupUser as 
select   GroupUserID,GroupsID
, 
 GroupUser.TheUser  
GroupUser_TheUser_ID, 
 MTZ.Func.Users_BRIEF_F(GroupUser.TheUser) 
GroupUser_TheUser 
, Groups.InstanceID InstanceID 
, GroupUser.GroupUserID ID 
, 'GroupUser' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from GroupUser
 join Groups on Groups.GroupsID=GroupUser.ParentStructRowID 
 join INSTANCE on Groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTONum_zones as 
select   Num_zonesID
, 
Num_zones.ZoneMask 
Num_zones_ZoneMask 
, Num_zones.InstanceID InstanceID 
, Num_zones.Num_zonesID ID 
, 'Num_zones' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Num_zones
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTONum_Values as 
select   Num_ValuesID,Num_zonesID
, 
Num_Values.OwnerRowID 
Num_Values_OwnerRowID 
, 
Num_Values.the_Value 
Num_Values_the_Value 
, 
Num_Values.OwnerPartName 
Num_Values_OwnerPartName 
, Num_zones.InstanceID InstanceID 
, Num_Values.Num_ValuesID ID 
, 'Num_Values' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Num_Values
 join Num_zones on Num_zones.Num_zonesID=Num_Values.ParentStructRowID 
 join INSTANCE on Num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTONum_head as 
select   Num_headID
, 
Num_head.Name 
Num_head_Name 
, 
 Num_head.Shema  
Num_head_Shema_VAL, 
 decode(Num_head.Shema 
, 2 ,'По кварталу'
, 3 ,'По месяцу'
, 0 ,'Единая зона'
, 4 ,'По дню'
, 1 ,'По году'
, 10 ,'Произвольные зоны'
, '???') 
Num_head_Shema 
, Num_head.InstanceID InstanceID 
, Num_head.Num_headID ID 
, 'Num_head' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Num_head
 join INSTANCE on Num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOMTZExt_def as 
select   MTZExt_defID
, 
MTZExt_def.TheDescription 
MTZExt_def_TheDescription 
, 
 MTZExt_def.ExtType  
MTZExt_def_ExtType_VAL, 
 decode(MTZExt_def.ExtType 
, 6 ,'VerifyRowExt'
, 7 ,'CodeGenerator'
, 5 ,'DefaultExt'
, 0 ,'StatusExt'
, 4 ,'JrnlRunExt'
, 2 ,'CustomExt'
, 8 ,'ARMGenerator'
, 1 ,'OnFormExt'
, 3 ,'JrnlAddExt'
, '???') 
MTZExt_def_ExtType 
, 
MTZExt_def.Name 
MTZExt_def_Name 
, MTZExt_def.InstanceID InstanceID 
, MTZExt_def.MTZExt_defID ID 
, 'MTZExt_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from MTZExt_def
 join INSTANCE on MTZExt_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOMTZExtRel as 
select   MTZExtRelID
, 
MTZExtRel.TheClassName 
MTZExtRel_TheClassName 
, 
 MTZExtRel.ThePlatform  
MTZExtRel_ThePlatform_VAL, 
 decode(MTZExtRel.ThePlatform 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
MTZExtRel_ThePlatform 
, 
MTZExtRel.TheLibraryName 
MTZExtRel_TheLibraryName 
, MTZExtRel.InstanceID InstanceID 
, MTZExtRel.MTZExtRelID ID 
, 'MTZExtRel' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from MTZExtRel
 join INSTANCE on MTZExtRel.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOMTZ2JOB_DEF as 
select   MTZ2JOB_DEFID
, 
MTZ2JOB_DEF.ProcessDate 
MTZ2JOB_DEF_ProcessDate 
, 
MTZ2JOB_DEF.EvenType 
MTZ2JOB_DEF_EvenType 
, 
MTZ2JOB_DEF.ThruState 
MTZ2JOB_DEF_ThruState 
, 
 MTZ2JOB_DEF.ThruObject  
MTZ2JOB_DEF_ThruObject_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(MTZ2JOB_DEF.ThruObject) 
MTZ2JOB_DEF_ThruObject 
, 
MTZ2JOB_DEF.NextState 
MTZ2JOB_DEF_NextState 
, 
 MTZ2JOB_DEF.Processed  
MTZ2JOB_DEF_Processed_VAL, 
 decode(MTZ2JOB_DEF.Processed 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
MTZ2JOB_DEF_Processed 
, 
MTZ2JOB_DEF.EventDate 
MTZ2JOB_DEF_EventDate 
, MTZ2JOB_DEF.InstanceID InstanceID 
, MTZ2JOB_DEF.MTZ2JOB_DEFID ID 
, 'MTZ2JOB_DEF' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from MTZ2JOB_DEF
 join INSTANCE on MTZ2JOB_DEF.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFilterFieldGroup as 
select   FilterFieldGroupID
, 
FilterFieldGroup.Name 
FilterFieldGroup_Name 
, 
FilterFieldGroup.Caption 
FilterFieldGroup_Caption 
, 
 FilterFieldGroup.AllowIgnore  
FilterFieldGroup_AllowIgnore_VAL, 
 decode(FilterFieldGroup.AllowIgnore 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FilterFieldGroup_AllowIgnore 
, 
FilterFieldGroup.sequence 
FilterFieldGroup_sequence 
, FilterFieldGroup.InstanceID InstanceID 
, FilterFieldGroup.FilterFieldGroupID ID 
, 'FilterFieldGroup' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FilterFieldGroup
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFileterField as 
select   FileterFieldID,FilterFieldGroupID
, 
FileterField.sequence 
FileterField_sequence 
, 
FileterField.Name 
FileterField_Name 
, 
 FileterField.RefType  
FileterField_RefType_VAL, 
 decode(FileterField.RefType 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
FileterField_RefType 
, 
 FileterField.RefToType  
FileterField_RefToType_ID, 
 MTZ.Func.OBJECTTYPE_BRIEF_F(FileterField.RefToType) 
FileterField_RefToType 
, 
FileterField.Caption 
FileterField_Caption 
, 
FileterField.FieldSize 
FileterField_FieldSize 
, 
 FileterField.ValueArray  
FileterField_ValueArray_VAL, 
 decode(FileterField.ValueArray 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
FileterField_ValueArray 
, 
 FileterField.RefToPart  
FileterField_RefToPart_ID, 
 MTZ.Func.PART_BRIEF_F(FileterField.RefToPart) 
FileterField_RefToPart 
, 
 FileterField.FieldType  
FileterField_FieldType_ID, 
 MTZ.Func.FIELDTYPE_BRIEF_F(FileterField.FieldType) 
FileterField_FieldType 
, FilterFieldGroup.InstanceID InstanceID 
, FileterField.FileterFieldID ID 
, 'FileterField' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from FileterField
 join FilterFieldGroup on FilterFieldGroup.FilterFieldGroupID=FileterField.ParentStructRowID 
 join INSTANCE on FilterFieldGroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOFilters as 
select   FiltersID
, 
Filters.TheComment 
Filters_TheComment 
, 
Filters.Name 
Filters_Name 
, 
Filters.TheCaption 
Filters_TheCaption 
, Filters.InstanceID InstanceID 
, Filters.FiltersID ID 
, 'Filters' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Filters
 join INSTANCE on Filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTORPTStruct as 
select   RPTStructID
, 
RPTStruct.Caption 
RPTStruct_Caption 
, 
RPTStruct.Name 
RPTStruct_Name 
, RPTStruct.InstanceID InstanceID 
, RPTStruct.RPTStructID ID 
, 'RPTStruct' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from RPTStruct
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTORPTFields as 
select   RPTFieldsID,RPTStructID
, 
 RPTFields.FieldType  
RPTFields_FieldType_ID, 
 MTZ.Func.FIELDTYPE_BRIEF_F(RPTFields.FieldType) 
RPTFields_FieldType 
, 
RPTFields.FieldSize 
RPTFields_FieldSize 
, 
RPTFields.Name 
RPTFields_Name 
, 
RPTFields.Caption 
RPTFields_Caption 
, RPTStruct.InstanceID InstanceID 
, RPTFields.RPTFieldsID ID 
, 'RPTFields' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from RPTFields
 join RPTStruct on RPTStruct.RPTStructID=RPTFields.ParentStructRowID 
 join INSTANCE on RPTStruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTORPTFormula as 
select   RPTFormulaID
, 
 RPTFormula.Platform  
RPTFormula_Platform_ID, 
 MTZ.Func.GENERATOR_TARGET_BRIEF_F(RPTFormula.Platform) 
RPTFormula_Platform 
, 
RPTFormula.Code 
RPTFormula_Code 
, 
RPTFormula.Name 
RPTFormula_Name 
, RPTFormula.InstanceID InstanceID 
, RPTFormula.RPTFormulaID ID 
, 'RPTFormula' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from RPTFormula
 join INSTANCE on RPTFormula.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOReports as 
select   ReportsID
, 
 Reports.ReportType  
Reports_ReportType_VAL, 
 decode(Reports.ReportType 
, 4 ,'Экспорт по Excel шаблону'
, 0 ,'Таблица'
, 3 ,'Экспорт по WORD шаблону'
, 1 ,'Двумерная матрица'
, 2 ,'Только расчет'
, '???') 
Reports_ReportType 
, 
Reports.ReportView 
Reports_ReportView 
, 
Reports.Caption 
Reports_Caption 
, 
Reports.Name 
Reports_Name 
, 
 Reports.TheReportExt  
Reports_TheReportExt_ID, 
 MTZ.Func.INSTANCE_BRIEF_F(Reports.TheReportExt) 
Reports_TheReportExt 
, 
Reports.ReportFile 
Reports_ReportFile 
, 
 Reports.PrepareMethod  
Reports_PrepareMethod_ID, 
 MTZ.Func.SHAREDMETHOD_BRIEF_F(Reports.PrepareMethod) 
Reports_PrepareMethod 
, 
Reports.TheComment 
Reports_TheComment 
, Reports.InstanceID InstanceID 
, Reports.ReportsID ID 
, 'Reports' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from Reports
 join INSTANCE on Reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Kernel.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package Kernel as

procedure INSTANCE_OWNER   (
    acursession CHAR ,ainstanceid CHAR,
 aOwnerPartName varchar2, aOwnerRowID CHAR); 
procedure SYSOPTIONS_SAVE    (
 aSysOptionsid CHAR,
 aName varchar2,
 aValue varchar2 ,
 aOptionType varchar2);
procedure INSTANCE_SAVE      (
aCURSESSION CHAR,
aInstanceID CHAR,
aObjType varchar2,
aName varchar2
);
  procedure INSTANCE_DELETE    (
aCURSESSION CHAR,
aInstanceID Char
);
  procedure INSTANCE_HCL   (
aCURSESSION CHAR,
aRowID CHAR,
aIsLocked out NUMBER
);
  procedure INSTANCE_PROPAGATE   (
aCURSESSION CHAR,
aRowID Char
);
  procedure INSTANCE_ISLOCKED   (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
  procedure INSTANCE_SINIT    (
aCURSESSION CHAR,
aRowID CHAR ,
 aSecurityStyleID Char
);
  procedure INSTANCE_LOCK     (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer
) ;
  procedure INSTANCE_UNLOCK (
 aCURSESSION CHAR,
 aROWID Char
);
    procedure INSTANCE_BRIEF    (
 aCURSESSION CHAR,
 ainstanceid CHAR,
 aBRIEF out varchar2
) ;
    procedure QR_AND_QR  ( aid1 CHAR, aid2
    CHAR,aidout CHAR,acnt out integer );
    procedure QR_OR_QR  ( aid1 CHAR, aid2 
    CHAR,aidout CHAR,acnt out integer);
  procedure ROWPARENTS
(aQueryID   CHAR
,aRowID CHAR/* Row */
,aTable varchar2 /* Part Table Name */
,aCURSESSION CHAR/* the_session */
);
    procedure INSTANCE_STATUS    (
  acursession CHAR,
  ainstanceid CHAR,
  astatusid CHAR);
 end Kernel;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Type.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZMetaModel" BlockCode=" create or replace package MTZMetaModel as

procedure MTZMetaModel_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZMetaModel_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZMetaModel_propagate(acursession CHAR, aROWID CHAR); 

procedure GENPACKAGE_BRIEF  (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
 aBRIEF out varchar2
);
procedure GENPACKAGE_DELETE  (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
 ainstanceid char
); 
procedure GENPACKAGE_SAVE (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
); 
procedure GENPACKAGE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GENPACKAGE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GENPACKAGE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GENPACKAGE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GENPACKAGE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GENPACKAGE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GENPACKAGE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure GENERATOR_TARGET_BRIEF  (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
 aBRIEF out varchar2
);
procedure GENERATOR_TARGET_DELETE  (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
 ainstanceid char
); 
procedure GENERATOR_TARGET_SAVE (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTargetType
 NUMBER/* Тип платформы *//* Тип платформы */
,aQueueName
 VARCHAR2 := null /* Очередь *//* Очередь */
,aGeneratorProgID
 VARCHAR2 := null /* COM класс *//* COM класс */
,aGeneratorStyle
 NUMBER := null /* Вариант *//* Вариант */
,aTheDevelopmentEnv
 NUMBER := null /* Среда разработки *//* Среда разработки */
); 
procedure GENERATOR_TARGET_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GENERATOR_TARGET_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GENERATOR_TARGET_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GENERATOR_TARGET_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GENERATOR_TARGET_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GENERATOR_TARGET_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GENERATOR_TARGET_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure GENREFERENCE_BRIEF  (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
 aBRIEF out varchar2
);
procedure GENREFERENCE_DELETE  (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
 ainstanceid char
); 
procedure GENREFERENCE_SAVE (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aRefClassID
 VARCHAR2 := null /* Класс ссылки *//* Класс ссылки */
,aVersionMajor
 NUMBER := null /* Номер версии *//* Номер версии */
,aVersionMinor
 NUMBER := null /* Подверсия *//* Подверсия */
); 
procedure GENREFERENCE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GENREFERENCE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GENREFERENCE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GENREFERENCE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GENREFERENCE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GENREFERENCE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GENREFERENCE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure GENMANUALCODE_BRIEF  (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
 aBRIEF out varchar2
);
procedure GENMANUALCODE_DELETE  (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
 ainstanceid char
); 
procedure GENMANUALCODE_SAVE (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,aCode VARCHAR2/* Код *//* Код */
); 
procedure GENMANUALCODE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GENMANUALCODE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GENMANUALCODE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GENMANUALCODE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GENMANUALCODE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GENMANUALCODE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GENMANUALCODE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure GENCONTROLS_BRIEF  (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
 aBRIEF out varchar2
);
procedure GENCONTROLS_DELETE  (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
 ainstanceid char
); 
procedure GENCONTROLS_SAVE (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aControlProgID
 VARCHAR2/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,aControlClassID
 VARCHAR2 := null /* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aVersionMajor
 NUMBER := null /* Версия *//* Версия */
,aVersionMinor
 NUMBER := null /* Подверсия *//* Подверсия */
); 
procedure GENCONTROLS_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GENCONTROLS_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GENCONTROLS_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GENCONTROLS_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GENCONTROLS_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GENCONTROLS_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GENCONTROLS_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure LocalizeInfo_BRIEF  (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
 aBRIEF out varchar2
);
procedure LocalizeInfo_DELETE  (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
 ainstanceid char
); 
procedure LocalizeInfo_SAVE (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
aInstanceID CHAR 
,aLangFull
 VARCHAR2/* Язык - название *//* Язык - название */
,aLangShort
 VARCHAR2/* Код языка *//* Код языка */
); 
procedure LocalizeInfo_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure LocalizeInfo_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure LocalizeInfo_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure LocalizeInfo_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure LocalizeInfo_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure LocalizeInfo_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure LocalizeInfo_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDTYPE_BRIEF  (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
 aBRIEF out varchar2
);
procedure FIELDTYPE_DELETE  (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
 ainstanceid char
); 
procedure FIELDTYPE_SAVE (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTypeStyle
 NUMBER/* Трактовка *//* Трактовка */
,athe_Comment VARCHAR2 := null /* Описание *//* Описание */
,aAllowSize
 NUMBER/* Нужен размер *//* Нужен размер */
,aMinimum
 VARCHAR2 := null /* Минимум *//* Минимум */
,aMaximum
 VARCHAR2 := null /* Максимум *//* Максимум */
,aAllowLikeSearch
 NUMBER/* Поиск текста *//* Поиск текста */
,aGridSortType
 NUMBER := null /* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
,aDelayedSave
 NUMBER/* Отложенное сохранение *//* Отложенное сохранение */
); 
procedure FIELDTYPE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDTYPE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDTYPE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDTYPE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDTYPE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDTYPE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDTYPE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ENUMITEM_BRIEF  (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
 aBRIEF out varchar2
);
procedure ENUMITEM_DELETE  (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
 ainstanceid char
); 
procedure ENUMITEM_SAVE (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aNameValue
 NUMBER/* Значение *//* Значение */
,aNameInCode
 VARCHAR2 := null /* Название в коде *//* Название в коде */
); 
procedure ENUMITEM_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ENUMITEM_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ENUMITEM_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ENUMITEM_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ENUMITEM_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ENUMITEM_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ENUMITEM_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDTYPEMAP_BRIEF  (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
 aBRIEF out varchar2
);
procedure FIELDTYPEMAP_DELETE  (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
 ainstanceid char
); 
procedure FIELDTYPEMAP_SAVE (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aStoageType
 VARCHAR2/* Тип хранения *//* Тип хранения */
,aFixedSize
 NUMBER := null /* Размер *//* Размер */
); 
procedure FIELDTYPEMAP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDTYPEMAP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDTYPEMAP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDTYPEMAP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDTYPEMAP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDTYPEMAP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDTYPEMAP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure SHAREDMETHOD_BRIEF  (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
 aBRIEF out varchar2
);
procedure SHAREDMETHOD_DELETE  (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
 ainstanceid char
); 
procedure SHAREDMETHOD_SAVE (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Comment VARCHAR2 := null /* Описание метода *//* Описание метода */
,aReturnType CHAR := null /* Возвращаемый тип *//* Возвращаемый тип */
); 
procedure SHAREDMETHOD_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure SHAREDMETHOD_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure SHAREDMETHOD_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure SHAREDMETHOD_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure SHAREDMETHOD_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure SHAREDMETHOD_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure SHAREDMETHOD_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure SCRIPT_BRIEF  (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
 aBRIEF out varchar2
);
procedure SCRIPT_DELETE  (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
 ainstanceid char
); 
procedure SCRIPT_SAVE (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure SCRIPT_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure SCRIPT_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure SCRIPT_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure SCRIPT_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure SCRIPT_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure SCRIPT_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure SCRIPT_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PARAMETERS_BRIEF  (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
 aBRIEF out varchar2
);
procedure PARAMETERS_DELETE  (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
 ainstanceid char
); 
procedure PARAMETERS_SAVE (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Имя *//* Имя */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aTypeOfParm CHAR/* Тип данных *//* Тип данных */
,aDataSize
 NUMBER := null /* Размер *//* Размер */
,aAllowNull
 NUMBER/* Можно не задавать *//* Можно не задавать */
,aOutParam
 NUMBER/* Возвращает значение *//* Возвращает значение */
,aReferenceType
 NUMBER/* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,aRefToPart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
); 
procedure PARAMETERS_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PARAMETERS_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PARAMETERS_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PARAMETERS_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PARAMETERS_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PARAMETERS_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PARAMETERS_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure OBJECTTYPE_BRIEF  (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
 aBRIEF out varchar2
);
procedure OBJECTTYPE_DELETE  (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
 ainstanceid char
); 
procedure OBJECTTYPE_SAVE (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
aInstanceID CHAR 
,aPackage CHAR/* Приложение *//* Приложение */
,athe_Comment
 VARCHAR2/* Название *//* Название */
,aName
 VARCHAR2/* Код *//* Код */
,aIsSingleInstance
 NUMBER/* Допускается только один объект *//* Допускается только один объект */
,aChooseView CHAR := null /* Представление для выбора *//* Представление для выбора */
,aOnRun CHAR := null /* При запуске *//* При запуске */
,aOnCreate CHAR := null /* При создании *//* При создании */
,aOnDelete CHAR := null /* При удалении *//* При удалении */
,aAllowRefToObject
 NUMBER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aAllowSearch
 NUMBER/* Отображать при поиске *//* Отображать при поиске */
,aReplicaType
 NUMBER := null /* Тип репликации *//* Тип репликации */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,aUseOwnership
 NUMBER/* Видмость зависит от пользователя *//* Видмость зависит от пользователя */
,aUseArchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aCommitFullObject
 NUMBER/* Сохранять объект целиком *//* Сохранять объект целиком */
,aobjIconCls
 VARCHAR2 := null /* Иконка объекта *//* Иконка объекта */
); 
procedure OBJECTTYPE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure OBJECTTYPE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure OBJECTTYPE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure OBJECTTYPE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure OBJECTTYPE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure OBJECTTYPE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure OBJECTTYPE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure OBJSTATUS_BRIEF  (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
 aBRIEF out varchar2
);
procedure OBJSTATUS_DELETE  (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
 ainstanceid char
); 
procedure OBJSTATUS_SAVE (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aisStartup
 NUMBER/* Начальное *//* Начальное */
,aIsArchive
 NUMBER/* Архивное *//* Архивное */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure OBJSTATUS_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure OBJSTATUS_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure OBJSTATUS_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure OBJSTATUS_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure OBJSTATUS_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure OBJSTATUS_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure OBJSTATUS_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure NEXTSTATE_BRIEF  (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
 aBRIEF out varchar2
);
procedure NEXTSTATE_DELETE  (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
 ainstanceid char
); 
procedure NEXTSTATE_SAVE (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheState CHAR/* Разрешенное состояние *//* Разрешенное состояние */
); 
procedure NEXTSTATE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure NEXTSTATE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure NEXTSTATE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure NEXTSTATE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure NEXTSTATE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure NEXTSTATE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure NEXTSTATE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure OBJECTMODE_BRIEF  (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
 aBRIEF out varchar2
);
procedure OBJECTMODE_DELETE  (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
 ainstanceid char
); 
procedure OBJECTMODE_SAVE (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название режима *//* Название режима */
,aDefaultMode
 NUMBER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure OBJECTMODE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure OBJECTMODE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure OBJECTMODE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure OBJECTMODE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure OBJECTMODE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure OBJECTMODE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure OBJECTMODE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure STRUCTRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
 aBRIEF out varchar2
);
procedure STRUCTRESTRICTION_DELETE  (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
 ainstanceid char
); 
procedure STRUCTRESTRICTION_SAVE (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aStruct CHAR/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aAllowRead
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowAdd
 NUMBER/* Разрешено добавлять *//* Разрешено добавлять */
,aAllowEdit
 NUMBER/* Разрешено изменять *//* Разрешено изменять */
,aAllowDelete
 NUMBER/* Разрешено удалять *//* Разрешено удалять */
); 
procedure STRUCTRESTRICTION_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure STRUCTRESTRICTION_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure STRUCTRESTRICTION_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure STRUCTRESTRICTION_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure STRUCTRESTRICTION_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure STRUCTRESTRICTION_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure STRUCTRESTRICTION_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure METHODRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
 aBRIEF out varchar2
);
procedure METHODRESTRICTION_DELETE  (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
 ainstanceid char
); 
procedure METHODRESTRICTION_SAVE (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aPart CHAR := null /* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,aMethod CHAR/* Метод *//* Метод */
,aIsRestricted
 NUMBER/* Запрещено использовать *//* Запрещено использовать */
); 
procedure METHODRESTRICTION_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure METHODRESTRICTION_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure METHODRESTRICTION_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure METHODRESTRICTION_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure METHODRESTRICTION_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure METHODRESTRICTION_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure METHODRESTRICTION_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
 aBRIEF out varchar2
);
procedure FIELDRESTRICTION_DELETE  (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
 ainstanceid char
); 
procedure FIELDRESTRICTION_SAVE (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aThePart CHAR/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,aTheField CHAR/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aAllowRead
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowModify
 NUMBER/* Разрешена модификация *//* Разрешена модификация */
,aMandatoryField
 NUMBER := null /* Обязательное поле *//* Обязательное поле */
); 
procedure FIELDRESTRICTION_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDRESTRICTION_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDRESTRICTION_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDRESTRICTION_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDRESTRICTION_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDRESTRICTION_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDRESTRICTION_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure TYPEMENU_BRIEF  (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
 aBRIEF out varchar2
);
procedure TYPEMENU_DELETE  (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
 ainstanceid char
); 
procedure TYPEMENU_SAVE (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_Action CHAR := null /* Метод *//* Метод */
,aIsMenuItem
 NUMBER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 NUMBER/* Включать в тулбар *//* Включать в тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure TYPEMENU_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure TYPEMENU_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure TYPEMENU_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure TYPEMENU_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure TYPEMENU_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure TYPEMENU_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure TYPEMENU_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure INSTANCEVALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
 aBRIEF out varchar2
);
procedure INSTANCEVALIDATOR_DELETE  (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
 ainstanceid char
); 
procedure INSTANCEVALIDATOR_SAVE (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure INSTANCEVALIDATOR_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure INSTANCEVALIDATOR_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure INSTANCEVALIDATOR_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure INSTANCEVALIDATOR_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure INSTANCEVALIDATOR_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure INSTANCEVALIDATOR_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure INSTANCEVALIDATOR_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PART_BRIEF  (
 aCURSESSION CHAR,
 aPARTid CHAR,
 aBRIEF out varchar2
);
procedure PART_DELETE  (
 aCURSESSION CHAR,
 aPARTid CHAR,
 ainstanceid char
); 
procedure PART_SAVE (
 aCURSESSION CHAR,
 aPARTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
, aParentRowid CHAR :=null
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aPartType
 NUMBER/* Тип структры *//* Тип структры */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aName
 VARCHAR2/* Название *//* Название */
,athe_Comment VARCHAR2 := null /* Описание *//* Описание */
,aNoLog
 NUMBER/* Не записывать в журнал *//* Не записывать в журнал */
,aManualRegister
 NUMBER/* Исключить из индексирования *//* Исключить из индексирования */
,aOnCreate CHAR := null /* При создании *//* При создании */
,aOnSave CHAR := null /* При сохранении *//* При сохранении */
,aOnRun CHAR := null /* При открытии *//* При открытии */
,aOnDelete CHAR := null /* При удалении *//* При удалении */
,aAddBehaivor
 NUMBER := null /* Поведение при добавлении *//* Поведение при добавлении */
,aExtenderObject CHAR := null /* Объект расширения *//* Объект расширения */
,ashablonBrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,aruleBrief
 VARCHAR2 := null /* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aIsJormalChange
 NUMBER/* Вести журнал изменений *//* Вести журнал изменений */
,aUseArchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aintegerpkey
 NUMBER/* Целочисленный ключ *//* Целочисленный ключ */
,apartIconCls
 VARCHAR2 := null /* Иконка раздела *//* Иконка раздела */
); 
procedure PART_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PART_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PART_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PART_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PART_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PART_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PART_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PARTMENU_BRIEF  (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
 aBRIEF out varchar2
);
procedure PARTMENU_DELETE  (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
 ainstanceid char
); 
procedure PARTMENU_SAVE (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_Action CHAR := null /* Метод *//* Метод */
,aIsMenuItem
 NUMBER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 NUMBER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure PARTMENU_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PARTMENU_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PARTMENU_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PARTMENU_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PARTMENU_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PARTMENU_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PARTMENU_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PARTPARAMMAP_BRIEF  (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
 aBRIEF out varchar2
);
procedure PARTPARAMMAP_DELETE  (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
 ainstanceid char
); 
procedure PARTPARAMMAP_SAVE (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aFieldName
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR2/* Параметр *//* Параметр */
,aNoEdit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
); 
procedure PARTPARAMMAP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PARTPARAMMAP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PARTPARAMMAP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PARTPARAMMAP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PARTPARAMMAP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PARTPARAMMAP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PARTPARAMMAP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PARTVIEW_BRIEF  (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
 aBRIEF out varchar2
);
procedure PARTVIEW_DELETE  (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
 ainstanceid char
); 
procedure PARTVIEW_SAVE (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2/* Псевдоним *//* Псевдоним */
,aForChoose
 NUMBER/* Для поиска *//* Для поиска */
,aFilterField0
 VARCHAR2 := null /* Поле - фильтр 0 *//* Поле - фильтр 0 */
,aFilterField1
 VARCHAR2 := null /* Поле - фильтр 1 *//* Поле - фильтр 1 */
,aFilterField2
 VARCHAR2 := null /* Поле - фильтр 2 *//* Поле - фильтр 2 */
,aFilterField3
 VARCHAR2 := null /* Поле - фильтр 3 *//* Поле - фильтр 3 */
); 
procedure PARTVIEW_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PARTVIEW_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PARTVIEW_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PARTVIEW_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PARTVIEW_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PARTVIEW_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PARTVIEW_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ViewColumn_BRIEF  (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
 aBRIEF out varchar2
);
procedure ViewColumn_DELETE  (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
 ainstanceid char
); 
procedure ViewColumn_SAVE (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER := null /* № *//* № */
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2/* Псвдоним *//* Псвдоним */
,aFromPart CHAR/* Раздел *//* Раздел */
,aField CHAR/* Поле *//* Поле */
,aAggregation
 NUMBER/* Агрегация *//* Агрегация */
,aExpression VARCHAR2 := null /* Формула *//* Формула */
,aForCombo
 NUMBER/* Для комбо *//* Для комбо */
); 
procedure ViewColumn_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ViewColumn_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ViewColumn_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ViewColumn_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ViewColumn_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ViewColumn_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ViewColumn_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure PARTVIEW_LNK_BRIEF  (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
 aBRIEF out varchar2
);
procedure PARTVIEW_LNK_DELETE  (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
 ainstanceid char
); 
procedure PARTVIEW_LNK_SAVE (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheView CHAR/* Представление *//* Представление */
,aTheJoinSource CHAR := null /* Связь: Поле для join источник *//* Связь: Поле для join источник */
,aRefType
 NUMBER/* Связывать как *//* Связывать как */
,aTheJoinDestination CHAR := null /* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,aHandJoin
 VARCHAR2 := null /* Ручной join *//* Ручной join */
,aSEQ
 NUMBER/* Порядок *//* Порядок */
); 
procedure PARTVIEW_LNK_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure PARTVIEW_LNK_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure PARTVIEW_LNK_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure PARTVIEW_LNK_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure PARTVIEW_LNK_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure PARTVIEW_LNK_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure PARTVIEW_LNK_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure VALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
 aBRIEF out varchar2
);
procedure VALIDATOR_DELETE  (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
 ainstanceid char
); 
procedure VALIDATOR_SAVE (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure VALIDATOR_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure VALIDATOR_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure VALIDATOR_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure VALIDATOR_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure VALIDATOR_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure VALIDATOR_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure VALIDATOR_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure UNIQUECONSTRAINT_BRIEF  (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
 aBRIEF out varchar2
);
procedure UNIQUECONSTRAINT_DELETE  (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
 ainstanceid char
); 
procedure UNIQUECONSTRAINT_SAVE (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aPerParent
 NUMBER/* По родителю *//* По родителю */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure UNIQUECONSTRAINT_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure UNIQUECONSTRAINT_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure UNIQUECONSTRAINT_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure UNIQUECONSTRAINT_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure UNIQUECONSTRAINT_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure UNIQUECONSTRAINT_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure UNIQUECONSTRAINT_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure CONSTRAINTFIELD_BRIEF  (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
 aBRIEF out varchar2
);
procedure CONSTRAINTFIELD_DELETE  (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
 ainstanceid char
); 
procedure CONSTRAINTFIELD_SAVE (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheField CHAR/* Поле *//* Поле */
); 
procedure CONSTRAINTFIELD_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure CONSTRAINTFIELD_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure CONSTRAINTFIELD_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure CONSTRAINTFIELD_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure CONSTRAINTFIELD_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure CONSTRAINTFIELD_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure CONSTRAINTFIELD_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ExtenderInterface_BRIEF  (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
 aBRIEF out varchar2
);
procedure ExtenderInterface_DELETE  (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
 ainstanceid char
); 
procedure ExtenderInterface_SAVE (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheName
 VARCHAR2/* Название *//* Название */
,aTargetPlatform CHAR/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR2/* Объект *//* Объект */
,aTheConfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
); 
procedure ExtenderInterface_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ExtenderInterface_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ExtenderInterface_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ExtenderInterface_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ExtenderInterface_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ExtenderInterface_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ExtenderInterface_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELD_BRIEF  (
 aCURSESSION CHAR,
 aFIELDid CHAR,
 aBRIEF out varchar2
);
procedure FIELD_DELETE  (
 aCURSESSION CHAR,
 aFIELDid CHAR,
 ainstanceid char
); 
procedure FIELD_SAVE (
 aCURSESSION CHAR,
 aFIELDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTabName
 VARCHAR2 := null /* Имя вкладки *//* Имя вкладки */
,aFieldGroupBox
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aName
 VARCHAR2/* Имя поля *//* Имя поля */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aIsBrief
 NUMBER/* Краткая информация *//* Краткая информация */
,aIsTabBrief
 NUMBER/* Для отображения в таблице *//* Для отображения в таблице */
,aAllowNull
 NUMBER/* Может быть пустым *//* Может быть пустым */
,aDataSize
 NUMBER := null /* Размер поля *//* Размер поля */
,aReferenceType
 NUMBER/* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,aRefToPart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
,aTheStyle
 VARCHAR2 := null /* Стиль *//* Стиль */
,aInternalReference
 NUMBER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,aCreateRefOnly
 NUMBER/* Только создание объекта *//* Только создание объекта */
,aIsAutoNumber
 NUMBER/* Автонумерация *//* Автонумерация */
,aTheNumerator CHAR := null /* Нумератор *//* Нумератор */
,aZoneTemplate
 VARCHAR2 := null /* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,aNumberDateField CHAR := null /* Поле для расчета даты *//* Поле для расчета даты */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,ashablonBrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,atheNameClass
 VARCHAR2 := null /* Имя класса для мастера строк *//* Имя класса для мастера строк */
,aTheMask
 VARCHAR2 := null /* Маска *//* Маска */
); 
procedure FIELD_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELD_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELD_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELD_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELD_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELD_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELD_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FldExtenders_BRIEF  (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
 aBRIEF out varchar2
);
procedure FldExtenders_DELETE  (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
 ainstanceid char
); 
procedure FldExtenders_SAVE (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheName
 VARCHAR2/* Название *//* Название */
,aTargetPlatform CHAR/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR2/* Объект *//* Объект */
,aTheConfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
); 
procedure FldExtenders_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FldExtenders_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FldExtenders_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FldExtenders_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FldExtenders_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FldExtenders_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FldExtenders_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDSRCDEF_BRIEF  (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
 aBRIEF out varchar2
);
procedure FIELDSRCDEF_DELETE  (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
 ainstanceid char
); 
procedure FIELDSRCDEF_SAVE (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aProvider
 VARCHAR2 := null /* Провайдер *//* Провайдер */
,aConnectionString
 VARCHAR2 := null /* Строка соединения с источником *//* Строка соединения с источником */
,aDataSource
 VARCHAR2/* Источник данных *//* Источник данных */
,aIDField
 VARCHAR2 := null /* ID *//* ID */
,aBriefString
 VARCHAR2 := null /* Источник краткой информации *//* Источник краткой информации */
,aFilterString
 VARCHAR2 := null /* Фильтр источника данных *//* Фильтр источника данных */
,aSortField
 VARCHAR2 := null /* Сортировка источника данных *//* Сортировка источника данных */
,aDescriptionString VARCHAR2 := null /* Примечания *//* Примечания */
,aDontShowDialog
 NUMBER := null /* Не показывать форму выбора *//* Не показывать форму выбора */
); 
procedure FIELDSRCDEF_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDSRCDEF_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDSRCDEF_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDSRCDEF_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDSRCDEF_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDSRCDEF_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDSRCDEF_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure DINAMICFILTERSCRIPT_BRIEF  (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
 aBRIEF out varchar2
);
procedure DINAMICFILTERSCRIPT_DELETE  (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
 ainstanceid char
); 
procedure DINAMICFILTERSCRIPT_SAVE (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure DINAMICFILTERSCRIPT_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure DINAMICFILTERSCRIPT_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure DINAMICFILTERSCRIPT_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure DINAMICFILTERSCRIPT_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure DINAMICFILTERSCRIPT_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure DINAMICFILTERSCRIPT_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure DINAMICFILTERSCRIPT_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDEXPRESSION_BRIEF  (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
 aBRIEF out varchar2
);
procedure FIELDEXPRESSION_DELETE  (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
 ainstanceid char
); 
procedure FIELDEXPRESSION_SAVE (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure FIELDEXPRESSION_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDEXPRESSION_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDEXPRESSION_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDEXPRESSION_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDEXPRESSION_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDEXPRESSION_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDEXPRESSION_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDVALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
 aBRIEF out varchar2
);
procedure FIELDVALIDATOR_DELETE  (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
 ainstanceid char
); 
procedure FIELDVALIDATOR_SAVE (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure FIELDVALIDATOR_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDVALIDATOR_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDVALIDATOR_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDVALIDATOR_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDVALIDATOR_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDVALIDATOR_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDVALIDATOR_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDMENU_BRIEF  (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
 aBRIEF out varchar2
);
procedure FIELDMENU_DELETE  (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
 ainstanceid char
); 
procedure FIELDMENU_SAVE (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,aActionID CHAR/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aIsMenuItem
 NUMBER/* В меню *//* В меню */
,aIsToolBarButton
 NUMBER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure FIELDMENU_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDMENU_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDMENU_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDMENU_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDMENU_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDMENU_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDMENU_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FIELDPARAMMAP_BRIEF  (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
 aBRIEF out varchar2
);
procedure FIELDPARAMMAP_DELETE  (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
 ainstanceid char
); 
procedure FIELDPARAMMAP_SAVE (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aFieldName
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR2/* Параметр *//* Параметр */
,aNoEdit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
); 
procedure FIELDPARAMMAP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FIELDPARAMMAP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FIELDPARAMMAP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FIELDPARAMMAP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FIELDPARAMMAP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FIELDPARAMMAP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FIELDPARAMMAP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure MTZAPP_BRIEF  (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
 aBRIEF out varchar2
);
procedure MTZAPP_DELETE  (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
 ainstanceid char
); 
procedure MTZAPP_SAVE (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aDBName
 VARCHAR2 := null /* База данных *//* База данных */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure MTZAPP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure MTZAPP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure MTZAPP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure MTZAPP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure MTZAPP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure MTZAPP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure MTZAPP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ParentPackage_BRIEF  (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
 aBRIEF out varchar2
);
procedure ParentPackage_DELETE  (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
 ainstanceid char
); 
procedure ParentPackage_SAVE (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aPackage CHAR/* Приложение *//* Приложение */
); 
procedure ParentPackage_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ParentPackage_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ParentPackage_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ParentPackage_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ParentPackage_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ParentPackage_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ParentPackage_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZMetaModel;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZJrnl" BlockCode=" create or replace package MTZJrnl as

procedure MTZJrnl_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZJrnl_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZJrnl_propagate(acursession CHAR, aROWID CHAR); 

procedure JournalColumn_BRIEF  (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
 aBRIEF out varchar2
);
procedure JournalColumn_DELETE  (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
 ainstanceid char
); 
procedure JournalColumn_SAVE (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER := null /* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,aColumnAlignment
 NUMBER/* Выравнивание *//* Выравнивание */
,aColSort
 NUMBER/* Сортировка колонки *//* Сортировка колонки */
,aGroupAggregation
 NUMBER/* Аггрегация при группировке *//* Аггрегация при группировке */
); 
procedure JournalColumn_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure JournalColumn_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure JournalColumn_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure JournalColumn_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure JournalColumn_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure JournalColumn_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure JournalColumn_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure JColumnSource_BRIEF  (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
 aBRIEF out varchar2
);
procedure JColumnSource_DELETE  (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
 ainstanceid char
); 
procedure JColumnSource_SAVE (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aSrcPartView CHAR/* Представление *//* Представление */
,aViewField
 VARCHAR2/* Поле представления *//* Поле представления */
); 
procedure JColumnSource_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure JColumnSource_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure JColumnSource_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure JColumnSource_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure JColumnSource_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure JColumnSource_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure JColumnSource_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure JournalSrc_BRIEF  (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
 aBRIEF out varchar2
);
procedure JournalSrc_DELETE  (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
 ainstanceid char
); 
procedure JournalSrc_SAVE (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
aInstanceID CHAR 
,aPartView CHAR/* Представление *//* Представление */
,aOnRun
 NUMBER/* При открытии *//* При открытии */
,aOpenMode
 VARCHAR2 := null /* Режим открытия *//* Режим открытия */
,aViewAlias
 VARCHAR2 := null /* Псевдоним представления *//* Псевдоним представления */
); 
procedure JournalSrc_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure JournalSrc_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure JournalSrc_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure JournalSrc_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure JournalSrc_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure JournalSrc_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure JournalSrc_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Journal_BRIEF  (
 aCURSESSION CHAR,
 aJournalid CHAR,
 aBRIEF out varchar2
);
procedure Journal_DELETE  (
 aCURSESSION CHAR,
 aJournalid CHAR,
 ainstanceid char
); 
procedure Journal_SAVE (
 aCURSESSION CHAR,
 aJournalid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,ajrnlIconCls
 VARCHAR2 := null /* Иконка журнала *//* Иконка журнала */
,aUseFavorites
 NUMBER/* Массовое выделение *//* Массовое выделение */
); 
procedure Journal_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Journal_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Journal_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Journal_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Journal_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Journal_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Journal_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZJrnl;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tod" BlockCode=" create or replace package tod as

procedure tod_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tod_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tod_propagate(acursession CHAR, aROWID CHAR); 

procedure tod_bug_BRIEF  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 aBRIEF out varchar2
);
procedure tod_bug_DELETE  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 ainstanceid char
); 
procedure tod_bug_SAVE (
 aCURSESSION CHAR,
 atod_bugid CHAR,
aInstanceID CHAR 
); 
procedure tod_bug_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_bug_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_bug_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_bug_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_bug_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_bug_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_bug_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_st_BRIEF  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 aBRIEF out varchar2
);
procedure tod_st_DELETE  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 ainstanceid char
); 
procedure tod_st_SAVE (
 aCURSESSION CHAR,
 atod_stid CHAR,
aInstanceID CHAR 
); 
procedure tod_st_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_st_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_st_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_st_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_st_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_st_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_st_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end tod;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--STDInfoStore" BlockCode=" create or replace package STDInfoStore as

procedure STDInfoStore_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure STDInfoStore_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure STDInfoStore_propagate(acursession CHAR, aROWID CHAR); 

procedure Folder_BRIEF  (
 aCURSESSION CHAR,
 aFolderid CHAR,
 aBRIEF out varchar2
);
procedure Folder_DELETE  (
 aCURSESSION CHAR,
 aFolderid CHAR,
 ainstanceid char
); 
procedure Folder_SAVE (
 aCURSESSION CHAR,
 aFolderid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aName
 VARCHAR2/* Название *//* Название */
,aFolderType
 NUMBER/* Тип папки *//* Тип папки */
); 
procedure Folder_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Folder_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Folder_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Folder_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Folder_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Folder_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Folder_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Shortcut_BRIEF  (
 aCURSESSION CHAR,
 aShortcutid CHAR,
 aBRIEF out varchar2
);
procedure Shortcut_DELETE  (
 aCURSESSION CHAR,
 aShortcutid CHAR,
 ainstanceid char
); 
procedure Shortcut_SAVE (
 aCURSESSION CHAR,
 aShortcutid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aDocItem CHAR/* Документ *//* Документ */
,aStartMode
 VARCHAR2 := null /* Режим *//* Режим */
); 
procedure Shortcut_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Shortcut_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Shortcut_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Shortcut_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Shortcut_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Shortcut_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Shortcut_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure InfoStoreDef_BRIEF  (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
 aBRIEF out varchar2
);
procedure InfoStoreDef_DELETE  (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
 ainstanceid char
); 
procedure InfoStoreDef_SAVE (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
aInstanceID CHAR 
,aTheGroup CHAR := null /* Группа *//* Группа */
,aName
 VARCHAR2/* Название *//* Название */
,aInfoStoreType
 NUMBER/* Тип каталога *//* Тип каталога */
,aTheUser CHAR := null /* Пользователь *//* Пользователь */
); 
procedure InfoStoreDef_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure InfoStoreDef_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure InfoStoreDef_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure InfoStoreDef_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure InfoStoreDef_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure InfoStoreDef_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure InfoStoreDef_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end STDInfoStore;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZSystem" BlockCode=" create or replace package MTZSystem as

procedure MTZSystem_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZSystem_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZSystem_propagate(acursession CHAR, aROWID CHAR); 

procedure the_Session_BRIEF  (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
 aBRIEF out varchar2
);
procedure the_Session_DELETE  (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
 ainstanceid char
); 
procedure the_Session_SAVE (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
aInstanceID CHAR 
,aApplicationID CHAR := null /* Приложение *//* Приложение */
,aUserRole CHAR/* Текущая роль пользователя *//* Текущая роль пользователя */
,aClosedAt
 DATE := null /* Момент закрытия *//* Момент закрытия */
,aClosed
 NUMBER/* Закрыта *//* Закрыта */
,aUsersid CHAR/* Пользователь *//* Пользователь */
,aLastAccess
 DATE := null /* Последнее подтверждение *//* Последнее подтверждение */
,aStartAt
 DATE/* Момент открытия *//* Момент открытия */
,aLang
 VARCHAR2 := null /* Локализация *//* Локализация */
,aLogin
 VARCHAR2 := null /* Login *//* Login */
); 
procedure the_Session_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure the_Session_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure the_Session_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure the_Session_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure the_Session_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure the_Session_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure the_Session_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure SysRefCache_BRIEF  (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
 aBRIEF out varchar2
);
procedure SysRefCache_DELETE  (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
 ainstanceid char
); 
procedure SysRefCache_SAVE (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
aInstanceID CHAR 
,aCacheType
 NUMBER/* Тип кеширования *//* Тип кеширования */
,aObjectOwnerID CHAR/* Идентификатор владельца *//* Идентификатор владельца */
,aSessionID CHAR/* Сессия *//* Сессия */
,amodulename
 VARCHAR2 := null /* модуль *//* модуль */
); 
procedure SysRefCache_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure SysRefCache_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure SysRefCache_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure SysRefCache_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure SysRefCache_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure SysRefCache_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure SysRefCache_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure SysLog_BRIEF  (
 aCURSESSION CHAR,
 aSysLogid CHAR,
 aBRIEF out varchar2
);
procedure SysLog_DELETE  (
 aCURSESSION CHAR,
 aSysLogid CHAR,
 ainstanceid char
); 
procedure SysLog_SAVE (
 aCURSESSION CHAR,
 aSysLogid CHAR,
aInstanceID CHAR 
,aTheSession CHAR/* Сессия *//* Сессия */
,athe_Resource
 VARCHAR2/* Ресурс *//* Ресурс */
,aLogStructID
 VARCHAR2/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,aVERB
 VARCHAR2/* Действие *//* Действие */
,aLogInstanceID CHAR := null /* Идентификатор документа *//* Идентификатор документа */
); 
procedure SysLog_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure SysLog_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure SysLog_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure SysLog_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure SysLog_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure SysLog_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure SysLog_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZSystem;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZwp" BlockCode=" create or replace package MTZwp as

procedure MTZwp_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZwp_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZwp_propagate(acursession CHAR, aROWID CHAR); 

procedure ARMJournal_BRIEF  (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
 aBRIEF out varchar2
);
procedure ARMJournal_DELETE  (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
 ainstanceid char
); 
procedure ARMJournal_SAVE (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
aInstanceID CHAR 
,aTheJournal CHAR/* Журнал *//* Журнал */
); 
procedure ARMJournal_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ARMJournal_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ARMJournal_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ARMJournal_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ARMJournal_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ARMJournal_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ARMJournal_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ARMJRNLREP_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
 aBRIEF out varchar2
);
procedure ARMJRNLREP_DELETE  (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
 ainstanceid char
); 
procedure ARMJRNLREP_SAVE (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arepname
 VARCHAR2/* Название отчета *//* Название отчета */
,aTheReport CHAR/* Отчет *//* Отчет */
); 
procedure ARMJRNLREP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ARMJRNLREP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ARMJRNLREP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ARMJRNLREP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ARMJRNLREP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ARMJRNLREP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ARMJRNLREP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ARMJRNLRUN_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
 aBRIEF out varchar2
);
procedure ARMJRNLRUN_DELETE  (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
 ainstanceid char
); 
procedure ARMJRNLRUN_SAVE (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheExtention CHAR/* Расширение *//* Расширение */
); 
procedure ARMJRNLRUN_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ARMJRNLRUN_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ARMJRNLRUN_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ARMJRNLRUN_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ARMJRNLRUN_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ARMJRNLRUN_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ARMJRNLRUN_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ARMJRNLADD_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
 aBRIEF out varchar2
);
procedure ARMJRNLADD_DELETE  (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
 ainstanceid char
); 
procedure ARMJRNLADD_SAVE (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheExtention CHAR/* Расширение *//* Расширение */
); 
procedure ARMJRNLADD_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ARMJRNLADD_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ARMJRNLADD_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ARMJRNLADD_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ARMJRNLADD_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ARMJRNLADD_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ARMJRNLADD_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure EntryPoints_BRIEF  (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
 aBRIEF out varchar2
);
procedure EntryPoints_DELETE  (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
 ainstanceid char
); 
procedure EntryPoints_SAVE (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aAsToolbarItem
 NUMBER/* Включить в тулбар *//* Включить в тулбар */
,aActionType
 NUMBER/* Вариант действия *//* Вариант действия */
,aTheFilter CHAR := null /* Фильтр *//* Фильтр */
,aJournal CHAR := null /* Журнал *//* Журнал */
,aReport CHAR := null /* Отчет *//* Отчет */
,aDocument CHAR := null /* Документ *//* Документ */
,aMethod CHAR := null /* Метод *//* Метод */
,aIconFile
 VARCHAR2 := null /* Файл картинки *//* Файл картинки */
,aTheExtention CHAR := null /* Расширение *//* Расширение */
,aARM CHAR := null /* АРМ *//* АРМ */
,aTheComment VARCHAR2 := null /* Примечание *//* Примечание */
,aObjectType CHAR := null /* Тип документа *//* Тип документа */
,aJournalFixedQuery VARCHAR2 := null /* Ограничения к журналу *//* Ограничения к журналу */
,aAllowAdd
 NUMBER/* Разрешено добавление *//* Разрешено добавление */
,aAllowEdit
 NUMBER/* Разрешено редактирование *//* Разрешено редактирование */
,aAllowDel
 NUMBER/* Рарешено удаление *//* Рарешено удаление */
,aAllowFilter
 NUMBER/* Разрешен фильтр *//* Разрешен фильтр */
,aAllowPrint
 NUMBER/* Разрешена печать *//* Разрешена печать */
); 
procedure EntryPoints_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure EntryPoints_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure EntryPoints_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure EntryPoints_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure EntryPoints_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure EntryPoints_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure EntryPoints_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure EPFilterLink_BRIEF  (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
 aBRIEF out varchar2
);
procedure EPFilterLink_DELETE  (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
 ainstanceid char
); 
procedure EPFilterLink_SAVE (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aRowSource
 VARCHAR2/* Источник *//* Источник */
,aTheExpression VARCHAR2/* Выражение *//* Выражение */
,aFilterField
 VARCHAR2 := null /* Поле фильтра *//* Поле фильтра */
); 
procedure EPFilterLink_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure EPFilterLink_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure EPFilterLink_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure EPFilterLink_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure EPFilterLink_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure EPFilterLink_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure EPFilterLink_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure WorkPlace_BRIEF  (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
 aBRIEF out varchar2
);
procedure WorkPlace_DELETE  (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
 ainstanceid char
); 
procedure WorkPlace_SAVE (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aTheVersion
 VARCHAR2 := null /* Версия *//* Версия */
,aThePlatform
 NUMBER := null /* Платформа реализации *//* Платформа реализации */
,aTheComment VARCHAR2 := null /* Примечание *//* Примечание */
); 
procedure WorkPlace_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure WorkPlace_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure WorkPlace_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure WorkPlace_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure WorkPlace_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure WorkPlace_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure WorkPlace_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ARMTypes_BRIEF  (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
 aBRIEF out varchar2
);
procedure ARMTypes_DELETE  (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
 ainstanceid char
); 
procedure ARMTypes_SAVE (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
aInstanceID CHAR 
,aTheDocumentType CHAR/* Тип документа *//* Тип документа */
); 
procedure ARMTypes_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ARMTypes_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ARMTypes_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ARMTypes_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ARMTypes_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ARMTypes_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ARMTypes_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZwp;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ROLES" BlockCode=" create or replace package ROLES as

procedure ROLES_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure ROLES_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure ROLES_propagate(acursession CHAR, aROWID CHAR); 

procedure ROLES_OPERATIONS_BRIEF  (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_OPERATIONS_DELETE  (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
 ainstanceid char
); 
procedure ROLES_OPERATIONS_SAVE (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
aInstanceID CHAR 
,ainfo
 VARCHAR2/* Описание *//* Описание */
,aAllowAction
 NUMBER/* Разрешено *//* Разрешено */
,aName
 VARCHAR2/* Код *//* Код */
); 
procedure ROLES_OPERATIONS_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_OPERATIONS_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_OPERATIONS_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_OPERATIONS_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_OPERATIONS_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_OPERATIONS_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_OPERATIONS_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_WP_BRIEF  (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_WP_DELETE  (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
 ainstanceid char
); 
procedure ROLES_WP_SAVE (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
aInstanceID CHAR 
,aWP CHAR/* Приложение *//* Приложение */
); 
procedure ROLES_WP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_WP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_WP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_WP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_WP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_WP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_WP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_ACT_BRIEF  (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_ACT_DELETE  (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
 ainstanceid char
); 
procedure ROLES_ACT_SAVE (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aAccesible
 NUMBER := null /* Доступность *//* Доступность */
,aMenuName
 VARCHAR2/* Меню *//* Меню */
,amenuCode
 VARCHAR2/* Код пункта меню *//* Код пункта меню */
); 
procedure ROLES_ACT_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_ACT_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_ACT_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_ACT_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_ACT_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_ACT_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_ACT_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES2_MODULE_BRIEF  (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
 aBRIEF out varchar2
);
procedure ROLES2_MODULE_DELETE  (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
 ainstanceid char
); 
procedure ROLES2_MODULE_SAVE (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
aInstanceID CHAR 
,aGroupName
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aModuleAccessible
 NUMBER/* Разрешен *//* Разрешен */
,aCustomizeVisibility
 NUMBER/* Настраивать видимость *//* Настраивать видимость */
,aTheIcon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aname
 VARCHAR2/* Код модуля *//* Код модуля */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,aAllObjects
 NUMBER/* Вся фирма *//* Вся фирма */
,aColegsObject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,aSubStructObjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
); 
procedure ROLES2_MODULE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES2_MODULE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES2_MODULE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES2_MODULE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES2_MODULE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES2_MODULE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES2_MODULE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES2_MODREPORT_BRIEF  (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
 aBRIEF out varchar2
);
procedure ROLES2_MODREPORT_DELETE  (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
 ainstanceid char
); 
procedure ROLES2_MODREPORT_SAVE (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Код *//* Код */
,aAllowAction
 NUMBER/* Разрешен *//* Разрешен */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aTheIcon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aIsReport
 NUMBER/* Это отчет *//* Это отчет */
,aselectType
 NUMBER := null /* Вариант выбора *//* Вариант выбора */
); 
procedure ROLES2_MODREPORT_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES2_MODREPORT_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES2_MODREPORT_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES2_MODREPORT_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES2_MODREPORT_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES2_MODREPORT_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES2_MODREPORT_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_DOC_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_DOC_DELETE  (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
 ainstanceid char
); 
procedure ROLES_DOC_SAVE (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
aInstanceID CHAR 
,aThe_Document CHAR/* Тип документа *//* Тип документа */
,aThe_Denied
 NUMBER := null /* Запрещен *//* Запрещен */
,aAllowDeleteDoc
 NUMBER/* Разрешено удаление *//* Разрешено удаление */
); 
procedure ROLES_DOC_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_DOC_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_DOC_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_DOC_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_DOC_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_DOC_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_DOC_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_DOC_STATE_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_DOC_STATE_DELETE  (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
 ainstanceid char
); 
procedure ROLES_DOC_STATE_SAVE (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aThe_State CHAR := null /* Состояние *//* Состояние */
,aThe_Mode CHAR := null /* Режим *//* Режим */
,aAllowDelete
 NUMBER/* Можно удалять *//* Можно удалять */
,aStateChangeDisabled
 NUMBER/* Запрещена смена состояния *//* Запрещена смена состояния */
); 
procedure ROLES_DOC_STATE_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_DOC_STATE_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_DOC_STATE_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_DOC_STATE_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_DOC_STATE_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_DOC_STATE_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_DOC_STATE_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_REPORTS_BRIEF  (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_REPORTS_DELETE  (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
 ainstanceid char
); 
procedure ROLES_REPORTS_SAVE (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
aInstanceID CHAR 
,aThe_Report CHAR/* Отчёт *//* Отчёт */
); 
procedure ROLES_REPORTS_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_REPORTS_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_REPORTS_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_REPORTS_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_REPORTS_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_REPORTS_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_REPORTS_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_USER_BRIEF  (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_USER_DELETE  (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
 ainstanceid char
); 
procedure ROLES_USER_SAVE (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
aInstanceID CHAR 
,aTheUser CHAR/* Пользователь *//* Пользователь */
); 
procedure ROLES_USER_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_USER_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_USER_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_USER_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_USER_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_USER_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_USER_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_MAP_BRIEF  (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_MAP_DELETE  (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
 ainstanceid char
); 
procedure ROLES_MAP_SAVE (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
aInstanceID CHAR 
,aTheGroup CHAR/* Группа *//* Группа */
); 
procedure ROLES_MAP_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_MAP_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_MAP_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_MAP_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_MAP_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_MAP_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_MAP_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure ROLES_DEF_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
 aBRIEF out varchar2
);
procedure ROLES_DEF_DELETE  (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
 ainstanceid char
); 
procedure ROLES_DEF_SAVE (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aAllObjects
 NUMBER/* Вся фирма *//* Вся фирма */
,aColegsObject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,aSubStructObjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
); 
procedure ROLES_DEF_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure ROLES_DEF_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure ROLES_DEF_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure ROLES_DEF_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure ROLES_DEF_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure ROLES_DEF_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure ROLES_DEF_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end ROLES;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totask" BlockCode=" create or replace package totask as

procedure totask_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure totask_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure totask_propagate(acursession CHAR, aROWID CHAR); 
end totask;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZUsers" BlockCode=" create or replace package MTZUsers as

procedure MTZUsers_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZUsers_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZUsers_propagate(acursession CHAR, aROWID CHAR); 

procedure Users_BRIEF  (
 aCURSESSION CHAR,
 aUsersid CHAR,
 aBRIEF out varchar2
);
procedure Users_DELETE  (
 aCURSESSION CHAR,
 aUsersid CHAR,
 ainstanceid char
); 
procedure Users_SAVE (
 aCURSESSION CHAR,
 aUsersid CHAR,
aInstanceID CHAR 
,aFamily
 VARCHAR2/* Фамилия *//* Фамилия */
,aName
 VARCHAR2/* Имя *//* Имя */
,aSurName
 VARCHAR2/* Отчество *//* Отчество */
,aLogin
 VARCHAR2/* Имя для входа *//* Имя для входа */
,aPassword VARCHAR2 := null /* Пароль *//* Пароль */
,aDomaiName
 VARCHAR2 := null /* Доменное имя *//* Доменное имя */
,aEMail VARCHAR2 := null /* e-mail *//* e-mail */
,aPhone
 VARCHAR2 := null /* Телефон *//* Телефон */
,aLocalPhone
 VARCHAR2 := null /* Местный телефон *//* Местный телефон */
); 
procedure Users_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Users_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Users_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Users_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Users_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Users_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Users_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Groups_BRIEF  (
 aCURSESSION CHAR,
 aGroupsid CHAR,
 aBRIEF out varchar2
);
procedure Groups_DELETE  (
 aCURSESSION CHAR,
 aGroupsid CHAR,
 ainstanceid char
); 
procedure Groups_SAVE (
 aCURSESSION CHAR,
 aGroupsid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aADGroup
 VARCHAR2 := null /* Группа AD *//* Группа AD */
); 
procedure Groups_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Groups_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Groups_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Groups_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Groups_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Groups_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Groups_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure GroupUser_BRIEF  (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
 aBRIEF out varchar2
);
procedure GroupUser_DELETE  (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
 ainstanceid char
); 
procedure GroupUser_SAVE (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheUser CHAR/* Пользователь *//* Пользователь */
); 
procedure GroupUser_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure GroupUser_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure GroupUser_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure GroupUser_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure GroupUser_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure GroupUser_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure GroupUser_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZUsers;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tooper" BlockCode=" create or replace package tooper as

procedure tooper_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tooper_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tooper_propagate(acursession CHAR, aROWID CHAR); 
end tooper;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--STDNumerator" BlockCode=" create or replace package STDNumerator as

procedure STDNumerator_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure STDNumerator_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure STDNumerator_propagate(acursession CHAR, aROWID CHAR); 

procedure Num_zones_BRIEF  (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
 aBRIEF out varchar2
);
procedure Num_zones_DELETE  (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
 ainstanceid char
); 
procedure Num_zones_SAVE (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
aInstanceID CHAR 
,aZoneMask
 VARCHAR2/* Маска зоны *//* Маска зоны */
); 
procedure Num_zones_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Num_zones_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Num_zones_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Num_zones_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Num_zones_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Num_zones_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Num_zones_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Num_Values_BRIEF  (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
 aBRIEF out varchar2
);
procedure Num_Values_DELETE  (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
 ainstanceid char
); 
procedure Num_Values_SAVE (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_Value
 NUMBER/* Значение *//* Значение */
,aOwnerPartName
 VARCHAR2 := null /* Раздел *//* Раздел */
,aOwnerRowID CHAR := null /* Идентификатор строки *//* Идентификатор строки */
); 
procedure Num_Values_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Num_Values_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Num_Values_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Num_Values_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Num_Values_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Num_Values_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Num_Values_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Num_head_BRIEF  (
 aCURSESSION CHAR,
 aNum_headid CHAR,
 aBRIEF out varchar2
);
procedure Num_head_DELETE  (
 aCURSESSION CHAR,
 aNum_headid CHAR,
 ainstanceid char
); 
procedure Num_head_SAVE (
 aCURSESSION CHAR,
 aNum_headid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aShema
 NUMBER/* Схема нумерации *//* Схема нумерации */
); 
procedure Num_head_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Num_head_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Num_head_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Num_head_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Num_head_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Num_head_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Num_head_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end STDNumerator;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZExt" BlockCode=" create or replace package MTZExt as

procedure MTZExt_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZExt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZExt_propagate(acursession CHAR, aROWID CHAR); 

procedure MTZExt_def_BRIEF  (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
 aBRIEF out varchar2
);
procedure MTZExt_def_DELETE  (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
 ainstanceid char
); 
procedure MTZExt_def_SAVE (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aExtType
 NUMBER/* Тип расширения *//* Тип расширения */
,aTheDescription VARCHAR2 := null /* Описание *//* Описание */
); 
procedure MTZExt_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure MTZExt_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure MTZExt_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure MTZExt_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure MTZExt_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure MTZExt_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure MTZExt_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure MTZExtRel_BRIEF  (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
 aBRIEF out varchar2
);
procedure MTZExtRel_DELETE  (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
 ainstanceid char
); 
procedure MTZExtRel_SAVE (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
aInstanceID CHAR 
,aThePlatform
 NUMBER/* Реализация *//* Реализация */
,aTheClassName
 VARCHAR2/* Название класса *//* Название класса */
,aTheLibraryName
 VARCHAR2 := null /* Название библиотеки *//* Название библиотеки */
); 
procedure MTZExtRel_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure MTZExtRel_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure MTZExtRel_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure MTZExtRel_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure MTZExtRel_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure MTZExtRel_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure MTZExtRel_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZExt;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toact" BlockCode=" create or replace package toact as

procedure toact_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure toact_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure toact_propagate(acursession CHAR, aROWID CHAR); 
end toact;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZ2JOB" BlockCode=" create or replace package MTZ2JOB as

procedure MTZ2JOB_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZ2JOB_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZ2JOB_propagate(acursession CHAR, aROWID CHAR); 

procedure MTZ2JOB_DEF_BRIEF  (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
 aBRIEF out varchar2
);
procedure MTZ2JOB_DEF_DELETE  (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
 ainstanceid char
); 
procedure MTZ2JOB_DEF_SAVE (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
aInstanceID CHAR 
,aEventDate
 DATE/* Отложено до *//* Отложено до */
,aEvenType
 VARCHAR2/* Тип события *//* Тип события */
,aThruObject CHAR/* Объект - причина события *//* Объект - причина события */
,aThruState CHAR := null /* Состояние - причина *//* Состояние - причина */
,aNextState CHAR := null /* Состояние после обработки *//* Состояние после обработки */
,aProcessDate
 DATE := null /* Момент обработки *//* Момент обработки */
,aProcessed
 NUMBER/* Обработан *//* Обработан */
); 
procedure MTZ2JOB_DEF_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure MTZ2JOB_DEF_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure MTZ2JOB_DEF_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure MTZ2JOB_DEF_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure MTZ2JOB_DEF_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure MTZ2JOB_DEF_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure MTZ2JOB_DEF_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZ2JOB;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZFltr" BlockCode=" create or replace package MTZFltr as

procedure MTZFltr_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZFltr_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZFltr_propagate(acursession CHAR, aROWID CHAR); 

procedure FilterFieldGroup_BRIEF  (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
 aBRIEF out varchar2
);
procedure FilterFieldGroup_DELETE  (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
 ainstanceid char
); 
procedure FilterFieldGroup_SAVE (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aAllowIgnore
 NUMBER/* Можно отключать *//* Можно отключать */
); 
procedure FilterFieldGroup_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FilterFieldGroup_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FilterFieldGroup_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FilterFieldGroup_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FilterFieldGroup_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FilterFieldGroup_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FilterFieldGroup_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure FileterField_BRIEF  (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
 aBRIEF out varchar2
);
procedure FileterField_DELETE  (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
 ainstanceid char
); 
procedure FileterField_SAVE (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aFieldSize
 NUMBER := null /* Размер *//* Размер */
,aRefType
 NUMBER := null /* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,aRefToPart CHAR := null /* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,aValueArray
 NUMBER/* Массив значений *//* Массив значений */
); 
procedure FileterField_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure FileterField_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure FileterField_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure FileterField_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure FileterField_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure FileterField_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure FileterField_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Filters_BRIEF  (
 aCURSESSION CHAR,
 aFiltersid CHAR,
 aBRIEF out varchar2
);
procedure Filters_DELETE  (
 aCURSESSION CHAR,
 aFiltersid CHAR,
 ainstanceid char
); 
procedure Filters_SAVE (
 aCURSESSION CHAR,
 aFiltersid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure Filters_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Filters_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Filters_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Filters_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Filters_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Filters_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Filters_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZFltr;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZRprt" BlockCode=" create or replace package MTZRprt as

procedure MTZRprt_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure MTZRprt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure MTZRprt_propagate(acursession CHAR, aROWID CHAR); 

procedure RPTStruct_BRIEF  (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
 aBRIEF out varchar2
);
procedure RPTStruct_DELETE  (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
 ainstanceid char
); 
procedure RPTStruct_SAVE (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
); 
procedure RPTStruct_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure RPTStruct_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure RPTStruct_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure RPTStruct_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure RPTStruct_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure RPTStruct_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure RPTStruct_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure RPTFields_BRIEF  (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
 aBRIEF out varchar2
);
procedure RPTFields_DELETE  (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
 ainstanceid char
); 
procedure RPTFields_SAVE (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aFieldSize
 NUMBER := null /* Размер *//* Размер */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
); 
procedure RPTFields_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure RPTFields_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure RPTFields_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure RPTFields_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure RPTFields_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure RPTFields_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure RPTFields_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure RPTFormula_BRIEF  (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
 aBRIEF out varchar2
);
procedure RPTFormula_DELETE  (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
 ainstanceid char
); 
procedure RPTFormula_SAVE (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCode VARCHAR2 := null /* Выражение *//* Выражение */
,aPlatform CHAR := null /* Платформа *//* Платформа */
); 
procedure RPTFormula_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure RPTFormula_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure RPTFormula_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure RPTFormula_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure RPTFormula_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure RPTFormula_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure RPTFormula_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure Reports_BRIEF  (
 aCURSESSION CHAR,
 aReportsid CHAR,
 aBRIEF out varchar2
);
procedure Reports_DELETE  (
 aCURSESSION CHAR,
 aReportsid CHAR,
 ainstanceid char
); 
procedure Reports_SAVE (
 aCURSESSION CHAR,
 aReportsid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aReportFile VARCHAR2 := null /* Файл отчета */
,aReportFile_EXT varchar2 /* Файл отчета */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aPrepareMethod CHAR := null /* Метод для формирования *//* Метод для формирования */
,aReportType
 NUMBER/* Тип отчета *//* Тип отчета */
,aTheReportExt CHAR := null /* Расширение для создания отчета *//* Расширение для создания отчета */
,aReportView
 VARCHAR2 := null /* Базовый запрос *//* Базовый запрос */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure Reports_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure Reports_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure Reports_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure Reports_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure Reports_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure Reports_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure Reports_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end MTZRprt;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Methods" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Custom" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
/* GetFreeNumber  Свободный номер из нумератора*/
create or replace procedure GetFreeNumber

(athe_Zone VARCHAR2/* Зона */

,aNumeratorID CHAR/* нумератор */

,anum out  NUMBER/* номер */

)
 as 
an integer;
aid1 char(38);
aid2 char(38);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
end;

/
/* AutoCloseSession  Автоматическое закрытие протухщих сессий*/
create or replace procedure AutoCloseSession

 as 
asid char(38);
begin
declare cursor closer is
select the_sessionid id from the_session where lastaccess &lt; (sysdate()-0.008) and closed =0;
closer_rec  closer%ROWTYPE;
begin
 --open closer;
 for closer_rec in closer loop
   Logout (closer_rec.id);
 end loop;
close closer;
end;
end;



/
/* GetNewNumber  Следующий номер из нумератора*/
create or replace procedure GetNewNumber

(anum out  NUMBER/* номер */

,athe_Zone VARCHAR2/* Зона */

,aNumeratorID CHAR/* нумератор */

)
 as 

/**********************************
declare @n integer
declare @id1 uniqueidentifier
declare @id2 uniqueidentifier
begin
if not exists(select 1 from instance where instanceid=@NumeratorID)
insert into instance(instanceid,name,objtype) values(@NumeratorID,'Numerator','STDNumerator')

if not exists(select 1 from num_zones where zonemask=@zone and instanceid=@NumeratorID)
  begin
    set @num =1
    set @ID1 = newid()
    set @ID2 = newid()
    insert into num_zones(num_zonesid,instanceid, zonemask) values(@id1,@NumeratorID, @zone)
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @num)
    return
  end
else
  begin
  select @ID1=num_zonesid from num_zones where zonemask=@zone and instanceid=@NumeratorID
  if not exists(select 1 from num_values where parentStructRowID=@ID1 )
    begin
      set @num =1
      set @ID2 = newid()
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @num)
      return
    end
  else
    begin
      select @n = max(the_value)+1 from num_values where parentStructRowID=@ID1
      set @ID2 = newid()
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @n)
      set @num = @n
    end
  end
end
************************************************************/

an integer;
aid1 char(38);
aid2 char(38);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
end;

/
/* EraseNumber  Удалить номер из нумератора*/
create or replace procedure EraseNumber

(aNumeratorID CHAR/* нумератор */

,athe_Zone VARCHAR2/* Зона */

,anum NUMBER/* номер */

)
 as 
aid1 char(38);
existsCnt integer;
begin
select count(*) into existsCnt  from instance where instanceid=aNumeratorID;
if existsCnt=0 then
return;
end if;
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    return ;
else
  select num_zonesid into aID1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt  from num_values where parentStructRowID=aID1 ;
  if  existsCnt=0 then
      return;
  else
     delete from num_values where parentStructRowID=aID1 and the_value=anum;
  end if;
end if;
end;

/
/* SessionCheckPoint  Автоматическое закрытие &quot;Подвисших&quot; сессий*/
create or replace procedure SessionCheckPoint

(aCURSESSION CHAR/* Текущая сессия */

)
 as 
cursor s is select the_sessionid id from the_session
where lastAccess &lt;sysdate()-1;
s_rec s%rowtype;
begin
--open s;
for s_rec in s loop
  logout(s_rec.id);
End loop;
Close s;
end;





/
/* RowsToInstances  Получить массив объектов, которые содержат строки*/
create or replace procedure RowsToInstances

(aRowQueryID CHAR/* Идентификатор массива строк */

,aOutputQueryID CHAR/* идентификатор масива результатов */

,athe_Table VARCHAR2/* Таблица */

,aCURSESSION CHAR/* Сессия пльзователя */

)
 as 
aInstanceID char(38); 
existsCnt integer; 
 cursor QR is select result ID from queryresult where queryresultid =arowqueryID; 
QR_REC QR%ROWTYPE; 
begin 
--open qr; 
for  qr_ReC in QR loop 
          RowToInstance (athe_InstanceID=&gt;aInstanceID , athe_RowID =&gt; QR_REC.ID, athe_Table=&gt;athe_TABLE, aCURSESSION=&gt;aCURSESSION); 
          if not ainstanceid is null then
          select count(*) into existsCnt from queryresult where QUERYRESULTID = aOutputQueryID and RESULT=aInstanceID; 
	if existsCnt =0 then 
	  insert into queryresult (queryresultid,result) values(aoutputqueryid,ainstanceid); 
	end if; 
          end if;
end loop; 
--close QR; 
end; 

/
/* CheckVerbRight  Проверка прав на действие*/
create or replace procedure CheckVerbRight

(aCURSESSION CHAR/* Сессия */

,athe_resource CHAR/* идентификатор стиля прав */

,averb VARCHAR2/* Действие */

,aaccess out  NUMBER/* Разрешение */

)
 as 
apr integer;
aallow integer;
begin
if athe_resource is null 
then
	aaccess :=1;
	return;
end if;

declare  cursor tst is
SELECT     
  MTZSEC_RIGHT.Allow,  
  MTZSEC_RIGHT.Piority
FROM MTZSEC_RIGHT JOIN
     GroupUser ON MTZSEC_RIGHT.TheGroup = GroupUser.ParentStructRowID  JOIN
     the_Session ON GroupUser.TheUser = the_Session.Usersid
where the_Session.the_Sessionid = acursession and the_Session.closed=0 
and MTZSEC_RIGHT.InstanceID =athe_resource
and MTZSEC_RIGHT.ProtectedItem =averb
order by MTZSEC_RIGHT.Piority;
tst_rec tst%ROWTYPE;
begin
--open tst;

for tst_rec in tst loop
	aaccess :=tst_rec.allow;
	CLOSE tst;
	return;
END loop;

aaccess :=0;
CLOSE tst;
end;
end;

/
/* MTZLogin  Открытие сессии*/
create or replace procedure MTZLogin

(aTHE_SESSION out  CHAR/* Идентификатор новой сессии */

,aPWD VARCHAR2/* Пароль */

,aUSR VARCHAR2/* Имя пользователя */

)
 as 
aID char(38); 
aUSERSID char(38); 
asysid char(38); 
existsCnt integer;  
begin 
asysid := null; 
select instanceid into asysid from instance where objtype = 'MTZSYSTEM'; 
athe_session:=null  ; 
if aPWD is null 
then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 
  then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1 
  then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
    End if; 
  end if; 
end if; -- password is null 
end; 


/
/* AdminUnlockAll  Административная функция для 
разблокировки документов*/
create or replace procedure AdminUnlockAll

 as 
begin
update instance set LockUserID = null, LockSessionID=null 
end;

/
/* RowToInstance  Поиск объекта для некоторой строки*/
create or replace procedure RowToInstance

(athe_InstanceID out  CHAR/* Object */

,athe_RowID CHAR/* Row */

,athe_Table VARCHAR2/* Part Table Name */

,aCURSESSION CHAR/* Session */

)
 as 
aparent varchar2(255);
aprev varchar2(255);
atmpID  char(38);
atmpRowID  char(38);
astr varchar2(4000);
existsCnt integer;
begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
 -- checking session  --
if  existsCnt =0
  then
    raise_application_error(-20000,'Session expired');

    return;
  end if;

aparent :=athe_table;
atmpID := athe_ROWID;

&lt;&lt;again&gt;&gt;

aprev := aparent;
begin 

select thevalue into aparent from sysoptions where optiontype = 'PARENT' and  name=aprev;
exception
when others then
aparent := null;
end;
if aparent is null then
    astr := 'select InstanceID from ' || aprev || ' where ' || aprev || 'id=:1';
    begin
        execute immediate astr into atmpRowID using atmpid;
        athe_InstanceID:=atmpRowID	    	;
    exception when others then
        athe_InstanceID:=null;
    end;
    
else
    astr :='select ParentStructRowID from ' || aprev || ' where ' || aprev || 'id=:1';
    begin
        execute immediate astr into atmpRowID using atmpid;
        atmpID := atmpROWID;
            exception when others then
              atmpID := null;
    end;
    goto again;
end if;
end
;

/
/* SessionTouch  Поддержание сессии*/
create or replace procedure SessionTouch

(aCURSESSION CHAR/* Идентификатор сессии */

)
 as 
begin
update the_session set lastaccess=sysdate() where the_sessionid=acursession and closed=0;
end;


/
/* GetServerTime  текущее время сервера*/
create or replace procedure GetServerTime

(aServerTime out  DATE/* Текущее время */

)
 as 
begin
select sysdate() into aServerTime from sys.dual;
end;

/
/* TestNumber  Проверить наличие номера в нумераторе*/
create or replace procedure TestNumber

(athe_Zone VARCHAR2/* Зона */

,aresult out  NUMBER/* результат */

,aNumeratorID CHAR/* нумератор */

,anum NUMBER/* номер */

)
 as 
aid1 char(38); 
existsCnt  integer; 
begin 
aresult:=0; 
 
select count(*) into existsCnt from instance where instanceid=aNumeratorID; 
if existsCnt =0 then 
  return; 
end if; 
 
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
 
if existsCnt=0 then 
    return; 
else 
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
  select count(*) into existsCnt from num_values where parentStructRowID=aID1 and the_value=anum; 
 
  if existsCnt=0 then 
      return; 
  else 
     aresult:=1; 
  end if; 
end if; 
end; 

/
/* Logout  Завершение сессии*/
create or replace procedure Logout

(aCURSESSION CHAR/* Идентификатор сессии */

)
 as 
existsCnt integer;

begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt &gt;0 then
   begin
    declare cursor dl  is
    select 'update '|| thevalue || ' set LockSessionID =null where LockSessionID=:1' str from sysoptions where optiontype='MAP' and theValue not like 'V[_]%';
    dl_rec dl%rowtype;
    begin
    --open dl;
    for dl_rec in dl loop
	      execute immediate dl_rec.str using acursession;
    end loop;
    --close dl;
    update INSTANCE set LockSessionID =null where LockSessionID=acursession ;
    update the_session set closed=1,closedAt=sysdate(), changeStamp=sysdate() where     the_sessionid=acursession;
    end;
  end;  
 End if;
end;


/
/* Login  Открытие сессии*/
create or replace procedure Login

(aTHE_SESSION out  CHAR/* Идентификатор новой сессии */

,aPWD VARCHAR2/* Пароль */

,aUSR VARCHAR2/* Имя пользователя */

)
 as 
aID char(38); 
aUSERSID char(38); 
asysid char(38); 
existsCnt integer;  
begin 
asysid := null; 
select instanceid into asysid from instance where objtype = 'MTZSYSTEM'; 
athe_session:=null  ; 
if aPWD is null 
then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 
  then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1 
  then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     select  mtz.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
    End if; 
  end if; 
end if; -- password is null 
end; 


/
/* AdminUnlock  Административная функция для 
разблокировки документов*/
create or replace procedure AdminUnlock

(athe_ID CHAR/* Идентификатор документа */

)
 as 
begin
update instance set LockUserID = null, LockSessionID=null where instanceID=athe_ID;
end;

/
/* SessionVerify  Проверка состояния сессии*/
create or replace procedure SessionVerify

(aCURSESSION CHAR/* Сессия */

,aOK out  NUMBER/* Активна */

)
 as 
existsCnt integer;
begin
select Count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;

if  existsCnt&gt;0 then
aOK:=1;
else
aOK :=0;
end if;
end;

/
/*Login (Login)*/
create or replace procedure Login
  
(aTHE_SESSION out  CHAR/* Идентификатор новой сессии */  
  
,aPWD VARCHAR2/* Пароль */  
  
,aUSR VARCHAR2/* Имя пользователя */  
  
)  
 as   
  
aID char(38);   
aUSERSID char(38);   
asysid char(38);   
SysLogid char(38); 
existsCnt integer;   
begin   
asysid := null;   
select instanceid into asysid from instance where objtype = 'MTZSYSTEM';   
athe_session:=null  ;   
if aPWD is null   
then   
 select count(*) into existsCnt from users where Login=ausr and Password is null;   
  if existsCNt =1   
  then   
    select USERSID into ausersid from users where Login=ausr and Password is null;   
    select  mtz.newid() into aID from sys.dual;   
       if asysid is null then   
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt)   
        values(aid,sysdate,ausersid,0,sysdate);   
       else   
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt)   
        values(asysid,aid,sysdate,ausersid,0,sysdate);   
       end if;   
     athe_session:=aid;   
      
     SysLogid:=MTZ.NEWID(); 
     MTZSystem.SysLog_SAVE( aTheSession=&gt;aid,aCURSESSION=&gt;aid, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGIN_SUCCESS', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null); 
  else 
     SysLogid:=MTZ.NEWID(); 
     MTZSystem.SysLog_SAVE( aTheSession=&gt;aid,aCURSESSION=&gt;aid, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGIN_FAILED', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null); 
  End if;   
else   
   
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD;   
  if existsCNt =1   
  then   
   select USERSID into ausersid from users where Login=ausr and Password =aPWD;   
   select  mtz.newid() into aID from sys.dual;   
       if asysid is null then   
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt)   
        values(aid,sysdate,ausersid,0,sysdate);   
       else   
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt)   
        values(asysid,aid,sysdate,ausersid,0,sysdate);   
       end if;   
     athe_session:=aid;   
      
     SysLogid:=MTZ.NEWID(); 
     MTZSystem.SysLog_SAVE( aTheSession=&gt;aid,aCURSESSION=&gt;aid, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGIN_SUCCESS', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null);  
      
  else   
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED';   
    if existsCNt =1   
    then   
     select USERSID into ausersid from users where DomaiName =ausr ;   
     select  mtz.newid() into aID from sys.dual;   
       if asysid is null then   
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt)   
        values(aid,sysdate,ausersid,0,sysdate);   
   
       else   
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt)   
        values(asysid,aid,sysdate,ausersid,0,sysdate);   
       end if;   
     athe_session:=aid;   
      
     SysLogid:=MTZ.NEWID(); 
     MTZSystem.SysLog_SAVE( aTheSession=&gt;aid,aCURSESSION=&gt;aid, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGIN_SUCCESS', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null); 
    else 
     SysLogid:=MTZ.NEWID(); 
     MTZSystem.SysLog_SAVE( aTheSession=&gt;aid,aCURSESSION=&gt;aid, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGIN_FAILED', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null); 
    End if;   
  end if;   
end if; -- password is null   
end;   
  
/
/*NEWID (NEWID)*/
create or replace function NEWID return varchar2 as
  Result varchar2(40);
  lguid raw(128);
  sTempString varchar2(40);
begin
  
  
  
  select sys_guid() into lguid from dual;
  
  sTempString:=to_char(lguid);
 
  Result:='{' || 
              Substr(sTempString, 1, 8) 
              || '-' ||
              Substr(sTempString, 9, 4) 
              || '-' ||
              Substr(sTempString, 13, 4) 
              || '-' ||
              Substr(sTempString, 17, 4) 
              || '-' ||
              Substr(sTempString, 21, 12) 
              || '}';
  return(Result);
end NEWID;
/
/*AutoCloseSession-job-AdminUnlockAll (JOB_FIX)*/
create or replace procedure AutoCloseSession
 
 as  
 
asid char(38); 
begin 
declare cursor closer is 
select the_sessionid id from the_session where lastaccess &lt; (sysdate()-0.008) and closed =0; 
closer_rec  closer%ROWTYPE; 
begin 
 --open closer; 
 for closer_rec in closer loop 
   Logout (closer_rec.id); 
 end loop; 
--close closer; 
end; 
end; 
/
declare
num_new_job_no number;
begin
select JOB into num_new_job_no from USER_JOBS where What='begin MTZ.AutoCloseSession; end;';
DBMS_JOB.REMOVE(num_new_job_no);
commit;
end;
/
declare
num_new_job_no number;
begin
sys.dbms_job.submit(job =&gt; num_new_job_no,
what =&gt; 'begin MTZ.AutoCloseSession; end;',
next_date =&gt; sysdate + (1/1000),
interval =&gt; 'sysdate+30/1440');
commit;
exception
when others then
dbms_output.put_line(sqlcode||sqlerrm);
end;
/
create or replace procedure AdminUnlockAll
 
 as  
 
begin 
update instance set LockUserID = null, LockSessionID=null  ;
end; 
/
/
/*V_LOG (V_LOG)*/
create or replace view V_LOG as 

select syslog.syslogid

,syslog.changestamp

,the_session.StartAt

,the_session.Closed

,syslog.the_Resource

,syslog.LogStructID

,syslog.LogInstanceID

,syslog.VERB

,NVL(users.login,the_Resource || '|' || NVL(logstructid,'null')) login

,users.Family

,users.Name

,users.Surname

,instance.name instname

,instance.objtype

,part.caption

,objecttype.the_comment

 from  syslog

left join the_session on syslog.thesession=the_session.the_sessionid

left join users on the_session.usersid=users.usersid

left join instance on syslog.loginstanceid = instance.instanceid

left join part on syslog.logstructid = part.name

left join objecttype on instance.objtype =objecttype.name
/
/*Logout (Logout)*/
create or replace procedure Logout
  
(aCURSESSION CHAR/**/  
  
)  
 as   
  
existsCnt integer;  
SysLogid char(38);  
asysid char(38);  
ausr char(38); 
begin  
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;  
if existsCnt &gt;0 then  
   begin  
    select usersid into ausr from the_session where the_sessionid=acursession;
    select login into ausr from users where usersid=ausr;
    declare cursor dl  is  
    select 'update '|| thevalue || ' set LockSessionID =null where LockSessionID=:1' str from sysoptions where optiontype='MAP' and theValue not like 'V[_]%';  
    dl_rec dl%rowtype;  
    begin  
    --open dl;  
    for dl_rec in dl loop  
	      execute immediate dl_rec.str using acursession;  
    end loop;  
    --close dl;  

    select instanceid into asysid from instance where objtype = 'MTZSYSTEM'; 
    
    SysLogid:=MTZ.NEWID(); 
    MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysid, aSysLogid=&gt;SysLogid, aLogStructID =&gt;ausr, 
     aVERB=&gt;'LOGOUT', aThe_Resource=&gt;ausr,aLogInstanceID=&gt;null); 


    update INSTANCE set LockSessionID =null where LockSessionID=acursession ;  
    update the_session set closed=1,closedAt=sysdate(), changeStamp=sysdate() where     the_sessionid=acursession;  
 
    end;  
  end;    
 End if;  
end;  
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package body Func as

  function instance_BRIEF_F  (
 ainstanceid CHAR
)return varchar2 as  
 aBRIEF varchar2(4000);
 atmpCnt numeric;
 begin
if ainstanceid is null then aBRIEF:=''; return (aBRIEF); end if;
 -- Brief body --
select count(*) into aTmpCnt from instance where instanceID=ainstanceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select aBRIEF
  ||  nvl(Name,' ')||'; ' into aBrief
  from instance where  instanceID = ainstanceID;
else 
  aBRIEF:= 'неверный идентификатор';
End if;
 aBRIEF:=substr(aBRIEF,1,255);
  return (aBRIEF);
End;

function GENPACKAGE_BRIEF_F  (
 aGENPACKAGEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGENPACKAGEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from GENPACKAGE  where  GENPACKAGEID = aGENPACKAGEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function GENERATOR_TARGET_BRIEF_F  (
 aGENERATOR_TARGETid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGENERATOR_TARGETid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from GENERATOR_TARGET  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
  select  aBRIEF ||
  Decode( TargetType
 ,0
 ,'СУБД'
 ,3
 ,'Документация'
 ,1
 ,'МОДЕЛЬ'
 ,2
 ,'Приложение'
 ,4
 ,'АРМ'
,'.') into aBrief from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function GENREFERENCE_BRIEF_F  (
 aGENREFERENCEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGENREFERENCEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from GENREFERENCE  where  GENREFERENCEID = aGENREFERENCEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function GENMANUALCODE_BRIEF_F  (
 aGENMANUALCODEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGENMANUALCODEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from GENMANUALCODE  where  GENMANUALCODEID = aGENMANUALCODEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function GENCONTROLS_BRIEF_F  (
 aGENCONTROLSid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGENCONTROLSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(ControlProgID),' ') ||'; '
  into aBrief from GENCONTROLS  where  GENCONTROLSID = aGENCONTROLSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function LocalizeInfo_BRIEF_F  (
 aLocalizeInfoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aLocalizeInfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(LangFull),' ') ||'; '
  into aBrief from LocalizeInfo  where  LocalizeInfoID = aLocalizeInfoID; 
 select aBRIEF 
  ||  nvl(to_char(LangShort),' ') ||'; '
  into aBrief from LocalizeInfo  where  LocalizeInfoID = aLocalizeInfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDTYPE_BRIEF_F  (
 aFIELDTYPEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from FIELDTYPE  where  FIELDTYPEID = aFIELDTYPEID; 
  select  aBRIEF ||
  Decode( TypeStyle
 ,4
 ,'Ссылка'
 ,1
 ,'Выражение'
 ,5
 ,'Элемент оформления'
 ,3
 ,'Интервал'
 ,2
 ,'Перечисление'
 ,0
 ,'Скалярный тип'
,'.') into aBrief from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ENUMITEM_BRIEF_F  (
 aENUMITEMid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aENUMITEMid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ENUMITEM  where  ENUMITEMID = aENUMITEMID; 
 select aBRIEF 
  ||  nvl(to_char(NameValue),' ') ||'; '
  into aBrief from ENUMITEM  where  ENUMITEMID = aENUMITEMID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDTYPEMAP_BRIEF_F  (
 aFIELDTYPEMAPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDTYPEMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDTYPEMAP  where  FIELDTYPEMAPID = aFIELDTYPEMAPID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(StoageType),' ') ||'; '
  into aBrief from FIELDTYPEMAP  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function SHAREDMETHOD_BRIEF_F  (
 aSHAREDMETHODid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aSHAREDMETHODid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from SHAREDMETHOD  where  SHAREDMETHODID = aSHAREDMETHODID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function SCRIPT_BRIEF_F  (
 aSCRIPTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aSCRIPTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from SCRIPT  where  SCRIPTID = aSCRIPTID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PARAMETERS_BRIEF_F  (
 aPARAMETERSid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARAMETERSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from PARAMETERS  where  PARAMETERSID = aPARAMETERSID; 
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from PARAMETERS  where  PARAMETERSID = aPARAMETERSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function OBJECTTYPE_BRIEF_F  (
 aOBJECTTYPEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aOBJECTTYPEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Package
 into atmpID  from OBJECTTYPE  where  OBJECTTYPEID = aOBJECTTYPEID ;
 atmpBrief := func.MTZAPP_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(the_Comment),' ') ||'; '
  into aBrief from OBJECTTYPE  where  OBJECTTYPEID = aOBJECTTYPEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function OBJSTATUS_BRIEF_F  (
 aOBJSTATUSid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aOBJSTATUSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from OBJSTATUS  where  OBJSTATUSID = aOBJSTATUSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function NEXTSTATE_BRIEF_F  (
 aNEXTSTATEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aNEXTSTATEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheState
 into atmpID  from NEXTSTATE  where  NEXTSTATEID = aNEXTSTATEID ;
 atmpBrief := func.OBJSTATUS_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function OBJECTMODE_BRIEF_F  (
 aOBJECTMODEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aOBJECTMODEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from OBJECTMODE  where  OBJECTMODEID = aOBJECTMODEID; 
  select  aBRIEF ||
  Decode( DefaultMode
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function STRUCTRESTRICTION_BRIEF_F  (
 aSTRUCTRESTRICTIONid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aSTRUCTRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Struct
 into atmpID  from STRUCTRESTRICTION  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID ;
 atmpBrief := func.PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( AllowRead
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  Decode( AllowAdd
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  Decode( AllowEdit
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
  select  aBRIEF ||
  Decode( AllowDelete
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function METHODRESTRICTION_BRIEF_F  (
 aMETHODRESTRICTIONid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aMETHODRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Method
 into atmpID  from METHODRESTRICTION  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID ;
 atmpBrief := func.SHAREDMETHOD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( IsRestricted
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDRESTRICTION_BRIEF_F  (
 aFIELDRESTRICTIONid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDRESTRICTIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select ThePart
 into atmpID  from FIELDRESTRICTION  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID ;
 atmpBrief := func.PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select TheField
 into atmpID  from FIELDRESTRICTION  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID ;
 atmpBrief := func.FIELD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( AllowRead
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
  select  aBRIEF ||
  Decode( AllowModify
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function TYPEMENU_BRIEF_F  (
 aTYPEMENUid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aTYPEMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from TYPEMENU  where  TYPEMENUID = aTYPEMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function INSTANCEVALIDATOR_BRIEF_F  (
 aINSTANCEVALIDATORid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aINSTANCEVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from INSTANCEVALIDATOR  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PART_BRIEF_F  (
 aPARTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PART where PARTID=aPARTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from PART  where  PARTID = aPARTID; 
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from PART  where  PARTID = aPARTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PARTMENU_BRIEF_F  (
 aPARTMENUid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARTMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from PARTMENU  where  PARTMENUID = aPARTMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PARTPARAMMAP_BRIEF_F  (
 aPARTPARAMMAPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARTPARAMMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(FieldName),' ') ||'; '
  into aBrief from PARTPARAMMAP  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 select aBRIEF 
  ||  nvl(to_char(ParamName),' ') ||'; '
  into aBrief from PARTPARAMMAP  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PARTVIEW_BRIEF_F  (
 aPARTVIEWid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARTVIEWid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from PARTVIEW  where  PARTVIEWID = aPARTVIEWID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ViewColumn_BRIEF_F  (
 aViewColumnid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aViewColumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ViewColumn where ViewColumnID=aViewColumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ViewColumn  where  ViewColumnID = aViewColumnID; 
select FromPart
 into atmpID  from ViewColumn  where  ViewColumnID = aViewColumnID ;
 atmpBrief := func.PART_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( Aggregation
 ,3
 ,'SUM'
 ,1
 ,'AVG'
 ,6
 ,'CUSTOM'
 ,0
 ,'none'
 ,2
 ,'COUNT'
 ,5
 ,'MAX'
 ,4
 ,'MIN'
,'.') into aBrief from ViewColumn where ViewColumnID=aViewColumnID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function PARTVIEW_LNK_BRIEF_F  (
 aPARTVIEW_LNKid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aPARTVIEW_LNKid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheView
 into atmpID  from PARTVIEW_LNK  where  PARTVIEW_LNKID = aPARTVIEW_LNKID ;
 atmpBrief := func.PARTVIEW_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function VALIDATOR_BRIEF_F  (
 aVALIDATORid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from VALIDATOR  where  VALIDATORID = aVALIDATORID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function UNIQUECONSTRAINT_BRIEF_F  (
 aUNIQUECONSTRAINTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aUNIQUECONSTRAINTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from UNIQUECONSTRAINT  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
  select  aBRIEF ||
  Decode( PerParent
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function CONSTRAINTFIELD_BRIEF_F  (
 aCONSTRAINTFIELDid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aCONSTRAINTFIELDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheField
 into atmpID  from CONSTRAINTFIELD  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID ;
 atmpBrief := func.FIELD_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ExtenderInterface_BRIEF_F  (
 aExtenderInterfaceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aExtenderInterfaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(TheName),' ') ||'; '
  into aBrief from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID; 
select TargetPlatform
 into atmpID  from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(TheObject),' ') ||'; '
  into aBrief from ExtenderInterface  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELD_BRIEF_F  (
 aFIELDid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELD where FIELDID=aFIELDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from FIELD  where  FIELDID = aFIELDID; 
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from FIELD  where  FIELDID = aFIELDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FldExtenders_BRIEF_F  (
 aFldExtendersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFldExtendersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(TheName),' ') ||'; '
  into aBrief from FldExtenders  where  FldExtendersID = aFldExtendersID; 
select TargetPlatform
 into atmpID  from FldExtenders  where  FldExtendersID = aFldExtendersID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(TheObject),' ') ||'; '
  into aBrief from FldExtenders  where  FldExtendersID = aFldExtendersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDSRCDEF_BRIEF_F  (
 aFIELDSRCDEFid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDSRCDEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(DataSource),' ') ||'; '
  into aBrief from FIELDSRCDEF  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function DINAMICFILTERSCRIPT_BRIEF_F  (
 aDINAMICFILTERSCRIPTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aDINAMICFILTERSCRIPTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from DINAMICFILTERSCRIPT  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDEXPRESSION_BRIEF_F  (
 aFIELDEXPRESSIONid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDEXPRESSIONid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDEXPRESSION  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDVALIDATOR_BRIEF_F  (
 aFIELDVALIDATORid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDVALIDATORid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Target
 into atmpID  from FIELDVALIDATOR  where  FIELDVALIDATORID = aFIELDVALIDATORID ;
 atmpBrief := func.GENERATOR_TARGET_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDMENU_BRIEF_F  (
 aFIELDMENUid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDMENUid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from FIELDMENU  where  FIELDMENUID = aFIELDMENUID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FIELDPARAMMAP_BRIEF_F  (
 aFIELDPARAMMAPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFIELDPARAMMAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(FieldName),' ') ||'; '
  into aBrief from FIELDPARAMMAP  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 select aBRIEF 
  ||  nvl(to_char(ParamName),' ') ||'; '
  into aBrief from FIELDPARAMMAP  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function MTZAPP_BRIEF_F  (
 aMTZAPPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aMTZAPPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from MTZAPP  where  MTZAPPID = aMTZAPPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ParentPackage_BRIEF_F  (
 aParentPackageid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aParentPackageid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ParentPackage where ParentPackageID=aParentPackageID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select Package
 into atmpID  from ParentPackage  where  ParentPackageID = aParentPackageID ;
 atmpBrief := func.MTZAPP_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function JournalColumn_BRIEF_F  (
 aJournalColumnid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aJournalColumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from JournalColumn  where  JournalColumnID = aJournalColumnID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function JColumnSource_BRIEF_F  (
 aJColumnSourceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aJColumnSourceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(ViewField),' ') ||'; '
  into aBrief from JColumnSource  where  JColumnSourceID = aJColumnSourceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function JournalSrc_BRIEF_F  (
 aJournalSrcid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aJournalSrcid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(PartView),' ') ||'; '
  into aBrief from JournalSrc  where  JournalSrcID = aJournalSrcID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Journal_BRIEF_F  (
 aJournalid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aJournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Journal where JournalID=aJournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Journal  where  JournalID = aJournalID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_bug_BRIEF_F  (
 atod_bugid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_bugid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_bug where tod_bugID=atod_bugID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_st_BRIEF_F  (
 atod_stid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_stid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_st where tod_stID=atod_stID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Folder_BRIEF_F  (
 aFolderid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFolderid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Folder where FolderID=aFolderID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Folder  where  FolderID = aFolderID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Shortcut_BRIEF_F  (
 aShortcutid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aShortcutid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Shortcut where ShortcutID=aShortcutID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select DocItem
 into atmpID  from Shortcut  where  ShortcutID = aShortcutID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function InfoStoreDef_BRIEF_F  (
 aInfoStoreDefid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aInfoStoreDefid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from InfoStoreDef  where  InfoStoreDefID = aInfoStoreDefID; 
  select  aBRIEF ||
  Decode( InfoStoreType
 ,2
 ,'Групповой'
 ,0
 ,' Общий'
 ,1
 ,'Персональный'
,'.') into aBrief from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function the_Session_BRIEF_F  (
 athe_Sessionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if athe_Sessionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from the_Session where the_SessionID=athe_SessionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select UserRole
 into atmpID  from the_Session  where  the_SessionID = athe_SessionID ;
 atmpBrief := func.Groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( Closed
 ,1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from the_Session where the_SessionID=athe_SessionID;
select Usersid
 into atmpID  from the_Session  where  the_SessionID = athe_SessionID ;
 atmpBrief := func.Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function SysRefCache_BRIEF_F  (
 aSysRefCacheid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aSysRefCacheid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SysRefCache where SysRefCacheID=aSysRefCacheID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select SessionID
 into atmpID  from SysRefCache  where  SysRefCacheID = aSysRefCacheID ;
 atmpBrief := func.the_Session_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function SysLog_BRIEF_F  (
 aSysLogid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aSysLogid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from SysLog where SysLogID=aSysLogID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheSession
 into atmpID  from SysLog  where  SysLogID = aSysLogID ;
 atmpBrief := func.the_Session_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(LogStructID),' ') ||'; '
  into aBrief from SysLog  where  SysLogID = aSysLogID; 
 select aBRIEF 
  ||  nvl(to_char(VERB),' ') ||'; '
  into aBrief from SysLog  where  SysLogID = aSysLogID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ARMJournal_BRIEF_F  (
 aARMJournalid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aARMJournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJournal where ARMJournalID=aARMJournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheJournal
 into atmpID  from ARMJournal  where  ARMJournalID = aARMJournalID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ARMJRNLREP_BRIEF_F  (
 aARMJRNLREPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aARMJRNLREPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(repname),' ') ||'; '
  into aBrief from ARMJRNLREP  where  ARMJRNLREPID = aARMJRNLREPID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ARMJRNLRUN_BRIEF_F  (
 aARMJRNLRUNid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aARMJRNLRUNid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ARMJRNLRUN  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ARMJRNLADD_BRIEF_F  (
 aARMJRNLADDid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aARMJRNLADDid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ARMJRNLADD  where  ARMJRNLADDID = aARMJRNLADDID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function EntryPoints_BRIEF_F  (
 aEntryPointsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aEntryPointsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from EntryPoints  where  EntryPointsID = aEntryPointsID; 
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from EntryPoints  where  EntryPointsID = aEntryPointsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function EPFilterLink_BRIEF_F  (
 aEPFilterLinkid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aEPFilterLinkid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(RowSource),' ') ||'; '
  into aBrief from EPFilterLink  where  EPFilterLinkID = aEPFilterLinkID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function WorkPlace_BRIEF_F  (
 aWorkPlaceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aWorkPlaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from WorkPlace  where  WorkPlaceID = aWorkPlaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ARMTypes_BRIEF_F  (
 aARMTypesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aARMTypesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ARMTypes where ARMTypesID=aARMTypesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheDocumentType
 into atmpID  from ARMTypes  where  ARMTypesID = aARMTypesID ;
 atmpBrief := func.OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_OPERATIONS_BRIEF_F  (
 aROLES_OPERATIONSid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_OPERATIONSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_OPERATIONS where ROLES_OPERATIONSID=aROLES_OPERATIONSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(info),' ') ||'; '
  into aBrief from ROLES_OPERATIONS  where  ROLES_OPERATIONSID = aROLES_OPERATIONSID; 
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ROLES_OPERATIONS  where  ROLES_OPERATIONSID = aROLES_OPERATIONSID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_WP_BRIEF_F  (
 aROLES_WPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_WPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select WP
 into atmpID  from ROLES_WP  where  ROLES_WPID = aROLES_WPID ;
 atmpBrief := func.WorkPlace_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_ACT_BRIEF_F  (
 aROLES_ACTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_ACTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  Decode( Accesible
 ,1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
 select aBRIEF 
  ||  nvl(to_char(MenuName),' ') ||'; '
  into aBrief from ROLES_ACT  where  ROLES_ACTID = aROLES_ACTID; 
 select aBRIEF 
  ||  nvl(to_char(menuCode),' ') ||'; '
  into aBrief from ROLES_ACT  where  ROLES_ACTID = aROLES_ACTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES2_MODULE_BRIEF_F  (
 aROLES2_MODULEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES2_MODULEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES2_MODULE where ROLES2_MODULEID=aROLES2_MODULEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from ROLES2_MODULE  where  ROLES2_MODULEID = aROLES2_MODULEID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from ROLES2_MODULE  where  ROLES2_MODULEID = aROLES2_MODULEID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES2_MODREPORT_BRIEF_F  (
 aROLES2_MODREPORTid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES2_MODREPORTid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES2_MODREPORT where ROLES2_MODREPORTID=aROLES2_MODREPORTID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from ROLES2_MODREPORT  where  ROLES2_MODREPORTID = aROLES2_MODREPORTID; 
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from ROLES2_MODREPORT  where  ROLES2_MODREPORTID = aROLES2_MODREPORTID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_DOC_BRIEF_F  (
 aROLES_DOCid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_DOCid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_Document
 into atmpID  from ROLES_DOC  where  ROLES_DOCID = aROLES_DOCID ;
 atmpBrief := func.OBJECTTYPE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_DOC_STATE_BRIEF_F  (
 aROLES_DOC_STATEid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_DOC_STATEid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_State
 into atmpID  from ROLES_DOC_STATE  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID ;
 atmpBrief := func.OBJSTATUS_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select The_Mode
 into atmpID  from ROLES_DOC_STATE  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID ;
 atmpBrief := func.OBJECTMODE_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_REPORTS_BRIEF_F  (
 aROLES_REPORTSid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_REPORTSid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select The_Report
 into atmpID  from ROLES_REPORTS  where  ROLES_REPORTSID = aROLES_REPORTSID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_USER_BRIEF_F  (
 aROLES_USERid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_USERid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheUser
 into atmpID  from ROLES_USER  where  ROLES_USERID = aROLES_USERID ;
 atmpBrief := func.Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_MAP_BRIEF_F  (
 aROLES_MAPid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_MAPid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheGroup
 into atmpID  from ROLES_MAP  where  ROLES_MAPID = aROLES_MAPID ;
 atmpBrief := func.Groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function ROLES_DEF_BRIEF_F  (
 aROLES_DEFid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aROLES_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from ROLES_DEF  where  ROLES_DEFID = aROLES_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Users_BRIEF_F  (
 aUsersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aUsersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Users where UsersID=aUsersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Family),' ') ||'; '
  into aBrief from Users  where  UsersID = aUsersID; 
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Users  where  UsersID = aUsersID; 
 select aBRIEF 
  ||  nvl(to_char(SurName),' ') ||'; '
  into aBrief from Users  where  UsersID = aUsersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Groups_BRIEF_F  (
 aGroupsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGroupsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Groups where GroupsID=aGroupsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Groups  where  GroupsID = aGroupsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function GroupUser_BRIEF_F  (
 aGroupUserid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aGroupUserid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from GroupUser where GroupUserID=aGroupUserID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select TheUser
 into atmpID  from GroupUser  where  GroupUserID = aGroupUserID ;
 atmpBrief := func.Users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Num_zones_BRIEF_F  (
 aNum_zonesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aNum_zonesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_zones where Num_zonesID=aNum_zonesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(ZoneMask),' ') ||'; '
  into aBrief from Num_zones  where  Num_zonesID = aNum_zonesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Num_Values_BRIEF_F  (
 aNum_Valuesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aNum_Valuesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(the_Value),' ') ||'; '
  into aBrief from Num_Values  where  Num_ValuesID = aNum_ValuesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Num_head_BRIEF_F  (
 aNum_headid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aNum_headid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Num_head where Num_headID=aNum_headID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Num_head  where  Num_headID = aNum_headID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function MTZExt_def_BRIEF_F  (
 aMTZExt_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aMTZExt_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from MTZExt_def  where  MTZExt_defID = aMTZExt_defID; 
  select  aBRIEF ||
  Decode( ExtType
 ,6
 ,'VerifyRowExt'
 ,7
 ,'CodeGenerator'
 ,5
 ,'DefaultExt'
 ,0
 ,'StatusExt'
 ,4
 ,'JrnlRunExt'
 ,2
 ,'CustomExt'
 ,8
 ,'ARMGenerator'
 ,1
 ,'OnFormExt'
 ,3
 ,'JrnlAddExt'
,'.') into aBrief from MTZExt_def where MTZExt_defID=aMTZExt_defID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function MTZExtRel_BRIEF_F  (
 aMTZExtRelid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aMTZExtRelid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  Decode( ThePlatform
 ,3
 ,'OTHER'
 ,1
 ,'DOTNET'
 ,2
 ,'JAVA'
 ,0
 ,'VB6'
,'.') into aBrief from MTZExtRel where MTZExtRelID=aMTZExtRelID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function MTZ2JOB_DEF_BRIEF_F  (
 aMTZ2JOB_DEFid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aMTZ2JOB_DEFid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(EventDate),' ') ||'; '
  into aBrief from MTZ2JOB_DEF  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 select aBRIEF 
  ||  nvl(to_char(EvenType),' ') ||'; '
  into aBrief from MTZ2JOB_DEF  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FilterFieldGroup_BRIEF_F  (
 aFilterFieldGroupid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFilterFieldGroupid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from FilterFieldGroup  where  FilterFieldGroupID = aFilterFieldGroupID; 
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from FilterFieldGroup  where  FilterFieldGroupID = aFilterFieldGroupID; 
  select  aBRIEF ||
  Decode( AllowIgnore
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function FileterField_BRIEF_F  (
 aFileterFieldid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFileterFieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from FileterField where FileterFieldID=aFileterFieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from FileterField  where  FileterFieldID = aFileterFieldID; 
 select aBRIEF 
  ||  nvl(to_char(Caption),' ') ||'; '
  into aBrief from FileterField  where  FileterFieldID = aFileterFieldID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Filters_BRIEF_F  (
 aFiltersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aFiltersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Filters where FiltersID=aFiltersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Filters  where  FiltersID = aFiltersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function RPTStruct_BRIEF_F  (
 aRPTStructid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aRPTStructid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTStruct where RPTStructID=aRPTStructID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from RPTStruct  where  RPTStructID = aRPTStructID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function RPTFields_BRIEF_F  (
 aRPTFieldsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aRPTFieldsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from RPTFields  where  RPTFieldsID = aRPTFieldsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function RPTFormula_BRIEF_F  (
 aRPTFormulaid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aRPTFormulaid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from RPTFormula  where  RPTFormulaID = aRPTFormulaID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function Reports_BRIEF_F  (
 aReportsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aReportsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from Reports where ReportsID=aReportsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(Name),' ') ||'; '
  into aBrief from Reports  where  ReportsID = aReportsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;
 end Func;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Kernel.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package body Kernel as

procedure INSTANCE_OWNER   (
    acursession CHAR ,ainstanceid CHAR,
 aOwnerPartName varchar2, aOwnerRowID CHAR) as
 existsCnt integer;
begin
select count(*)into existscnt from instance
where instanceid=ainstanceid;
If existsCnt &gt; 0 Then
  if aOwnerPartName is null or aownerRowID is null
  then
     update instance set OwnerPartName=null, OwnerRowid = null where instanceid=ainstanceid ;
  Else
     update instance set OwnerPartName=aOwnerPartName, OwnerRowid = aOwnerRowID where instanceid=ainstanceid ;
  End if;
End if;
end;
procedure SYSOPTIONS_SAVE    (
   aSysOptionsid CHAR,
aName varchar2,
aValue varchar2 ,
aOptionType varchar2) as
existsCnt numeric;
begin
 select count(*) into existsCnt from sysoptions where sysoptionsid=asysoptionsid;
 If existsCnt &gt; 0 Then
  update sysoptions set Name=aName, theValue=aValue, OptionType=aOptionType where sysoptionsid=asysoptionsid ;
 Else
  insert into sysoptions (sysoptionsid, Name, theValue, OptionType)values(asysoptionsid,aName,aValue,aOptionType) ;
 End if;
end;
procedure INSTANCE_SAVE      (
aCURSESSION CHAR,
aInstanceID CHAR,
aObjType varchar2,
aName varchar2
) as
 atmpStr varchar2(255) ;
 aSSID CHAR(38) ;
 atmpID CHAR(38) ;
 aSysLogID CHAR(38) ;
 aaccess numeric ;
 aSysInstID CHAR(38) ;
 aStatusID CHAR(38) ;
 existsCnt numeric;
 theObjType varchar2(255);
begin
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select  count(*) into existsCnt  from instance where instanceid=ainstanceid;
 If existsCnt &gt; 0 Then
   select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,athe_resource=&gt;atmpID,averb=&gt;'EDIT',aaccess=&gt;aaccess  );
   If aaccess = 0 Then
     raise_application_error(-20000,'Нет прав на изменение объекта.') ;
     return ;
   end if;
   MTZ.Kernel.instance_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;ainstanceid,aIsLocked=&gt;aaccess  );
   If aaccess &gt; 2 Then
     raise_application_error(-20000,'Объект заблокирован другим пользователем.') ;
     return;
   end if;
   select objtype into TheObjType from instance  where  instanceid=ainstanceid ;
   update instance set name = aname where  instanceid=ainstanceid;
   select newid() into aSysLogID from sys.DUAL ;
   MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid,
   aLogStructID =&gt; TheOBJTYPE ,
   aVERB=&gt;'EDIT',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID );
 Else
    select count(*) into existsCnt from typelist where name = aobjtype;
    If existsCnt &gt; 0 Then
      select SecurityStyleid,RegisterProc into aSSID,atmpstr  from typelist where name = aobjtype;
      CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;aSSID,averb=&gt;'CREATE',aaccess=&gt;aaccess  );
      If aaccess = 0 Then
         raise_application_error(-20000,'Нет прав на создание объекта.') ;
         return;
      end if;
    end if;
   begin
   select objstatusid into astatusid from objstatus join objecttype on
         objecttype.objecttypeid=objstatus.parentstructrowid and objecttype.name=aobjtype and isStartup&lt;&gt;0;
   exception when others then
      astatusid:=null ;
    end;
   If astatusid Is Null Then
     insert into instance(instanceid,name,objtype,SecurityStyleID) values(ainstanceid,aname,aobjtype,aSSID)         ;
   Else
     insert into instance(instanceid,name,objtype,SecurityStyleID,STATUS) values(ainstanceid,aname,aobjtype,aSSID,aSTATUSID) ;
   end if;
   If Not atmpstr Is Null Then
      execute immediate atmpstr using  acursession, ainstanceid;
   end if;
   select newid() into aSysLogid from sys.dual ;
   
   MTZSystem.SysLog_SAVE (
     aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession,
     aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aOBJTYPE ,
     aVERB=&gt;'CREATE',  aThe_Resource=&gt;aInstanceID , aLogInstanceID=&gt;aInstanceID);
 End  if;
End;
  procedure INSTANCE_DELETE    (
aCURSESSION CHAR,
aInstanceID Char
) as
 atmpStr varchar2(255) ;
  aStr varchar2(4000) ;
  aObjType varchar2(255) ;
 aSysInstID CHAR(38) ;
    atmpID CHAR(38) ;
   aaccess integer;
   aOwnerPartName varchar2(255) ;
   aOwnerRowID CHAR(38) ;
   aSysLogid CHAR(38) ;
    existsCnt integer;
begin
  select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM' ;
  select count(*) into existsCnt from instance where instanceid=ainstanceid;
  If existsCnt &gt; 0 Then
   select  SecurityStyleID, OwnerPartName,OWnerRowID
        Into atmpid, aOwnerpartname, aownerrowid
        from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETE',aaccess=&gt;aaccess);
   If aaccess = 0 Then
       raise_application_error(-20000,'Нет прав на удаление.');
       Return ;
   End if;
   If aOwnerpartname Is Null Or aownerrowid Is Null Then
        select  objtype into aobjtype from instance where instanceid=ainstanceid;
        select 'begin MTZ.' || aobjtype || '.' || DeleteProc ||'(:1,:2); end;' into atmpstr from typelist where name = aobjtype;
        If Not atmpstr Is Null Then
            EXECUTE IMMEDIATE atmpstr USING acursession,ainstanceid;
        end if;
        delete from instance where instanceid=ainstanceid ;
        select newid() into aSysLogID from SYS.DUAL;
        MTZSystem.SysLog_SAVE( aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aobjtype ,
        aVERB=&gt;'DELETE',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID);
        Else
        -- Owner exists
         astr :='select '|| aownerpartname || 'id  from ' || aownerpartname || ' where ' || aownerpartname ||'id=:1';
         execute immediate  astr into atmpid using aownerrowid;
         If atmpid = aownerrowid Then
           raise_application_error(-20000,'Этот документ принадлежит другому документу и не может быть удален отдельно.');
           return;
         End if;
         select  objtype into aObjType from instance where instanceid=ainstanceid;
         select 'begin MTZ.' || aobjtype || '.' || DeleteProc ||'(:1,:2); end;' into atmpstr from typelist where name = aobjtype ;
         If Not atmpstr Is Null Then
           execute immediate atmpstr using acursession, ainstanceid ;
           delete from instance where instanceid=ainstanceid ;
         select newid() into aSysLogID from SYS.DUAL;
         MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession,
                      aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aobjtype ,
                      aVERB=&gt;'DELETE',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID );
        End if;
     End if;
End if;
end;
  procedure INSTANCE_HCL   (
aCURSESSION CHAR,
aRowID CHAR,
aIsLocked out NUMBER
) as
atmpStr varchar2(255) ;
aObjType varchar2(255) ;
existscnt integer;
begin
select count(*) into existsCnt from instance where instanceid=arowid ;
if existscnt=1
    then
      select objtype into aobjtype  from instance where instanceid=arowid ;
      select 'begin MTZ.' || aobjtype || '.' || HCLProc || '(:1,:2,:3); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute immediate atmpstr using acursession, arowid,out aIsLocked ;
      End if;
end if;
End;
  procedure INSTANCE_PROPAGATE   (
aCURSESSION CHAR,
aRowID Char
) as
atmpStr varchar2(255) ;
aObjType varchar2(255);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=arowid ;
if existsCnt=1
    then
      select  objtype into aobjtype from instance where instanceid=arowid ;
      select  'begin MTZ.' || aobjtype || '.' || propagateProc || '(:1,:2); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute immediate atmpstr using  acursession, arowid ;
    End if;
End if;
End;
  procedure INSTANCE_ISLOCKED   (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as
 aUserID CHAR(38) ;
 aLockUserID CHAR(38) ;
 aLockSessionID CHAR(38) ;
 existsCnt integer;
 begin
 aisLocked := 0 ;
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 If existsCnt = 0 Then
   raise_APPLICATION_Error(-20000,'Сессия уже завершена');
   Return ;
 End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession ;
 select LockUserID, LockSessionID
 Into aLockUserID, aLockSessionID
 from INSTANCE where INSTANCEid=aRowID ;
 If Not aLockUserID Is Null Then
   If aLockUserID &lt;&gt; auserID Then
     aisLocked := 4; /* CheckOut by another user */
     Return ;
   Else
     aisLocked := 2; /* CheckOut by caller */
     Return;
   end if;
 End if;
 If Not aLockSessionID Is Null Then
   If aLockSessionID &lt;&gt; aCURSESSION Then
     aisLocked := 3 ;/* Lockes by another user */
     Return ;
   Else
     aisLocked := 1; /* Locked by caller */
     Return ;
   end if;
 End if;
 aisLocked := 0 ;
 End;
  procedure INSTANCE_SINIT    (
aCURSESSION CHAR,
aRowID CHAR ,
 aSecurityStyleID Char
)as
aParentTable varchar2(255) ;
 aStyleID CHAR(38) ;
 atmpID CHAR(38) ;
 aaccess integer ;
 begin
  select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aROWID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess);
 if aaccess=0
  then
    raise_application_error(-20000,'Нет прав на управление защитой.');
    return ;
  end if;
  If aSecurityStyleID Is Null Then
    select  objtype into aParentTable from instance where instanceid=aRowID ;
    select SecurityStyleID  into aStyleID from typelist where name =aParentTable ;
    update Instance set securitystyleid =aStyleID where Instanceid = aRowID;
  Else
    update Instance set securitystyleid =aSecurityStyleID where Instanceid = aRowID ;
  End if;
End;
  procedure INSTANCE_LOCK     (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer
) as
aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer ;
 aIsLocked integer ;
 existsCnt integer;
  begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
If existsCnt = 0 Then
    raise_application_error(-20000,'Сессия уже завершена.') ;
    Return ;
End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession;
 MTZ.Kernel.Instance_ISLOCKED (aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3
  then
    raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
 if aIsLocked =0
 then
  MTZ.Kernel.Instance_HCL( acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3
  then
     raise_application_error(-20000,'У данного объекта имеются дочерние строки, которые заблокированы другим пользователем');
     Return ;
  End if;
 End if;
 select  SecurityStyleID into atmpid from INSTANCE where INSTANCEid=aROWID ;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKINSTANCE',aaccess=&gt;aaccess);
 if aaccess=0
  then
    raise_application_error(-20000,'Нет прав на блокировку объекта.');
    return ;
  end if;
   if  aLockMode =2
   then
    update INSTANCE  set LockUserID =auserID ,LockSessionID =null where Instanceid=aRowID ;
     Return ;
   End if ;
   if  aLockMode =1
   then
    update INSTANCE  set LockUserID =null,LockSessionID =aCURSESSION  where Instanceid=aRowID ;
     Return ;
   End if;
 End;
  procedure INSTANCE_UNLOCK (
 aCURSESSION CHAR,
 aROWID Char
) as
 aParentID CHAR(38);
 aUserID CHAR(38) ;
 aIsLocked integer ;
 aParentTable varchar2(255);
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
if  existsCnt =0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    Return ;
  End if;
  MTZ.Kernel.Instance_ISLOCKED( aCURSESSION,aROWID,aISLocked  );
 if aIsLocked &gt;=3
  then
    raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
   if  aIsLocked =2
   then
    update INSTANCE set LockUserID =null  where Instanceid=aRowID ;
     Return ;
   End if;
   if  aIsLocked =1
   then
    update INSTANCE set LockSessionID =null  where Instanceid=aRowID;
     Return ;
   End if;
 End; 
    procedure INSTANCE_BRIEF    (
 aCURSESSION CHAR,
 ainstanceid CHAR,
 aBRIEF out varchar2
) as
 atmpStr varchar2(255);
 aaccess int ;
 atmpBrief varchar2(4000) ;
 atmpID CHAR(38) ;
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt  from  the_session where the_sessionid=acursession and closed=0;
If existsCnt = 0 Then
    raise_application_error(-20000,'Сессия уже завершена.') ;
    Return ;
  End if;
If ainstanceid Is Null Then
     aBRIEF:='';
    return;
end if;
 -- Brief body --
  select count(*) into existsCnt  from instance where instanceID=ainstanceID;
If existsCnt = 1 Then
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceID ;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,
     averb=&gt;'BRIEF',aaccess=&gt;aaccess);
 If aaccess = 0 Then
    raise_application_error(-20000,'Нет прав на получение краткого наименования. Раздел=instance') ;
    Return ;
 End  if;
  select func.instance_brief_F(instanceid) into aBrief from instance where instanceid=ainstanceid;
 Else
   aBRIEF:= 'неверный идентификатор';
End if;
    aBRIEF:=substr(aBRIEF,1,255);
End;
    procedure QR_AND_QR  ( aid1 CHAR, aid2
    CHAR,aidout CHAR,acnt out integer )
as
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, a.result
from QueryResult a
join QueryResult b on b.QueryResultid=aid2 and a.result=b.result
where a.QueryResultid=aid1 ;
select count(*) into acnt from QueryResult where QueryResultid=aidout;
end;
    procedure QR_OR_QR  ( aid1 CHAR, aid2 
    CHAR,aidout CHAR,acnt out integer)
as
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, result from QueryResult where QueryResultid in (aid1,aid2);
select count(*) into acnt from QueryResult where QueryResultid=aidout;
End;
  procedure ROWPARENTS
(aQueryID   CHAR
,aRowID CHAR/* Row */
,aTable varchar2 /* Part Table Name */
,aCURSESSION CHAR/* the_session */
) as
astr varchar(4000);
aplevel integer ;
aparent varchar2(255) ;
aprev varchar2(255) ;
atmpID  CHAR(38) ;
atmpRowID  CHAR(38) ;
existsCnt integer;
begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'the_session expired') ;
    Return ;
  End if;
aparent :=atable ;
atmpID := aROWID ;
aplevel :=0 ;
delete from RPRESULT where RPRESULTID
  =aQUERYID;
insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,atable,aRowID) ;
&lt;&lt;again&gt;&gt;
 aplevel :=aplevel + 1 ;
 aprev := aparent ;
 begin
   select thevalue into aparent from sysoptions where optiontype ='PARENT' and  name=aprev ;
 exception when others then
   aparent := null ;
 end;
 if aparent is null
 then
     astr := 'select InstanceID  from ' || aprev || ' where ' || aprev || 'id=:1' ;
    execute immediate astr into atmpRowID using atmpid ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,'INSTANCE',atmpRowID);
 Else
    astr := 'select ParentStructRowID  from ' || aprev || ' where '  || aprev || 'id=:1' ;
    execute immediate astr into atmpRowID using atmpid ;
    atmpID := atmpROWID ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,aparent,atmpRowID) ;
    GoTo again ;
 End if;
End;
    procedure INSTANCE_STATUS    (
  acursession CHAR,
  ainstanceid CHAR,
  astatusid CHAR)
as
   aSSID CHAR(38);
   atmpID CHAR(38);
   aSysLogID CHAR(38) ;
   aaccess integer;
   aSysInstID CHAR(38) ;
   aObjType varchar2(255) ;
   existsCnt integer;
  begin
   select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM' ;
   select count(*) into existsCnt from instance where instanceid=ainstanceid;
 If existsCnt = 1 Then
   select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'STATUS',aaccess=&gt;aaccess );
   If aaccess = 0 Then
    raise_application_error(-20000,'Нет прав на изменение состояния объекта.');
    Return ;
   End if;
    MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainstanceid,aIsLocked=&gt;aaccess);
   If aaccess &gt; 2 Then
     raise_application_error(-20000,'Документ заблокирован другим пльзователем.') ;
     Return ;
   End if;
   select objtype into aObjType from instance  where  instanceid=ainstanceid ;
   select count(*) into existsCnt from objstatus
  join objecttype on objstatus.parentstructrowid=objecttype.objecttypeid
  where objecttype.name=aobjtype and objstatusid=astatusid ;
   If existsCnt = 1 Then
     update instance set status = astatusid where  instanceid=ainstanceid ;
     select newid() into aSysLogid from sys.dual;
     MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aSTATUSID ,
     aVERB=&gt;'STATUS',  aThe_Resource=&gt;aInstanceID , aLogInstanceID=&gt;aInstanceID); 
   End if;
 End if;
End;
 end Kernel;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Type.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZMetaModel" BlockCode=" create or replace package body MTZMetaModel as

procedure MTZMetaModel_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZMetaModel'
then
declare cursor child_GENPACKAGE is select GENPACKAGE.GENPACKAGEid ID from GENPACKAGE where  GENPACKAGE.InstanceID = ainstanceid;
row_GENPACKAGE  child_GENPACKAGE%ROWTYPE;
begin
--open child_GENPACKAGE;
for row_GENPACKAGE in child_GENPACKAGE loop
 GENPACKAGE_DELETE (acursession,row_GENPACKAGE.id,aInstanceID);
end loop;
--close child_GENPACKAGE;
end;
declare cursor child_LocalizeInfo is select LocalizeInfo.LocalizeInfoid ID from LocalizeInfo where  LocalizeInfo.InstanceID = ainstanceid;
row_LocalizeInfo  child_LocalizeInfo%ROWTYPE;
begin
--open child_LocalizeInfo;
for row_LocalizeInfo in child_LocalizeInfo loop
 LocalizeInfo_DELETE (acursession,row_LocalizeInfo.id,aInstanceID);
end loop;
--close child_LocalizeInfo;
end;
declare cursor child_FIELDTYPE is select FIELDTYPE.FIELDTYPEid ID from FIELDTYPE where  FIELDTYPE.InstanceID = ainstanceid;
row_FIELDTYPE  child_FIELDTYPE%ROWTYPE;
begin
--open child_FIELDTYPE;
for row_FIELDTYPE in child_FIELDTYPE loop
 FIELDTYPE_DELETE (acursession,row_FIELDTYPE.id,aInstanceID);
end loop;
--close child_FIELDTYPE;
end;
declare cursor child_SHAREDMETHOD is select SHAREDMETHOD.SHAREDMETHODid ID from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = ainstanceid;
row_SHAREDMETHOD  child_SHAREDMETHOD%ROWTYPE;
begin
--open child_SHAREDMETHOD;
for row_SHAREDMETHOD in child_SHAREDMETHOD loop
 SHAREDMETHOD_DELETE (acursession,row_SHAREDMETHOD.id,aInstanceID);
end loop;
--close child_SHAREDMETHOD;
end;
declare cursor child_OBJECTTYPE is select OBJECTTYPE.OBJECTTYPEid ID from OBJECTTYPE where  OBJECTTYPE.InstanceID = ainstanceid;
row_OBJECTTYPE  child_OBJECTTYPE%ROWTYPE;
begin
--open child_OBJECTTYPE;
for row_OBJECTTYPE in child_OBJECTTYPE loop
 OBJECTTYPE_DELETE (acursession,row_OBJECTTYPE.id,aInstanceID);
end loop;
--close child_OBJECTTYPE;
end;
declare cursor child_MTZAPP is select MTZAPP.MTZAPPid ID from MTZAPP where  MTZAPP.InstanceID = ainstanceid;
row_MTZAPP  child_MTZAPP%ROWTYPE;
begin
--open child_MTZAPP;
for row_MTZAPP in child_MTZAPP loop
 MTZAPP_DELETE (acursession,row_MTZAPP.id,aInstanceID);
end loop;
--close child_MTZAPP;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZMetaModel_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZMetaModel'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_GENPACKAGE is select GENPACKAGE.GENPACKAGEid ID from GENPACKAGE where  GENPACKAGE.InstanceID = arowid;
ROW_GENPACKAGE  lch_GENPACKAGE%ROWTYPE;
begin
--open lch_GENPACKAGE;
for row_GENPACKAGE in lch_GENPACKAGE loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from GENPACKAGE where GENPACKAGEid=row_GENPACKAGE.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GENPACKAGE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_GENPACKAGE;
     return;
   end if; 
 end if; 
 GENPACKAGE_HCL (acursession,ROW_GENPACKAGE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GENPACKAGE;
   return;
 end if;
 end loop;
--close lch_GENPACKAGE;
end;
declare cursor lch_LocalizeInfo is select LocalizeInfo.LocalizeInfoid ID from LocalizeInfo where  LocalizeInfo.InstanceID = arowid;
ROW_LocalizeInfo  lch_LocalizeInfo%ROWTYPE;
begin
--open lch_LocalizeInfo;
for row_LocalizeInfo in lch_LocalizeInfo loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from LocalizeInfo where LocalizeInfoid=row_LocalizeInfo.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_LocalizeInfo;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_LocalizeInfo;
     return;
   end if; 
 end if; 
 LocalizeInfo_HCL (acursession,ROW_LocalizeInfo.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_LocalizeInfo;
   return;
 end if;
 end loop;
--close lch_LocalizeInfo;
end;
declare cursor lch_FIELDTYPE is select FIELDTYPE.FIELDTYPEid ID from FIELDTYPE where  FIELDTYPE.InstanceID = arowid;
ROW_FIELDTYPE  lch_FIELDTYPE%ROWTYPE;
begin
--open lch_FIELDTYPE;
for row_FIELDTYPE in lch_FIELDTYPE loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from FIELDTYPE where FIELDTYPEid=row_FIELDTYPE.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDTYPE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_FIELDTYPE;
     return;
   end if; 
 end if; 
 FIELDTYPE_HCL (acursession,ROW_FIELDTYPE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDTYPE;
   return;
 end if;
 end loop;
--close lch_FIELDTYPE;
end;
declare cursor lch_SHAREDMETHOD is select SHAREDMETHOD.SHAREDMETHODid ID from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = arowid;
ROW_SHAREDMETHOD  lch_SHAREDMETHOD%ROWTYPE;
begin
--open lch_SHAREDMETHOD;
for row_SHAREDMETHOD in lch_SHAREDMETHOD loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SHAREDMETHOD where SHAREDMETHODid=row_SHAREDMETHOD.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_SHAREDMETHOD;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_SHAREDMETHOD;
     return;
   end if; 
 end if; 
 SHAREDMETHOD_HCL (acursession,ROW_SHAREDMETHOD.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_SHAREDMETHOD;
   return;
 end if;
 end loop;
--close lch_SHAREDMETHOD;
end;
declare cursor lch_OBJECTTYPE is select OBJECTTYPE.OBJECTTYPEid ID from OBJECTTYPE where  OBJECTTYPE.InstanceID = arowid;
ROW_OBJECTTYPE  lch_OBJECTTYPE%ROWTYPE;
begin
--open lch_OBJECTTYPE;
for row_OBJECTTYPE in lch_OBJECTTYPE loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from OBJECTTYPE where OBJECTTYPEid=row_OBJECTTYPE.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_OBJECTTYPE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_OBJECTTYPE;
     return;
   end if; 
 end if; 
 OBJECTTYPE_HCL (acursession,ROW_OBJECTTYPE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_OBJECTTYPE;
   return;
 end if;
 end loop;
--close lch_OBJECTTYPE;
end;
declare cursor lch_MTZAPP is select MTZAPP.MTZAPPid ID from MTZAPP where  MTZAPP.InstanceID = arowid;
ROW_MTZAPP  lch_MTZAPP%ROWTYPE;
begin
--open lch_MTZAPP;
for row_MTZAPP in lch_MTZAPP loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZAPP where MTZAPPid=row_MTZAPP.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_MTZAPP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_MTZAPP;
     return;
   end if; 
 end if; 
 MTZAPP_HCL (acursession,ROW_MTZAPP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_MTZAPP;
   return;
 end if;
 end loop;
--close lch_MTZAPP;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZMetaModel_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZMetaModel'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_GENPACKAGE is select GENPACKAGE.GENPACKAGEid id from GENPACKAGE where  GENPACKAGE.InstanceID = arowid;
row_GENPACKAGE  pch_GENPACKAGE%ROWTYPE;
begin
--open pch_GENPACKAGE;
for row_GENPACKAGE in  pch_GENPACKAGE loop
 GENPACKAGE_SINIT( acursession,row_GENPACKAGE.id,assid);
 GENPACKAGE_propagate( acursession,row_GENPACKAGE.id);
end loop;
--close pch_GENPACKAGE;
end;
declare cursor pch_LocalizeInfo is select LocalizeInfo.LocalizeInfoid id from LocalizeInfo where  LocalizeInfo.InstanceID = arowid;
row_LocalizeInfo  pch_LocalizeInfo%ROWTYPE;
begin
--open pch_LocalizeInfo;
for row_LocalizeInfo in  pch_LocalizeInfo loop
 LocalizeInfo_SINIT( acursession,row_LocalizeInfo.id,assid);
 LocalizeInfo_propagate( acursession,row_LocalizeInfo.id);
end loop;
--close pch_LocalizeInfo;
end;
declare cursor pch_FIELDTYPE is select FIELDTYPE.FIELDTYPEid id from FIELDTYPE where  FIELDTYPE.InstanceID = arowid;
row_FIELDTYPE  pch_FIELDTYPE%ROWTYPE;
begin
--open pch_FIELDTYPE;
for row_FIELDTYPE in  pch_FIELDTYPE loop
 FIELDTYPE_SINIT( acursession,row_FIELDTYPE.id,assid);
 FIELDTYPE_propagate( acursession,row_FIELDTYPE.id);
end loop;
--close pch_FIELDTYPE;
end;
declare cursor pch_SHAREDMETHOD is select SHAREDMETHOD.SHAREDMETHODid id from SHAREDMETHOD where  SHAREDMETHOD.InstanceID = arowid;
row_SHAREDMETHOD  pch_SHAREDMETHOD%ROWTYPE;
begin
--open pch_SHAREDMETHOD;
for row_SHAREDMETHOD in  pch_SHAREDMETHOD loop
 SHAREDMETHOD_SINIT( acursession,row_SHAREDMETHOD.id,assid);
 SHAREDMETHOD_propagate( acursession,row_SHAREDMETHOD.id);
end loop;
--close pch_SHAREDMETHOD;
end;
declare cursor pch_OBJECTTYPE is select OBJECTTYPE.OBJECTTYPEid id from OBJECTTYPE where  OBJECTTYPE.InstanceID = arowid;
row_OBJECTTYPE  pch_OBJECTTYPE%ROWTYPE;
begin
--open pch_OBJECTTYPE;
for row_OBJECTTYPE in  pch_OBJECTTYPE loop
 OBJECTTYPE_SINIT( acursession,row_OBJECTTYPE.id,assid);
 OBJECTTYPE_propagate( acursession,row_OBJECTTYPE.id);
end loop;
--close pch_OBJECTTYPE;
end;
declare cursor pch_MTZAPP is select MTZAPP.MTZAPPid id from MTZAPP where  MTZAPP.InstanceID = arowid;
row_MTZAPP  pch_MTZAPP%ROWTYPE;
begin
--open pch_MTZAPP;
for row_MTZAPP in  pch_MTZAPP loop
 MTZAPP_SINIT( acursession,row_MTZAPP.id,assid);
 MTZAPP_propagate( acursession,row_MTZAPP.id);
end loop;
--close pch_MTZAPP;
end;
 end if; 
end;


procedure GENPACKAGE_BRIEF  (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGENPACKAGEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GENPACKAGE where GENPACKAGEid=aGENPACKAGEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GENPACKAGE');
    return;
  end if;
  aBRIEF:=func.GENPACKAGE_BRIEF_F(aGENPACKAGEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GENPACKAGE_DELETE /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GENPACKAGE where GENPACKAGEid=aGENPACKAGEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GENPACKAGE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GENPACKAGE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENPACKAGE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENPACKAGEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENPACKAGE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_GENERATOR_TARGET is select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aGENPACKAGEid;
    child_GENERATOR_TARGET_rec  child_GENERATOR_TARGET%ROWTYPE;
    begin
    --open child_GENERATOR_TARGET;
      for child_GENERATOR_TARGET_rec in child_GENERATOR_TARGET loop
      GENERATOR_TARGET_DELETE (acursession,child_GENERATOR_TARGET_rec.id,aInstanceid);
      end loop;
      --close child_GENERATOR_TARGET;
    end ;
declare cursor chld_GENPACKAGE is select  instanceid ID from instance where OwnerPartName ='GENPACKAGE' and OwnerRowID=aGENPACKAGEid;
row_GENPACKAGE  chld_GENPACKAGE%ROWTYPE;
begin
--open chld_GENPACKAGE;
for row_GENPACKAGE in chld_GENPACKAGE loop
 Kernel.INSTANCE_OWNER (acursession,row_GENPACKAGE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GENPACKAGE.id);
end loop;
--close chld_GENPACKAGE;
end ;
  delete from  GENPACKAGE 
  where  GENPACKAGEID = aGENPACKAGEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пакет генерации*/
procedure GENPACKAGE_SAVE /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aGENPACKAGEid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENPACKAGE where GENPACKAGEID=aGENPACKAGEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GENPACKAGE where GENPACKAGEid=aGENPACKAGEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GENPACKAGE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GENPACKAGE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENPACKAGE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENPACKAGEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENPACKAGE');
    return;
  end if;
 -- update row  --
 update  GENPACKAGE set ChangeStamp=sysdate
,
  Name=aName
  where  GENPACKAGEID = aGENPACKAGEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GENPACKAGE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GENPACKAGE');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENPACKAGE');
    return;
  end if;
 insert into   GENPACKAGE
 (  GENPACKAGEID 
,InstanceID
,Name

 ) values ( aGENPACKAGEID 
,aInstanceID
,aName

 ); 
 GENPACKAGE_SINIT( aCURSESSION,aGENPACKAGEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure GENPACKAGE_PARENT /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from GENPACKAGE where  GENPACKAGEid=aRowID;
 end; 

procedure GENPACKAGE_ISLOCKED /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENPACKAGE where GENPACKAGEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GENPACKAGE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GENPACKAGE_LOCK /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GENPACKAGE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GENPACKAGE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GENPACKAGE where GENPACKAGEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GENPACKAGE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GENPACKAGE set LockUserID =auserID ,LockSessionID =null where GENPACKAGEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENPACKAGE set LockUserID =null,LockSessionID =aCURSESSION  where GENPACKAGEid=aRowID;
     return;
   end if;
 end ;

procedure GENPACKAGE_HCL /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_GENERATOR_TARGET is select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aRowid;
row_GENERATOR_TARGET lch_GENERATOR_TARGET%ROWTYPE;
begin  
--open lch_GENERATOR_TARGET;
for row_GENERATOR_TARGET in lch_GENERATOR_TARGET
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENERATOR_TARGET where GENERATOR_TARGETid=row_GENERATOR_TARGET.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GENERATOR_TARGET;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_GENERATOR_TARGET;
     return;
   end if; 
 end if;  
 GENERATOR_TARGET_HCL (acursession,row_GENERATOR_TARGET.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GENERATOR_TARGET;
   return;
 end if;
end loop;
--close lch_GENERATOR_TARGET;
end;
aIsLocked :=0;
end;

procedure GENPACKAGE_UNLOCK /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GENPACKAGE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENPACKAGE set LockUserID =null  where GENPACKAGEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENPACKAGE set LockSessionID =null  where GENPACKAGEid=aRowID;
     return;
   end if;
 end; 

procedure GENPACKAGE_SINIT /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GENPACKAGE where GENPACKAGEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GENPACKAGE');
    return;
  end if;
if aSecurityStyleID is null then
 GENPACKAGE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GENPACKAGE set securitystyleid =aStyleID where GENPACKAGEid = aRowID;
else 
 update GENPACKAGE set securitystyleid =aSecurityStyleID where GENPACKAGEid = aRowID;
end if; 
end ; 

procedure GENPACKAGE_propagate /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GENPACKAGE where GENPACKAGEid=aRowid;
declare cursor pch_GENERATOR_TARGET  is select GENERATOR_TARGET.GENERATOR_TARGETid ID from GENERATOR_TARGET where  GENERATOR_TARGET.ParentStructRowID = aRowid;
row_GENERATOR_TARGET  pch_GENERATOR_TARGET%ROWTYPE;
begin
--open pch_GENERATOR_TARGET;
for row_GENERATOR_TARGET in pch_GENERATOR_TARGET loop
   GENERATOR_TARGET_SINIT( acursession,row_GENERATOR_TARGET.id,assid);
   GENERATOR_TARGET_propagate( acursession,row_GENERATOR_TARGET.id);
end loop;
--close pch_GENERATOR_TARGET;
end;
end;


procedure GENERATOR_TARGET_BRIEF  (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGENERATOR_TARGETid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GENERATOR_TARGET where GENERATOR_TARGETid=aGENERATOR_TARGETID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GENERATOR_TARGET');
    return;
  end if;
  aBRIEF:=func.GENERATOR_TARGET_BRIEF_F(aGENERATOR_TARGETid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GENERATOR_TARGET_DELETE /*Генераторы*/ (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aGENERATOR_TARGETID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GENERATOR_TARGET',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GENERATOR_TARGET');
      return;
    end if;
  end if;
 --  verify lock  --
 GENERATOR_TARGET_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENERATOR_TARGETid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_GENREFERENCE is select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aGENERATOR_TARGETid;
    child_GENREFERENCE_rec  child_GENREFERENCE%ROWTYPE;
    begin
    --open child_GENREFERENCE;
      for child_GENREFERENCE_rec in child_GENREFERENCE loop
      GENREFERENCE_DELETE (acursession,child_GENREFERENCE_rec.id,aInstanceid);
      end loop;
      --close child_GENREFERENCE;
    end ;
    declare cursor child_GENMANUALCODE is select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aGENERATOR_TARGETid;
    child_GENMANUALCODE_rec  child_GENMANUALCODE%ROWTYPE;
    begin
    --open child_GENMANUALCODE;
      for child_GENMANUALCODE_rec in child_GENMANUALCODE loop
      GENMANUALCODE_DELETE (acursession,child_GENMANUALCODE_rec.id,aInstanceid);
      end loop;
      --close child_GENMANUALCODE;
    end ;
    declare cursor child_GENCONTROLS is select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aGENERATOR_TARGETid;
    child_GENCONTROLS_rec  child_GENCONTROLS%ROWTYPE;
    begin
    --open child_GENCONTROLS;
      for child_GENCONTROLS_rec in child_GENCONTROLS loop
      GENCONTROLS_DELETE (acursession,child_GENCONTROLS_rec.id,aInstanceid);
      end loop;
      --close child_GENCONTROLS;
    end ;
declare cursor chld_GENERATOR_TARGET is select  instanceid ID from instance where OwnerPartName ='GENERATOR_TARGET' and OwnerRowID=aGENERATOR_TARGETid;
row_GENERATOR_TARGET  chld_GENERATOR_TARGET%ROWTYPE;
begin
--open chld_GENERATOR_TARGET;
for row_GENERATOR_TARGET in chld_GENERATOR_TARGET loop
 Kernel.INSTANCE_OWNER (acursession,row_GENERATOR_TARGET.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GENERATOR_TARGET.id);
end loop;
--close chld_GENERATOR_TARGET;
end ;
  delete from  GENERATOR_TARGET 
  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Генераторы*/
procedure GENERATOR_TARGET_SAVE /*Генераторы*/ (
 aCURSESSION CHAR,
 aGENERATOR_TARGETid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTargetType
 NUMBER/* Тип платформы *//* Тип платформы */
,aQueueName
 VARCHAR2 := null /* Очередь *//* Очередь */
,aGeneratorProgID
 VARCHAR2 := null /* COM класс *//* COM класс */
,aGeneratorStyle
 NUMBER := null /* Вариант *//* Вариант */
,aTheDevelopmentEnv
 NUMBER := null /* Среда разработки *//* Среда разработки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENERATOR_TARGET where GENERATOR_TARGETID=aGENERATOR_TARGETID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aGENERATOR_TARGETID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GENERATOR_TARGET',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GENERATOR_TARGET');
      return;
    end if;
  end if;
 --  verify lock  --
 GENERATOR_TARGET_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENERATOR_TARGETid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
 -- update row  --
 update  GENERATOR_TARGET set ChangeStamp=sysdate
,
  Name=aName
,
  TargetType=aTargetType
,
  QueueName=aQueueName
,
  GeneratorProgID=aGeneratorProgID
,
  GeneratorStyle=aGeneratorStyle
,
  TheDevelopmentEnv=aTheDevelopmentEnv
  where  GENERATOR_TARGETID = aGENERATOR_TARGETID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from GENPACKAGE where GENPACKAGEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GENERATOR_TARGET',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GENERATOR_TARGET');
      return;
    end if;
 end if;
 GENPACKAGE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENERATOR_TARGET');
    return;
  end if;
 insert into   GENERATOR_TARGET
 (  GENERATOR_TARGETID 
,ParentStructRowID
,Name

,TargetType

,QueueName

,GeneratorProgID

,GeneratorStyle

,TheDevelopmentEnv

 ) values ( aGENERATOR_TARGETID 
,aParentStructRowID
,aName

,aTargetType

,aQueueName

,aGeneratorProgID

,aGeneratorStyle

,aTheDevelopmentEnv

 ); 
 GENERATOR_TARGET_SINIT( aCURSESSION,aGENERATOR_TARGETid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure GENERATOR_TARGET_PARENT /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from GENERATOR_TARGET where  GENERATOR_TARGETid=aRowID;
  aParentTable := 'GENPACKAGE';
 end; 

procedure GENERATOR_TARGET_ISLOCKED /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENERATOR_TARGET where GENERATOR_TARGETid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GENERATOR_TARGET_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GENERATOR_TARGET_LOCK /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GENERATOR_TARGET_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GENERATOR_TARGET_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GENERATOR_TARGET');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GENERATOR_TARGET set LockUserID =auserID ,LockSessionID =null where GENERATOR_TARGETid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENERATOR_TARGET set LockUserID =null,LockSessionID =aCURSESSION  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
 end ;

procedure GENERATOR_TARGET_HCL /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_GENREFERENCE is select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aRowid;
row_GENREFERENCE lch_GENREFERENCE%ROWTYPE;
begin  
--open lch_GENREFERENCE;
for row_GENREFERENCE in lch_GENREFERENCE
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENREFERENCE where GENREFERENCEid=row_GENREFERENCE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GENREFERENCE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_GENREFERENCE;
     return;
   end if; 
 end if;  
 GENREFERENCE_HCL (acursession,row_GENREFERENCE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GENREFERENCE;
   return;
 end if;
end loop;
--close lch_GENREFERENCE;
end;
declare cursor lch_GENMANUALCODE is select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aRowid;
row_GENMANUALCODE lch_GENMANUALCODE%ROWTYPE;
begin  
--open lch_GENMANUALCODE;
for row_GENMANUALCODE in lch_GENMANUALCODE
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENMANUALCODE where GENMANUALCODEid=row_GENMANUALCODE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GENMANUALCODE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_GENMANUALCODE;
     return;
   end if; 
 end if;  
 GENMANUALCODE_HCL (acursession,row_GENMANUALCODE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GENMANUALCODE;
   return;
 end if;
end loop;
--close lch_GENMANUALCODE;
end;
declare cursor lch_GENCONTROLS is select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aRowid;
row_GENCONTROLS lch_GENCONTROLS%ROWTYPE;
begin  
--open lch_GENCONTROLS;
for row_GENCONTROLS in lch_GENCONTROLS
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GENCONTROLS where GENCONTROLSid=row_GENCONTROLS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GENCONTROLS;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_GENCONTROLS;
     return;
   end if; 
 end if;  
 GENCONTROLS_HCL (acursession,row_GENCONTROLS.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GENCONTROLS;
   return;
 end if;
end loop;
--close lch_GENCONTROLS;
end;
aIsLocked :=0;
end;

procedure GENERATOR_TARGET_UNLOCK /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GENERATOR_TARGET_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENERATOR_TARGET set LockUserID =null  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENERATOR_TARGET set LockSessionID =null  where GENERATOR_TARGETid=aRowID;
     return;
   end if;
 end; 

procedure GENERATOR_TARGET_SINIT /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GENERATOR_TARGET');
    return;
  end if;
if aSecurityStyleID is null then
 GENERATOR_TARGET_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GENERATOR_TARGET set securitystyleid =aStyleID where GENERATOR_TARGETid = aRowID;
else 
 update GENERATOR_TARGET set securitystyleid =aSecurityStyleID where GENERATOR_TARGETid = aRowID;
end if; 
end ; 

procedure GENERATOR_TARGET_propagate /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GENERATOR_TARGET where GENERATOR_TARGETid=aRowid;
declare cursor pch_GENREFERENCE  is select GENREFERENCE.GENREFERENCEid ID from GENREFERENCE where  GENREFERENCE.ParentStructRowID = aRowid;
row_GENREFERENCE  pch_GENREFERENCE%ROWTYPE;
begin
--open pch_GENREFERENCE;
for row_GENREFERENCE in pch_GENREFERENCE loop
   GENREFERENCE_SINIT( acursession,row_GENREFERENCE.id,assid);
   GENREFERENCE_propagate( acursession,row_GENREFERENCE.id);
end loop;
--close pch_GENREFERENCE;
end;
declare cursor pch_GENMANUALCODE  is select GENMANUALCODE.GENMANUALCODEid ID from GENMANUALCODE where  GENMANUALCODE.ParentStructRowID = aRowid;
row_GENMANUALCODE  pch_GENMANUALCODE%ROWTYPE;
begin
--open pch_GENMANUALCODE;
for row_GENMANUALCODE in pch_GENMANUALCODE loop
   GENMANUALCODE_SINIT( acursession,row_GENMANUALCODE.id,assid);
   GENMANUALCODE_propagate( acursession,row_GENMANUALCODE.id);
end loop;
--close pch_GENMANUALCODE;
end;
declare cursor pch_GENCONTROLS  is select GENCONTROLS.GENCONTROLSid ID from GENCONTROLS where  GENCONTROLS.ParentStructRowID = aRowid;
row_GENCONTROLS  pch_GENCONTROLS%ROWTYPE;
begin
--open pch_GENCONTROLS;
for row_GENCONTROLS in pch_GENCONTROLS loop
   GENCONTROLS_SINIT( acursession,row_GENCONTROLS.id,assid);
   GENCONTROLS_propagate( acursession,row_GENCONTROLS.id);
end loop;
--close pch_GENCONTROLS;
end;
end;


procedure GENREFERENCE_BRIEF  (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGENREFERENCEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GENREFERENCE where GENREFERENCEid=aGENREFERENCEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GENREFERENCE');
    return;
  end if;
  aBRIEF:=func.GENREFERENCE_BRIEF_F(aGENREFERENCEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GENREFERENCE_DELETE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GENREFERENCE where GENREFERENCEid=aGENREFERENCEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GENREFERENCE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GENREFERENCE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENREFERENCE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENREFERENCEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENREFERENCE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_GENREFERENCE is select  instanceid ID from instance where OwnerPartName ='GENREFERENCE' and OwnerRowID=aGENREFERENCEid;
row_GENREFERENCE  chld_GENREFERENCE%ROWTYPE;
begin
--open chld_GENREFERENCE;
for row_GENREFERENCE in chld_GENREFERENCE loop
 Kernel.INSTANCE_OWNER (acursession,row_GENREFERENCE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GENREFERENCE.id);
end loop;
--close chld_GENREFERENCE;
end ;
  delete from  GENREFERENCE 
  where  GENREFERENCEID = aGENREFERENCEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Библиотеки*/
procedure GENREFERENCE_SAVE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aGENREFERENCEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aRefClassID
 VARCHAR2 := null /* Класс ссылки *//* Класс ссылки */
,aVersionMajor
 NUMBER := null /* Номер версии *//* Номер версии */
,aVersionMinor
 NUMBER := null /* Подверсия *//* Подверсия */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENREFERENCE where GENREFERENCEID=aGENREFERENCEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GENREFERENCE where GENREFERENCEid=aGENREFERENCEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GENREFERENCE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GENREFERENCE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENREFERENCE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENREFERENCEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENREFERENCE');
    return;
  end if;
 -- update row  --
 update  GENREFERENCE set ChangeStamp=sysdate
,
  Name=aName
,
  RefClassID=aRefClassID
,
  VersionMajor=aVersionMajor
,
  VersionMinor=aVersionMinor
  where  GENREFERENCEID = aGENREFERENCEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GENREFERENCE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GENREFERENCE');
      return;
    end if;
 end if;
 GENERATOR_TARGET_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENREFERENCE');
    return;
  end if;
 insert into   GENREFERENCE
 (  GENREFERENCEID 
,ParentStructRowID
,Name

,RefClassID

,VersionMajor

,VersionMinor

 ) values ( aGENREFERENCEID 
,aParentStructRowID
,aName

,aRefClassID

,aVersionMajor

,aVersionMinor

 ); 
 GENREFERENCE_SINIT( aCURSESSION,aGENREFERENCEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure GENREFERENCE_PARENT /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from GENREFERENCE where  GENREFERENCEid=aRowID;
  aParentTable := 'GENERATOR_TARGET';
 end; 

procedure GENREFERENCE_ISLOCKED /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENREFERENCE where GENREFERENCEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GENREFERENCE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GENREFERENCE_LOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GENREFERENCE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GENREFERENCE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GENREFERENCE where GENREFERENCEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GENREFERENCE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GENREFERENCE set LockUserID =auserID ,LockSessionID =null where GENREFERENCEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENREFERENCE set LockUserID =null,LockSessionID =aCURSESSION  where GENREFERENCEid=aRowID;
     return;
   end if;
 end ;

procedure GENREFERENCE_HCL /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure GENREFERENCE_UNLOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GENREFERENCE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENREFERENCE set LockUserID =null  where GENREFERENCEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENREFERENCE set LockSessionID =null  where GENREFERENCEid=aRowID;
     return;
   end if;
 end; 

procedure GENREFERENCE_SINIT /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GENREFERENCE where GENREFERENCEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GENREFERENCE');
    return;
  end if;
if aSecurityStyleID is null then
 GENREFERENCE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GENREFERENCE set securitystyleid =aStyleID where GENREFERENCEid = aRowID;
else 
 update GENREFERENCE set securitystyleid =aSecurityStyleID where GENREFERENCEid = aRowID;
end if; 
end ; 

procedure GENREFERENCE_propagate /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GENREFERENCE where GENREFERENCEid=aRowid;
end;


procedure GENMANUALCODE_BRIEF  (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGENMANUALCODEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GENMANUALCODE where GENMANUALCODEid=aGENMANUALCODEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GENMANUALCODE');
    return;
  end if;
  aBRIEF:=func.GENMANUALCODE_BRIEF_F(aGENMANUALCODEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GENMANUALCODE_DELETE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GENMANUALCODE where GENMANUALCODEid=aGENMANUALCODEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GENMANUALCODE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GENMANUALCODE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENMANUALCODE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENMANUALCODEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENMANUALCODE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_GENMANUALCODE is select  instanceid ID from instance where OwnerPartName ='GENMANUALCODE' and OwnerRowID=aGENMANUALCODEid;
row_GENMANUALCODE  chld_GENMANUALCODE%ROWTYPE;
begin
--open chld_GENMANUALCODE;
for row_GENMANUALCODE in chld_GENMANUALCODE loop
 Kernel.INSTANCE_OWNER (acursession,row_GENMANUALCODE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GENMANUALCODE.id);
end loop;
--close chld_GENMANUALCODE;
end ;
  delete from  GENMANUALCODE 
  where  GENMANUALCODEID = aGENMANUALCODEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ручной код*/
procedure GENMANUALCODE_SAVE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aGENMANUALCODEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,aCode VARCHAR2/* Код *//* Код */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENMANUALCODE where GENMANUALCODEID=aGENMANUALCODEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GENMANUALCODE where GENMANUALCODEid=aGENMANUALCODEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GENMANUALCODE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GENMANUALCODE');
      return;
    end if;
  end if;
 --  verify lock  --
 GENMANUALCODE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENMANUALCODEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENMANUALCODE');
    return;
  end if;
 -- update row  --
 update  GENMANUALCODE set ChangeStamp=sysdate
,
  Name=aName
,
  the_Alias=athe_Alias
,
  Code=aCode
  where  GENMANUALCODEID = aGENMANUALCODEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GENMANUALCODE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GENMANUALCODE');
      return;
    end if;
 end if;
 GENERATOR_TARGET_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENMANUALCODE');
    return;
  end if;
 insert into   GENMANUALCODE
 (  GENMANUALCODEID 
,ParentStructRowID
,Name

,the_Alias

,Code

 ) values ( aGENMANUALCODEID 
,aParentStructRowID
,aName

,athe_Alias

,aCode

 ); 
 GENMANUALCODE_SINIT( aCURSESSION,aGENMANUALCODEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure GENMANUALCODE_PARENT /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from GENMANUALCODE where  GENMANUALCODEid=aRowID;
  aParentTable := 'GENERATOR_TARGET';
 end; 

procedure GENMANUALCODE_ISLOCKED /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENMANUALCODE where GENMANUALCODEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GENMANUALCODE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GENMANUALCODE_LOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GENMANUALCODE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GENMANUALCODE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GENMANUALCODE where GENMANUALCODEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GENMANUALCODE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GENMANUALCODE set LockUserID =auserID ,LockSessionID =null where GENMANUALCODEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENMANUALCODE set LockUserID =null,LockSessionID =aCURSESSION  where GENMANUALCODEid=aRowID;
     return;
   end if;
 end ;

procedure GENMANUALCODE_HCL /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure GENMANUALCODE_UNLOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GENMANUALCODE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENMANUALCODE set LockUserID =null  where GENMANUALCODEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENMANUALCODE set LockSessionID =null  where GENMANUALCODEid=aRowID;
     return;
   end if;
 end; 

procedure GENMANUALCODE_SINIT /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GENMANUALCODE where GENMANUALCODEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GENMANUALCODE');
    return;
  end if;
if aSecurityStyleID is null then
 GENMANUALCODE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GENMANUALCODE set securitystyleid =aStyleID where GENMANUALCODEid = aRowID;
else 
 update GENMANUALCODE set securitystyleid =aSecurityStyleID where GENMANUALCODEid = aRowID;
end if; 
end ; 

procedure GENMANUALCODE_propagate /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GENMANUALCODE where GENMANUALCODEid=aRowid;
end;


procedure GENCONTROLS_BRIEF  (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGENCONTROLSid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GENCONTROLS where GENCONTROLSid=aGENCONTROLSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GENCONTROLS');
    return;
  end if;
  aBRIEF:=func.GENCONTROLS_BRIEF_F(aGENCONTROLSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GENCONTROLS_DELETE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GENCONTROLS where GENCONTROLSid=aGENCONTROLSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GENCONTROLS',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GENCONTROLS');
      return;
    end if;
  end if;
 --  verify lock  --
 GENCONTROLS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENCONTROLSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GENCONTROLS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_GENCONTROLS is select  instanceid ID from instance where OwnerPartName ='GENCONTROLS' and OwnerRowID=aGENCONTROLSid;
row_GENCONTROLS  chld_GENCONTROLS%ROWTYPE;
begin
--open chld_GENCONTROLS;
for row_GENCONTROLS in chld_GENCONTROLS loop
 Kernel.INSTANCE_OWNER (acursession,row_GENCONTROLS.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GENCONTROLS.id);
end loop;
--close chld_GENCONTROLS;
end ;
  delete from  GENCONTROLS 
  where  GENCONTROLSID = aGENCONTROLSID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Контрольные элементы*/
procedure GENCONTROLS_SAVE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aGENCONTROLSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aControlProgID
 VARCHAR2/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,aControlClassID
 VARCHAR2 := null /* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aVersionMajor
 NUMBER := null /* Версия *//* Версия */
,aVersionMinor
 NUMBER := null /* Подверсия *//* Подверсия */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GENCONTROLS where GENCONTROLSID=aGENCONTROLSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GENCONTROLS where GENCONTROLSid=aGENCONTROLSID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GENCONTROLS',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GENCONTROLS');
      return;
    end if;
  end if;
 --  verify lock  --
 GENCONTROLS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGENCONTROLSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENCONTROLS');
    return;
  end if;
 -- update row  --
 update  GENCONTROLS set ChangeStamp=sysdate
,
  ControlProgID=aControlProgID
,
  ControlClassID=aControlClassID
,
  VersionMajor=aVersionMajor
,
  VersionMinor=aVersionMinor
  where  GENCONTROLSID = aGENCONTROLSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from GENERATOR_TARGET where GENERATOR_TARGETid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GENCONTROLS',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GENCONTROLS');
      return;
    end if;
 end if;
 GENERATOR_TARGET_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GENCONTROLS');
    return;
  end if;
 insert into   GENCONTROLS
 (  GENCONTROLSID 
,ParentStructRowID
,ControlProgID

,ControlClassID

,VersionMajor

,VersionMinor

 ) values ( aGENCONTROLSID 
,aParentStructRowID
,aControlProgID

,aControlClassID

,aVersionMajor

,aVersionMinor

 ); 
 GENCONTROLS_SINIT( aCURSESSION,aGENCONTROLSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure GENCONTROLS_PARENT /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from GENCONTROLS where  GENCONTROLSid=aRowID;
  aParentTable := 'GENERATOR_TARGET';
 end; 

procedure GENCONTROLS_ISLOCKED /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GENCONTROLS where GENCONTROLSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GENCONTROLS_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GENCONTROLS_LOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GENCONTROLS_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GENCONTROLS_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GENCONTROLS where GENCONTROLSid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GENCONTROLS');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GENCONTROLS set LockUserID =auserID ,LockSessionID =null where GENCONTROLSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GENCONTROLS set LockUserID =null,LockSessionID =aCURSESSION  where GENCONTROLSid=aRowID;
     return;
   end if;
 end ;

procedure GENCONTROLS_HCL /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure GENCONTROLS_UNLOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GENCONTROLS_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GENCONTROLS set LockUserID =null  where GENCONTROLSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GENCONTROLS set LockSessionID =null  where GENCONTROLSid=aRowID;
     return;
   end if;
 end; 

procedure GENCONTROLS_SINIT /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GENCONTROLS where GENCONTROLSid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GENCONTROLS');
    return;
  end if;
if aSecurityStyleID is null then
 GENCONTROLS_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GENCONTROLS set securitystyleid =aStyleID where GENCONTROLSid = aRowID;
else 
 update GENCONTROLS set securitystyleid =aSecurityStyleID where GENCONTROLSid = aRowID;
end if; 
end ; 

procedure GENCONTROLS_propagate /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GENCONTROLS where GENCONTROLSid=aRowid;
end;


procedure LocalizeInfo_BRIEF  (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aLocalizeInfoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from LocalizeInfo where LocalizeInfoid=aLocalizeInfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=LocalizeInfo');
    return;
  end if;
  aBRIEF:=func.LocalizeInfo_BRIEF_F(aLocalizeInfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure LocalizeInfo_DELETE /**/ (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from LocalizeInfo where LocalizeInfoid=aLocalizeInfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:LocalizeInfo',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=LocalizeInfo');
      return;
    end if;
  end if;
 --  verify lock  --
 LocalizeInfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aLocalizeInfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=LocalizeInfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_LocalizeInfo is select  instanceid ID from instance where OwnerPartName ='LocalizeInfo' and OwnerRowID=aLocalizeInfoid;
row_LocalizeInfo  chld_LocalizeInfo%ROWTYPE;
begin
--open chld_LocalizeInfo;
for row_LocalizeInfo in chld_LocalizeInfo loop
 Kernel.INSTANCE_OWNER (acursession,row_LocalizeInfo.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_LocalizeInfo.id);
end loop;
--close chld_LocalizeInfo;
end ;
  delete from  LocalizeInfo 
  where  LocalizeInfoID = aLocalizeInfoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Локализация*/
procedure LocalizeInfo_SAVE /**/ (
 aCURSESSION CHAR,
 aLocalizeInfoid CHAR,
aInstanceID CHAR 
,aLangFull
 VARCHAR2/* Язык - название *//* Язык - название */
,aLangShort
 VARCHAR2/* Код языка *//* Код языка */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from LocalizeInfo where LocalizeInfoID=aLocalizeInfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from LocalizeInfo where LocalizeInfoid=aLocalizeInfoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:LocalizeInfo',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=LocalizeInfo');
      return;
    end if;
  end if;
 --  verify lock  --
 LocalizeInfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aLocalizeInfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LocalizeInfo');
    return;
  end if;
 -- update row  --
 update  LocalizeInfo set ChangeStamp=sysdate
,
  LangFull=aLangFull
,
  LangShort=aLangShort
  where  LocalizeInfoID = aLocalizeInfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:LocalizeInfo',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=LocalizeInfo');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=LocalizeInfo');
    return;
  end if;
 insert into   LocalizeInfo
 (  LocalizeInfoID 
,InstanceID
,LangFull

,LangShort

 ) values ( aLocalizeInfoID 
,aInstanceID
,aLangFull

,aLangShort

 ); 
 LocalizeInfo_SINIT( aCURSESSION,aLocalizeInfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure LocalizeInfo_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from LocalizeInfo where  LocalizeInfoid=aRowID;
 end; 

procedure LocalizeInfo_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from LocalizeInfo where LocalizeInfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  LocalizeInfo_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure LocalizeInfo_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 LocalizeInfo_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  LocalizeInfo_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from LocalizeInfo where LocalizeInfoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=LocalizeInfo');
    return;
  end if;
   if  aLockMode =2  
   then   
    update LocalizeInfo set LockUserID =auserID ,LockSessionID =null where LocalizeInfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update LocalizeInfo set LockUserID =null,LockSessionID =aCURSESSION  where LocalizeInfoid=aRowID;
     return;
   end if;
 end ;

procedure LocalizeInfo_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure LocalizeInfo_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 LocalizeInfo_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update LocalizeInfo set LockUserID =null  where LocalizeInfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update LocalizeInfo set LockSessionID =null  where LocalizeInfoid=aRowID;
     return;
   end if;
 end; 

procedure LocalizeInfo_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from LocalizeInfo where LocalizeInfoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =LocalizeInfo');
    return;
  end if;
if aSecurityStyleID is null then
 LocalizeInfo_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update LocalizeInfo set securitystyleid =aStyleID where LocalizeInfoid = aRowID;
else 
 update LocalizeInfo set securitystyleid =aSecurityStyleID where LocalizeInfoid = aRowID;
end if; 
end ; 

procedure LocalizeInfo_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from LocalizeInfo where LocalizeInfoid=aRowid;
end;


procedure FIELDTYPE_BRIEF  (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDTYPEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDTYPE where FIELDTYPEid=aFIELDTYPEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDTYPE');
    return;
  end if;
  aBRIEF:=func.FIELDTYPE_BRIEF_F(aFIELDTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDTYPE_DELETE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aFIELDTYPEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDTYPE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDTYPE');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDTYPE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDTYPEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ENUMITEM is select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aFIELDTYPEid;
    child_ENUMITEM_rec  child_ENUMITEM%ROWTYPE;
    begin
    --open child_ENUMITEM;
      for child_ENUMITEM_rec in child_ENUMITEM loop
      ENUMITEM_DELETE (acursession,child_ENUMITEM_rec.id,aInstanceid);
      end loop;
      --close child_ENUMITEM;
    end ;
    declare cursor child_FIELDTYPEMAP is select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aFIELDTYPEid;
    child_FIELDTYPEMAP_rec  child_FIELDTYPEMAP%ROWTYPE;
    begin
    --open child_FIELDTYPEMAP;
      for child_FIELDTYPEMAP_rec in child_FIELDTYPEMAP loop
      FIELDTYPEMAP_DELETE (acursession,child_FIELDTYPEMAP_rec.id,aInstanceid);
      end loop;
      --close child_FIELDTYPEMAP;
    end ;
declare cursor chld_FIELDTYPE is select  instanceid ID from instance where OwnerPartName ='FIELDTYPE' and OwnerRowID=aFIELDTYPEid;
row_FIELDTYPE  chld_FIELDTYPE%ROWTYPE;
begin
--open chld_FIELDTYPE;
for row_FIELDTYPE in chld_FIELDTYPE loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDTYPE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDTYPE.id);
end loop;
--close chld_FIELDTYPE;
end ;
  delete from  FIELDTYPE 
  where  FIELDTYPEID = aFIELDTYPEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип поля*/
procedure FIELDTYPE_SAVE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aFIELDTYPEid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTypeStyle
 NUMBER/* Трактовка *//* Трактовка */
,athe_Comment VARCHAR2 := null /* Описание *//* Описание */
,aAllowSize
 NUMBER/* Нужен размер *//* Нужен размер */
,aMinimum
 VARCHAR2 := null /* Минимум *//* Минимум */
,aMaximum
 VARCHAR2 := null /* Максимум *//* Максимум */
,aAllowLikeSearch
 NUMBER/* Поиск текста *//* Поиск текста */
,aGridSortType
 NUMBER := null /* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
,aDelayedSave
 NUMBER/* Отложенное сохранение *//* Отложенное сохранение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDTYPE where FIELDTYPEID=aFIELDTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aFIELDTYPEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDTYPE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDTYPE');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDTYPE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDTYPEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPE');
    return;
  end if;
 -- update row  --
 update  FIELDTYPE set ChangeStamp=sysdate
,
  Name=aName
,
  TypeStyle=aTypeStyle
,
  the_Comment=athe_Comment
,
  AllowSize=aAllowSize
,
  Minimum=aMinimum
,
  Maximum=aMaximum
,
  AllowLikeSearch=aAllowLikeSearch
,
  GridSortType=aGridSortType
,
  DelayedSave=aDelayedSave
  where  FIELDTYPEID = aFIELDTYPEID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELDTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELDTYPE');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDTYPE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDTYPE');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPE');
    return;
  end if;
 insert into   FIELDTYPE
 (  FIELDTYPEID 
,InstanceID
,Name

,TypeStyle

,the_Comment

,AllowSize

,Minimum

,Maximum

,AllowLikeSearch

,GridSortType

,DelayedSave

 ) values ( aFIELDTYPEID 
,aInstanceID
,aName

,aTypeStyle

,athe_Comment

,aAllowSize

,aMinimum

,aMaximum

,aAllowLikeSearch

,aGridSortType

,aDelayedSave

 ); 
 FIELDTYPE_SINIT( aCURSESSION,aFIELDTYPEid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELDTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELDTYPE');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure FIELDTYPE_PARENT /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from FIELDTYPE where  FIELDTYPEid=aRowID;
 end; 

procedure FIELDTYPE_ISLOCKED /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDTYPE where FIELDTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDTYPE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDTYPE_LOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDTYPE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDTYPE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDTYPE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDTYPE set LockUserID =auserID ,LockSessionID =null where FIELDTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDTYPE set LockUserID =null,LockSessionID =aCURSESSION  where FIELDTYPEid=aRowID;
     return;
   end if;
 end ;

procedure FIELDTYPE_HCL /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ENUMITEM is select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aRowid;
row_ENUMITEM lch_ENUMITEM%ROWTYPE;
begin  
--open lch_ENUMITEM;
for row_ENUMITEM in lch_ENUMITEM
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ENUMITEM where ENUMITEMid=row_ENUMITEM.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ENUMITEM;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ENUMITEM;
     return;
   end if; 
 end if;  
 ENUMITEM_HCL (acursession,row_ENUMITEM.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ENUMITEM;
   return;
 end if;
end loop;
--close lch_ENUMITEM;
end;
declare cursor lch_FIELDTYPEMAP is select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aRowid;
row_FIELDTYPEMAP lch_FIELDTYPEMAP%ROWTYPE;
begin  
--open lch_FIELDTYPEMAP;
for row_FIELDTYPEMAP in lch_FIELDTYPEMAP
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDTYPEMAP where FIELDTYPEMAPid=row_FIELDTYPEMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDTYPEMAP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDTYPEMAP;
     return;
   end if; 
 end if;  
 FIELDTYPEMAP_HCL (acursession,row_FIELDTYPEMAP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDTYPEMAP;
   return;
 end if;
end loop;
--close lch_FIELDTYPEMAP;
end;
aIsLocked :=0;
end;

procedure FIELDTYPE_UNLOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDTYPE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDTYPE set LockUserID =null  where FIELDTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDTYPE set LockSessionID =null  where FIELDTYPEid=aRowID;
     return;
   end if;
 end; 

procedure FIELDTYPE_SINIT /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDTYPE');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDTYPE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDTYPE set securitystyleid =aStyleID where FIELDTYPEid = aRowID;
else 
 update FIELDTYPE set securitystyleid =aSecurityStyleID where FIELDTYPEid = aRowID;
end if; 
end ; 

procedure FIELDTYPE_propagate /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDTYPE where FIELDTYPEid=aRowid;
declare cursor pch_ENUMITEM  is select ENUMITEM.ENUMITEMid ID from ENUMITEM where  ENUMITEM.ParentStructRowID = aRowid;
row_ENUMITEM  pch_ENUMITEM%ROWTYPE;
begin
--open pch_ENUMITEM;
for row_ENUMITEM in pch_ENUMITEM loop
   ENUMITEM_SINIT( acursession,row_ENUMITEM.id,assid);
   ENUMITEM_propagate( acursession,row_ENUMITEM.id);
end loop;
--close pch_ENUMITEM;
end;
declare cursor pch_FIELDTYPEMAP  is select FIELDTYPEMAP.FIELDTYPEMAPid ID from FIELDTYPEMAP where  FIELDTYPEMAP.ParentStructRowID = aRowid;
row_FIELDTYPEMAP  pch_FIELDTYPEMAP%ROWTYPE;
begin
--open pch_FIELDTYPEMAP;
for row_FIELDTYPEMAP in pch_FIELDTYPEMAP loop
   FIELDTYPEMAP_SINIT( acursession,row_FIELDTYPEMAP.id,assid);
   FIELDTYPEMAP_propagate( acursession,row_FIELDTYPEMAP.id);
end loop;
--close pch_FIELDTYPEMAP;
end;
end;


procedure ENUMITEM_BRIEF  (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aENUMITEMid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ENUMITEM where ENUMITEMid=aENUMITEMID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ENUMITEM');
    return;
  end if;
  aBRIEF:=func.ENUMITEM_BRIEF_F(aENUMITEMid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ENUMITEM_DELETE /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ENUMITEM where ENUMITEMid=aENUMITEMID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ENUMITEM',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ENUMITEM');
      return;
    end if;
  end if;
 --  verify lock  --
 ENUMITEM_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aENUMITEMid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ENUMITEM');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ENUMITEM is select  instanceid ID from instance where OwnerPartName ='ENUMITEM' and OwnerRowID=aENUMITEMid;
row_ENUMITEM  chld_ENUMITEM%ROWTYPE;
begin
--open chld_ENUMITEM;
for row_ENUMITEM in chld_ENUMITEM loop
 Kernel.INSTANCE_OWNER (acursession,row_ENUMITEM.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ENUMITEM.id);
end loop;
--close chld_ENUMITEM;
end ;
  delete from  ENUMITEM 
  where  ENUMITEMID = aENUMITEMID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Зачения*/
procedure ENUMITEM_SAVE /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aENUMITEMid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aNameValue
 NUMBER/* Значение *//* Значение */
,aNameInCode
 VARCHAR2 := null /* Название в коде *//* Название в коде */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ENUMITEM where ENUMITEMID=aENUMITEMID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ENUMITEM where ENUMITEMid=aENUMITEMID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ENUMITEM',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ENUMITEM');
      return;
    end if;
  end if;
 --  verify lock  --
 ENUMITEM_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aENUMITEMid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ENUMITEM');
    return;
  end if;
 -- update row  --
 update  ENUMITEM set ChangeStamp=sysdate
,
  Name=aName
,
  NameValue=aNameValue
,
  NameInCode=aNameInCode
  where  ENUMITEMID = aENUMITEMID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and NameValue=aNameValue;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;
select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ENUMITEM',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ENUMITEM');
      return;
    end if;
 end if;
 FIELDTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ENUMITEM');
    return;
  end if;
 insert into   ENUMITEM
 (  ENUMITEMID 
,ParentStructRowID
,Name

,NameValue

,NameInCode

 ) values ( aENUMITEMID 
,aParentStructRowID
,aName

,aNameValue

,aNameInCode

 ); 
 ENUMITEM_SINIT( aCURSESSION,aENUMITEMid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and NameValue=aNameValue;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;
select Count(*) into aUniqueRowCount from ENUMITEM where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ENUMITEM');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ENUMITEM_PARENT /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ENUMITEM where  ENUMITEMid=aRowID;
  aParentTable := 'FIELDTYPE';
 end; 

procedure ENUMITEM_ISLOCKED /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ENUMITEM where ENUMITEMid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ENUMITEM_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ENUMITEM_LOCK /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ENUMITEM_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ENUMITEM_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ENUMITEM where ENUMITEMid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ENUMITEM');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ENUMITEM set LockUserID =auserID ,LockSessionID =null where ENUMITEMid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ENUMITEM set LockUserID =null,LockSessionID =aCURSESSION  where ENUMITEMid=aRowID;
     return;
   end if;
 end ;

procedure ENUMITEM_HCL /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ENUMITEM_UNLOCK /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ENUMITEM_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ENUMITEM set LockUserID =null  where ENUMITEMid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ENUMITEM set LockSessionID =null  where ENUMITEMid=aRowID;
     return;
   end if;
 end; 

procedure ENUMITEM_SINIT /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ENUMITEM where ENUMITEMid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ENUMITEM');
    return;
  end if;
if aSecurityStyleID is null then
 ENUMITEM_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ENUMITEM set securitystyleid =aStyleID where ENUMITEMid = aRowID;
else 
 update ENUMITEM set securitystyleid =aSecurityStyleID where ENUMITEMid = aRowID;
end if; 
end ; 

procedure ENUMITEM_propagate /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ENUMITEM where ENUMITEMid=aRowid;
end;


procedure FIELDTYPEMAP_BRIEF  (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDTYPEMAPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDTYPEMAP where FIELDTYPEMAPid=aFIELDTYPEMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDTYPEMAP');
    return;
  end if;
  aBRIEF:=func.FIELDTYPEMAP_BRIEF_F(aFIELDTYPEMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDTYPEMAP_DELETE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDTYPEMAP where FIELDTYPEMAPid=aFIELDTYPEMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDTYPEMAP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDTYPEMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDTYPEMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDTYPEMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDTYPEMAP is select  instanceid ID from instance where OwnerPartName ='FIELDTYPEMAP' and OwnerRowID=aFIELDTYPEMAPid;
row_FIELDTYPEMAP  chld_FIELDTYPEMAP%ROWTYPE;
begin
--open chld_FIELDTYPEMAP;
for row_FIELDTYPEMAP in chld_FIELDTYPEMAP loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDTYPEMAP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDTYPEMAP.id);
end loop;
--close chld_FIELDTYPEMAP;
end ;
  delete from  FIELDTYPEMAP 
  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение*/
procedure FIELDTYPEMAP_SAVE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aFIELDTYPEMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aStoageType
 VARCHAR2/* Тип хранения *//* Тип хранения */
,aFixedSize
 NUMBER := null /* Размер *//* Размер */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDTYPEMAP where FIELDTYPEMAPID=aFIELDTYPEMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDTYPEMAP where FIELDTYPEMAPid=aFIELDTYPEMAPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDTYPEMAP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDTYPEMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDTYPEMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDTYPEMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
 -- update row  --
 update  FIELDTYPEMAP set ChangeStamp=sysdate
,
  Target=aTarget
,
  StoageType=aStoageType
,
  FixedSize=aFixedSize
  where  FIELDTYPEMAPID = aFIELDTYPEMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELDTYPE where FIELDTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDTYPEMAP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDTYPEMAP');
      return;
    end if;
 end if;
 FIELDTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDTYPEMAP');
    return;
  end if;
 insert into   FIELDTYPEMAP
 (  FIELDTYPEMAPID 
,ParentStructRowID
,Target

,StoageType

,FixedSize

 ) values ( aFIELDTYPEMAPID 
,aParentStructRowID
,aTarget

,aStoageType

,aFixedSize

 ); 
 FIELDTYPEMAP_SINIT( aCURSESSION,aFIELDTYPEMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDTYPEMAP_PARENT /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDTYPEMAP where  FIELDTYPEMAPid=aRowID;
  aParentTable := 'FIELDTYPE';
 end; 

procedure FIELDTYPEMAP_ISLOCKED /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDTYPEMAP where FIELDTYPEMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDTYPEMAP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDTYPEMAP_LOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDTYPEMAP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDTYPEMAP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDTYPEMAP where FIELDTYPEMAPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDTYPEMAP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDTYPEMAP set LockUserID =auserID ,LockSessionID =null where FIELDTYPEMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDTYPEMAP set LockUserID =null,LockSessionID =aCURSESSION  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
 end ;

procedure FIELDTYPEMAP_HCL /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDTYPEMAP_UNLOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDTYPEMAP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDTYPEMAP set LockUserID =null  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDTYPEMAP set LockSessionID =null  where FIELDTYPEMAPid=aRowID;
     return;
   end if;
 end; 

procedure FIELDTYPEMAP_SINIT /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDTYPEMAP where FIELDTYPEMAPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDTYPEMAP');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDTYPEMAP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDTYPEMAP set securitystyleid =aStyleID where FIELDTYPEMAPid = aRowID;
else 
 update FIELDTYPEMAP set securitystyleid =aSecurityStyleID where FIELDTYPEMAPid = aRowID;
end if; 
end ; 

procedure FIELDTYPEMAP_propagate /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDTYPEMAP where FIELDTYPEMAPid=aRowid;
end;


procedure SHAREDMETHOD_BRIEF  (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aSHAREDMETHODid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from SHAREDMETHOD where SHAREDMETHODid=aSHAREDMETHODID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=SHAREDMETHOD');
    return;
  end if;
  aBRIEF:=func.SHAREDMETHOD_BRIEF_F(aSHAREDMETHODid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure SHAREDMETHOD_DELETE /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from SHAREDMETHOD where SHAREDMETHODid=aSHAREDMETHODID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:SHAREDMETHOD',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=SHAREDMETHOD');
      return;
    end if;
  end if;
 --  verify lock  --
 SHAREDMETHOD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSHAREDMETHODid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SHAREDMETHOD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_SCRIPT is select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aSHAREDMETHODid;
    child_SCRIPT_rec  child_SCRIPT%ROWTYPE;
    begin
    --open child_SCRIPT;
      for child_SCRIPT_rec in child_SCRIPT loop
      SCRIPT_DELETE (acursession,child_SCRIPT_rec.id,aInstanceid);
      end loop;
      --close child_SCRIPT;
    end ;
declare cursor chld_SHAREDMETHOD is select  instanceid ID from instance where OwnerPartName ='SHAREDMETHOD' and OwnerRowID=aSHAREDMETHODid;
row_SHAREDMETHOD  chld_SHAREDMETHOD%ROWTYPE;
begin
--open chld_SHAREDMETHOD;
for row_SHAREDMETHOD in chld_SHAREDMETHOD loop
 Kernel.INSTANCE_OWNER (acursession,row_SHAREDMETHOD.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_SHAREDMETHOD.id);
end loop;
--close chld_SHAREDMETHOD;
end ;
  delete from  SHAREDMETHOD 
  where  SHAREDMETHODID = aSHAREDMETHODID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы и процедуры*/
procedure SHAREDMETHOD_SAVE /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aSHAREDMETHODid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Comment VARCHAR2 := null /* Описание метода *//* Описание метода */
,aReturnType CHAR := null /* Возвращаемый тип *//* Возвращаемый тип */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SHAREDMETHOD where SHAREDMETHODID=aSHAREDMETHODID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from SHAREDMETHOD where SHAREDMETHODid=aSHAREDMETHODID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:SHAREDMETHOD',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=SHAREDMETHOD');
      return;
    end if;
  end if;
 --  verify lock  --
 SHAREDMETHOD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSHAREDMETHODid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SHAREDMETHOD');
    return;
  end if;
 -- update row  --
 update  SHAREDMETHOD set ChangeStamp=sysdate
,
  Name=aName
,
  the_Comment=athe_Comment
,
  ReturnType=aReturnType
  where  SHAREDMETHODID = aSHAREDMETHODID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from SHAREDMETHOD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=SHAREDMETHOD');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:SHAREDMETHOD',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=SHAREDMETHOD');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SHAREDMETHOD');
    return;
  end if;
 insert into   SHAREDMETHOD
 (  SHAREDMETHODID 
,InstanceID
,Name

,the_Comment

,ReturnType

 ) values ( aSHAREDMETHODID 
,aInstanceID
,aName

,athe_Comment

,aReturnType

 ); 
 SHAREDMETHOD_SINIT( aCURSESSION,aSHAREDMETHODid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from SHAREDMETHOD where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=SHAREDMETHOD');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure SHAREDMETHOD_PARENT /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from SHAREDMETHOD where  SHAREDMETHODid=aRowID;
 end; 

procedure SHAREDMETHOD_ISLOCKED /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SHAREDMETHOD where SHAREDMETHODid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  SHAREDMETHOD_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure SHAREDMETHOD_LOCK /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 SHAREDMETHOD_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  SHAREDMETHOD_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from SHAREDMETHOD where SHAREDMETHODid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=SHAREDMETHOD');
    return;
  end if;
   if  aLockMode =2  
   then   
    update SHAREDMETHOD set LockUserID =auserID ,LockSessionID =null where SHAREDMETHODid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SHAREDMETHOD set LockUserID =null,LockSessionID =aCURSESSION  where SHAREDMETHODid=aRowID;
     return;
   end if;
 end ;

procedure SHAREDMETHOD_HCL /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_SCRIPT is select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aRowid;
row_SCRIPT lch_SCRIPT%ROWTYPE;
begin  
--open lch_SCRIPT;
for row_SCRIPT in lch_SCRIPT
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from SCRIPT where SCRIPTid=row_SCRIPT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_SCRIPT;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_SCRIPT;
     return;
   end if; 
 end if;  
 SCRIPT_HCL (acursession,row_SCRIPT.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_SCRIPT;
   return;
 end if;
end loop;
--close lch_SCRIPT;
end;
aIsLocked :=0;
end;

procedure SHAREDMETHOD_UNLOCK /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 SHAREDMETHOD_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SHAREDMETHOD set LockUserID =null  where SHAREDMETHODid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SHAREDMETHOD set LockSessionID =null  where SHAREDMETHODid=aRowID;
     return;
   end if;
 end; 

procedure SHAREDMETHOD_SINIT /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from SHAREDMETHOD where SHAREDMETHODid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =SHAREDMETHOD');
    return;
  end if;
if aSecurityStyleID is null then
 SHAREDMETHOD_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update SHAREDMETHOD set securitystyleid =aStyleID where SHAREDMETHODid = aRowID;
else 
 update SHAREDMETHOD set securitystyleid =aSecurityStyleID where SHAREDMETHODid = aRowID;
end if; 
end ; 

procedure SHAREDMETHOD_propagate /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from SHAREDMETHOD where SHAREDMETHODid=aRowid;
declare cursor pch_SCRIPT  is select SCRIPT.SCRIPTid ID from SCRIPT where  SCRIPT.ParentStructRowID = aRowid;
row_SCRIPT  pch_SCRIPT%ROWTYPE;
begin
--open pch_SCRIPT;
for row_SCRIPT in pch_SCRIPT loop
   SCRIPT_SINIT( acursession,row_SCRIPT.id,assid);
   SCRIPT_propagate( acursession,row_SCRIPT.id);
end loop;
--close pch_SCRIPT;
end;
end;


procedure SCRIPT_BRIEF  (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aSCRIPTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from SCRIPT where SCRIPTid=aSCRIPTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=SCRIPT');
    return;
  end if;
  aBRIEF:=func.SCRIPT_BRIEF_F(aSCRIPTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure SCRIPT_DELETE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from SCRIPT where SCRIPTid=aSCRIPTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:SCRIPT',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=SCRIPT');
      return;
    end if;
  end if;
 --  verify lock  --
 SCRIPT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSCRIPTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SCRIPT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_PARAMETERS is select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aSCRIPTid;
    child_PARAMETERS_rec  child_PARAMETERS%ROWTYPE;
    begin
    --open child_PARAMETERS;
      for child_PARAMETERS_rec in child_PARAMETERS loop
      PARAMETERS_DELETE (acursession,child_PARAMETERS_rec.id,aInstanceid);
      end loop;
      --close child_PARAMETERS;
    end ;
declare cursor chld_SCRIPT is select  instanceid ID from instance where OwnerPartName ='SCRIPT' and OwnerRowID=aSCRIPTid;
row_SCRIPT  chld_SCRIPT%ROWTYPE;
begin
--open chld_SCRIPT;
for row_SCRIPT in chld_SCRIPT loop
 Kernel.INSTANCE_OWNER (acursession,row_SCRIPT.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_SCRIPT.id);
end loop;
--close chld_SCRIPT;
end ;
  delete from  SCRIPT 
  where  SCRIPTID = aSCRIPTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Реализация*/
procedure SCRIPT_SAVE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aSCRIPTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SCRIPT where SCRIPTID=aSCRIPTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from SCRIPT where SCRIPTid=aSCRIPTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:SCRIPT',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=SCRIPT');
      return;
    end if;
  end if;
 --  verify lock  --
 SCRIPT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSCRIPTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SCRIPT');
    return;
  end if;
 -- update row  --
 update  SCRIPT set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  SCRIPTID = aSCRIPTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from SHAREDMETHOD where SHAREDMETHODid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:SCRIPT',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=SCRIPT');
      return;
    end if;
 end if;
 SHAREDMETHOD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SCRIPT');
    return;
  end if;
 insert into   SCRIPT
 (  SCRIPTID 
,ParentStructRowID
,Target

,Code

 ) values ( aSCRIPTID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 SCRIPT_SINIT( aCURSESSION,aSCRIPTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure SCRIPT_PARENT /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from SCRIPT where  SCRIPTid=aRowID;
  aParentTable := 'SHAREDMETHOD';
 end; 

procedure SCRIPT_ISLOCKED /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SCRIPT where SCRIPTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  SCRIPT_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure SCRIPT_LOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 SCRIPT_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  SCRIPT_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from SCRIPT where SCRIPTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=SCRIPT');
    return;
  end if;
   if  aLockMode =2  
   then   
    update SCRIPT set LockUserID =auserID ,LockSessionID =null where SCRIPTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SCRIPT set LockUserID =null,LockSessionID =aCURSESSION  where SCRIPTid=aRowID;
     return;
   end if;
 end ;

procedure SCRIPT_HCL /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_PARAMETERS is select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aRowid;
row_PARAMETERS lch_PARAMETERS%ROWTYPE;
begin  
--open lch_PARAMETERS;
for row_PARAMETERS in lch_PARAMETERS
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARAMETERS where PARAMETERSid=row_PARAMETERS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PARAMETERS;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PARAMETERS;
     return;
   end if; 
 end if;  
 PARAMETERS_HCL (acursession,row_PARAMETERS.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PARAMETERS;
   return;
 end if;
end loop;
--close lch_PARAMETERS;
end;
aIsLocked :=0;
end;

procedure SCRIPT_UNLOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 SCRIPT_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SCRIPT set LockUserID =null  where SCRIPTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SCRIPT set LockSessionID =null  where SCRIPTid=aRowID;
     return;
   end if;
 end; 

procedure SCRIPT_SINIT /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from SCRIPT where SCRIPTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =SCRIPT');
    return;
  end if;
if aSecurityStyleID is null then
 SCRIPT_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update SCRIPT set securitystyleid =aStyleID where SCRIPTid = aRowID;
else 
 update SCRIPT set securitystyleid =aSecurityStyleID where SCRIPTid = aRowID;
end if; 
end ; 

procedure SCRIPT_propagate /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from SCRIPT where SCRIPTid=aRowid;
declare cursor pch_PARAMETERS  is select PARAMETERS.PARAMETERSid ID from PARAMETERS where  PARAMETERS.ParentStructRowID = aRowid;
row_PARAMETERS  pch_PARAMETERS%ROWTYPE;
begin
--open pch_PARAMETERS;
for row_PARAMETERS in pch_PARAMETERS loop
   PARAMETERS_SINIT( acursession,row_PARAMETERS.id,assid);
   PARAMETERS_propagate( acursession,row_PARAMETERS.id);
end loop;
--close pch_PARAMETERS;
end;
end;


procedure PARAMETERS_BRIEF  (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARAMETERSid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PARAMETERS where PARAMETERSid=aPARAMETERSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PARAMETERS');
    return;
  end if;
  aBRIEF:=func.PARAMETERS_BRIEF_F(aPARAMETERSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PARAMETERS_DELETE /*Параметры метода*/ (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PARAMETERS where PARAMETERSid=aPARAMETERSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PARAMETERS',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PARAMETERS');
      return;
    end if;
  end if;
 --  verify lock  --
 PARAMETERS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARAMETERSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARAMETERS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_PARAMETERS is select  instanceid ID from instance where OwnerPartName ='PARAMETERS' and OwnerRowID=aPARAMETERSid;
row_PARAMETERS  chld_PARAMETERS%ROWTYPE;
begin
--open chld_PARAMETERS;
for row_PARAMETERS in chld_PARAMETERS loop
 Kernel.INSTANCE_OWNER (acursession,row_PARAMETERS.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PARAMETERS.id);
end loop;
--close chld_PARAMETERS;
end ;
  delete from  PARAMETERS 
  where  PARAMETERSID = aPARAMETERSID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Параметры*/
procedure PARAMETERS_SAVE /*Параметры метода*/ (
 aCURSESSION CHAR,
 aPARAMETERSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Имя *//* Имя */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aTypeOfParm CHAR/* Тип данных *//* Тип данных */
,aDataSize
 NUMBER := null /* Размер *//* Размер */
,aAllowNull
 NUMBER/* Можно не задавать *//* Можно не задавать */
,aOutParam
 NUMBER/* Возвращает значение *//* Возвращает значение */
,aReferenceType
 NUMBER/* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,aRefToPart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARAMETERS where PARAMETERSID=aPARAMETERSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PARAMETERS where PARAMETERSid=aPARAMETERSID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PARAMETERS',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PARAMETERS');
      return;
    end if;
  end if;
 --  verify lock  --
 PARAMETERS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARAMETERSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARAMETERS');
    return;
  end if;
 -- update row  --
 update  PARAMETERS set ChangeStamp=sysdate
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  TypeOfParm=aTypeOfParm
,
  DataSize=aDataSize
,
  AllowNull=aAllowNull
,
  OutParam=aOutParam
,
  ReferenceType=aReferenceType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
  where  PARAMETERSID = aPARAMETERSID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;
select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from SCRIPT where SCRIPTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PARAMETERS',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PARAMETERS');
      return;
    end if;
 end if;
 SCRIPT_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARAMETERS');
    return;
  end if;
 insert into   PARAMETERS
 (  PARAMETERSID 
,ParentStructRowID
,sequence

,Name

,Caption

,TypeOfParm

,DataSize

,AllowNull

,OutParam

,ReferenceType

,RefToType

,RefToPart

 ) values ( aPARAMETERSID 
,aParentStructRowID
,asequence

,aName

,aCaption

,aTypeOfParm

,aDataSize

,aAllowNull

,aOutParam

,aReferenceType

,aRefToType

,aRefToPart

 ); 
 PARAMETERS_SINIT( aCURSESSION,aPARAMETERSid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;
select Count(*) into aUniqueRowCount from PARAMETERS where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PARAMETERS');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure PARAMETERS_PARENT /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PARAMETERS where  PARAMETERSid=aRowID;
  aParentTable := 'SCRIPT';
 end; 

procedure PARAMETERS_ISLOCKED /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARAMETERS where PARAMETERSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PARAMETERS_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PARAMETERS_LOCK /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PARAMETERS_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PARAMETERS_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PARAMETERS where PARAMETERSid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PARAMETERS');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PARAMETERS set LockUserID =auserID ,LockSessionID =null where PARAMETERSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARAMETERS set LockUserID =null,LockSessionID =aCURSESSION  where PARAMETERSid=aRowID;
     return;
   end if;
 end ;

procedure PARAMETERS_HCL /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure PARAMETERS_UNLOCK /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PARAMETERS_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARAMETERS set LockUserID =null  where PARAMETERSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARAMETERS set LockSessionID =null  where PARAMETERSid=aRowID;
     return;
   end if;
 end; 

procedure PARAMETERS_SINIT /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PARAMETERS where PARAMETERSid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PARAMETERS');
    return;
  end if;
if aSecurityStyleID is null then
 PARAMETERS_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PARAMETERS set securitystyleid =aStyleID where PARAMETERSid = aRowID;
else 
 update PARAMETERS set securitystyleid =aSecurityStyleID where PARAMETERSid = aRowID;
end if; 
end ; 

procedure PARAMETERS_propagate /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PARAMETERS where PARAMETERSid=aRowid;
end;


procedure OBJECTTYPE_BRIEF  (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aOBJECTTYPEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from OBJECTTYPE where OBJECTTYPEid=aOBJECTTYPEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=OBJECTTYPE');
    return;
  end if;
  aBRIEF:=func.OBJECTTYPE_BRIEF_F(aOBJECTTYPEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure OBJECTTYPE_DELETE /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aOBJECTTYPEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:OBJECTTYPE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=OBJECTTYPE');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJECTTYPE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJECTTYPEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJECTTYPE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_OBJSTATUS is select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aOBJECTTYPEid;
    child_OBJSTATUS_rec  child_OBJSTATUS%ROWTYPE;
    begin
    --open child_OBJSTATUS;
      for child_OBJSTATUS_rec in child_OBJSTATUS loop
      OBJSTATUS_DELETE (acursession,child_OBJSTATUS_rec.id,aInstanceid);
      end loop;
      --close child_OBJSTATUS;
    end ;
    declare cursor child_OBJECTMODE is select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aOBJECTTYPEid;
    child_OBJECTMODE_rec  child_OBJECTMODE%ROWTYPE;
    begin
    --open child_OBJECTMODE;
      for child_OBJECTMODE_rec in child_OBJECTMODE loop
      OBJECTMODE_DELETE (acursession,child_OBJECTMODE_rec.id,aInstanceid);
      end loop;
      --close child_OBJECTMODE;
    end ;
    declare cursor child_TYPEMENU is select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aOBJECTTYPEid;
    child_TYPEMENU_rec  child_TYPEMENU%ROWTYPE;
    begin
    --open child_TYPEMENU;
      for child_TYPEMENU_rec in child_TYPEMENU loop
      TYPEMENU_DELETE (acursession,child_TYPEMENU_rec.id,aInstanceid);
      end loop;
      --close child_TYPEMENU;
    end ;
    declare cursor child_INSTANCEVALIDATOR is select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aOBJECTTYPEid;
    child_INSTANCEVALIDATOR_rec  child_INSTANCEVALIDATOR%ROWTYPE;
    begin
    --open child_INSTANCEVALIDATOR;
      for child_INSTANCEVALIDATOR_rec in child_INSTANCEVALIDATOR loop
      INSTANCEVALIDATOR_DELETE (acursession,child_INSTANCEVALIDATOR_rec.id,aInstanceid);
      end loop;
      --close child_INSTANCEVALIDATOR;
    end ;
    declare cursor child_PART is select PART.PARTid ID from PART where  PART.ParentStructRowID = aOBJECTTYPEid;
    child_PART_rec  child_PART%ROWTYPE;
    begin
    --open child_PART;
      for child_PART_rec in child_PART loop
      PART_DELETE (acursession,child_PART_rec.id,aInstanceid);
      end loop;
      --close child_PART;
    end ;
declare cursor chld_OBJECTTYPE is select  instanceid ID from instance where OwnerPartName ='OBJECTTYPE' and OwnerRowID=aOBJECTTYPEid;
row_OBJECTTYPE  chld_OBJECTTYPE%ROWTYPE;
begin
--open chld_OBJECTTYPE;
for row_OBJECTTYPE in chld_OBJECTTYPE loop
 Kernel.INSTANCE_OWNER (acursession,row_OBJECTTYPE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_OBJECTTYPE.id);
end loop;
--close chld_OBJECTTYPE;
end ;
  delete from  OBJECTTYPE 
  where  OBJECTTYPEID = aOBJECTTYPEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип объекта*/
procedure OBJECTTYPE_SAVE /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aOBJECTTYPEid CHAR,
aInstanceID CHAR 
,aPackage CHAR/* Приложение *//* Приложение */
,athe_Comment
 VARCHAR2/* Название *//* Название */
,aName
 VARCHAR2/* Код *//* Код */
,aIsSingleInstance
 NUMBER/* Допускается только один объект *//* Допускается только один объект */
,aChooseView CHAR := null /* Представление для выбора *//* Представление для выбора */
,aOnRun CHAR := null /* При запуске *//* При запуске */
,aOnCreate CHAR := null /* При создании *//* При создании */
,aOnDelete CHAR := null /* При удалении *//* При удалении */
,aAllowRefToObject
 NUMBER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aAllowSearch
 NUMBER/* Отображать при поиске *//* Отображать при поиске */
,aReplicaType
 NUMBER := null /* Тип репликации *//* Тип репликации */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,aUseOwnership
 NUMBER/* Видмость зависит от пользователя *//* Видмость зависит от пользователя */
,aUseArchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aCommitFullObject
 NUMBER/* Сохранять объект целиком *//* Сохранять объект целиком */
,aobjIconCls
 VARCHAR2 := null /* Иконка объекта *//* Иконка объекта */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJECTTYPE where OBJECTTYPEID=aOBJECTTYPEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aOBJECTTYPEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:OBJECTTYPE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=OBJECTTYPE');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJECTTYPE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJECTTYPEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTTYPE');
    return;
  end if;
 -- update row  --
 update  OBJECTTYPE set ChangeStamp=sysdate
,
  Package=aPackage
,
  the_Comment=athe_Comment
,
  Name=aName
,
  IsSingleInstance=aIsSingleInstance
,
  ChooseView=aChooseView
,
  OnRun=aOnRun
,
  OnCreate=aOnCreate
,
  OnDelete=aOnDelete
,
  AllowRefToObject=aAllowRefToObject
,
  AllowSearch=aAllowSearch
,
  ReplicaType=aReplicaType
,
  TheComment=aTheComment
,
  UseOwnership=aUseOwnership
,
  UseArchiving=aUseArchiving
,
  CommitFullObject=aCommitFullObject
,
  objIconCls=aobjIconCls
  where  OBJECTTYPEID = aOBJECTTYPEID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from OBJECTTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=OBJECTTYPE');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:OBJECTTYPE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=OBJECTTYPE');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTTYPE');
    return;
  end if;
 insert into   OBJECTTYPE
 (  OBJECTTYPEID 
,InstanceID
,Package

,the_Comment

,Name

,IsSingleInstance

,ChooseView

,OnRun

,OnCreate

,OnDelete

,AllowRefToObject

,AllowSearch

,ReplicaType

,TheComment

,UseOwnership

,UseArchiving

,CommitFullObject

,objIconCls

 ) values ( aOBJECTTYPEID 
,aInstanceID
,aPackage

,athe_Comment

,aName

,aIsSingleInstance

,aChooseView

,aOnRun

,aOnCreate

,aOnDelete

,aAllowRefToObject

,aAllowSearch

,aReplicaType

,aTheComment

,aUseOwnership

,aUseArchiving

,aCommitFullObject

,aobjIconCls

 ); 
 OBJECTTYPE_SINIT( aCURSESSION,aOBJECTTYPEid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from OBJECTTYPE where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=OBJECTTYPE');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure OBJECTTYPE_PARENT /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from OBJECTTYPE where  OBJECTTYPEid=aRowID;
 end; 

procedure OBJECTTYPE_ISLOCKED /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJECTTYPE where OBJECTTYPEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  OBJECTTYPE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure OBJECTTYPE_LOCK /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 OBJECTTYPE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  OBJECTTYPE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=OBJECTTYPE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update OBJECTTYPE set LockUserID =auserID ,LockSessionID =null where OBJECTTYPEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJECTTYPE set LockUserID =null,LockSessionID =aCURSESSION  where OBJECTTYPEid=aRowID;
     return;
   end if;
 end ;

procedure OBJECTTYPE_HCL /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_OBJSTATUS is select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aRowid;
row_OBJSTATUS lch_OBJSTATUS%ROWTYPE;
begin  
--open lch_OBJSTATUS;
for row_OBJSTATUS in lch_OBJSTATUS
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from OBJSTATUS where OBJSTATUSid=row_OBJSTATUS.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_OBJSTATUS;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_OBJSTATUS;
     return;
   end if; 
 end if;  
 OBJSTATUS_HCL (acursession,row_OBJSTATUS.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_OBJSTATUS;
   return;
 end if;
end loop;
--close lch_OBJSTATUS;
end;
declare cursor lch_OBJECTMODE is select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aRowid;
row_OBJECTMODE lch_OBJECTMODE%ROWTYPE;
begin  
--open lch_OBJECTMODE;
for row_OBJECTMODE in lch_OBJECTMODE
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from OBJECTMODE where OBJECTMODEid=row_OBJECTMODE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_OBJECTMODE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_OBJECTMODE;
     return;
   end if; 
 end if;  
 OBJECTMODE_HCL (acursession,row_OBJECTMODE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_OBJECTMODE;
   return;
 end if;
end loop;
--close lch_OBJECTMODE;
end;
declare cursor lch_TYPEMENU is select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aRowid;
row_TYPEMENU lch_TYPEMENU%ROWTYPE;
begin  
--open lch_TYPEMENU;
for row_TYPEMENU in lch_TYPEMENU
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from TYPEMENU where TYPEMENUid=row_TYPEMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_TYPEMENU;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_TYPEMENU;
     return;
   end if; 
 end if;  
 TYPEMENU_HCL (acursession,row_TYPEMENU.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_TYPEMENU;
   return;
 end if;
end loop;
--close lch_TYPEMENU;
end;
declare cursor lch_INSTANCEVALIDATOR is select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aRowid;
row_INSTANCEVALIDATOR lch_INSTANCEVALIDATOR%ROWTYPE;
begin  
--open lch_INSTANCEVALIDATOR;
for row_INSTANCEVALIDATOR in lch_INSTANCEVALIDATOR
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=row_INSTANCEVALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_INSTANCEVALIDATOR;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_INSTANCEVALIDATOR;
     return;
   end if; 
 end if;  
 INSTANCEVALIDATOR_HCL (acursession,row_INSTANCEVALIDATOR.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_INSTANCEVALIDATOR;
   return;
 end if;
end loop;
--close lch_INSTANCEVALIDATOR;
end;
declare cursor lch_PART is select PART.PARTid ID from PART where  PART.ParentStructRowID = aRowid;
row_PART lch_PART%ROWTYPE;
begin  
--open lch_PART;
for row_PART in lch_PART
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PART where PARTid=row_PART.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PART;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PART;
     return;
   end if; 
 end if;  
 PART_HCL (acursession,row_PART.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PART;
   return;
 end if;
end loop;
--close lch_PART;
end;
aIsLocked :=0;
end;

procedure OBJECTTYPE_UNLOCK /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 OBJECTTYPE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJECTTYPE set LockUserID =null  where OBJECTTYPEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJECTTYPE set LockSessionID =null  where OBJECTTYPEid=aRowID;
     return;
   end if;
 end; 

procedure OBJECTTYPE_SINIT /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =OBJECTTYPE');
    return;
  end if;
if aSecurityStyleID is null then
 OBJECTTYPE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update OBJECTTYPE set securitystyleid =aStyleID where OBJECTTYPEid = aRowID;
else 
 update OBJECTTYPE set securitystyleid =aSecurityStyleID where OBJECTTYPEid = aRowID;
end if; 
end ; 

procedure OBJECTTYPE_propagate /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from OBJECTTYPE where OBJECTTYPEid=aRowid;
declare cursor pch_OBJSTATUS  is select OBJSTATUS.OBJSTATUSid ID from OBJSTATUS where  OBJSTATUS.ParentStructRowID = aRowid;
row_OBJSTATUS  pch_OBJSTATUS%ROWTYPE;
begin
--open pch_OBJSTATUS;
for row_OBJSTATUS in pch_OBJSTATUS loop
   OBJSTATUS_SINIT( acursession,row_OBJSTATUS.id,assid);
   OBJSTATUS_propagate( acursession,row_OBJSTATUS.id);
end loop;
--close pch_OBJSTATUS;
end;
declare cursor pch_OBJECTMODE  is select OBJECTMODE.OBJECTMODEid ID from OBJECTMODE where  OBJECTMODE.ParentStructRowID = aRowid;
row_OBJECTMODE  pch_OBJECTMODE%ROWTYPE;
begin
--open pch_OBJECTMODE;
for row_OBJECTMODE in pch_OBJECTMODE loop
   OBJECTMODE_SINIT( acursession,row_OBJECTMODE.id,assid);
   OBJECTMODE_propagate( acursession,row_OBJECTMODE.id);
end loop;
--close pch_OBJECTMODE;
end;
declare cursor pch_TYPEMENU  is select TYPEMENU.TYPEMENUid ID from TYPEMENU where  TYPEMENU.ParentStructRowID = aRowid;
row_TYPEMENU  pch_TYPEMENU%ROWTYPE;
begin
--open pch_TYPEMENU;
for row_TYPEMENU in pch_TYPEMENU loop
   TYPEMENU_SINIT( acursession,row_TYPEMENU.id,assid);
   TYPEMENU_propagate( acursession,row_TYPEMENU.id);
end loop;
--close pch_TYPEMENU;
end;
declare cursor pch_INSTANCEVALIDATOR  is select INSTANCEVALIDATOR.INSTANCEVALIDATORid ID from INSTANCEVALIDATOR where  INSTANCEVALIDATOR.ParentStructRowID = aRowid;
row_INSTANCEVALIDATOR  pch_INSTANCEVALIDATOR%ROWTYPE;
begin
--open pch_INSTANCEVALIDATOR;
for row_INSTANCEVALIDATOR in pch_INSTANCEVALIDATOR loop
   INSTANCEVALIDATOR_SINIT( acursession,row_INSTANCEVALIDATOR.id,assid);
   INSTANCEVALIDATOR_propagate( acursession,row_INSTANCEVALIDATOR.id);
end loop;
--close pch_INSTANCEVALIDATOR;
end;
declare cursor pch_PART  is select PART.PARTid ID from PART where  PART.ParentStructRowID = aRowid;
row_PART  pch_PART%ROWTYPE;
begin
--open pch_PART;
for row_PART in pch_PART loop
   PART_SINIT( acursession,row_PART.id,assid);
   PART_propagate( acursession,row_PART.id);
end loop;
--close pch_PART;
end;
end;


procedure OBJSTATUS_BRIEF  (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aOBJSTATUSid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from OBJSTATUS where OBJSTATUSid=aOBJSTATUSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=OBJSTATUS');
    return;
  end if;
  aBRIEF:=func.OBJSTATUS_BRIEF_F(aOBJSTATUSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure OBJSTATUS_DELETE /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from OBJSTATUS where OBJSTATUSid=aOBJSTATUSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:OBJSTATUS',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=OBJSTATUS');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJSTATUS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJSTATUSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJSTATUS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_NEXTSTATE is select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aOBJSTATUSid;
    child_NEXTSTATE_rec  child_NEXTSTATE%ROWTYPE;
    begin
    --open child_NEXTSTATE;
      for child_NEXTSTATE_rec in child_NEXTSTATE loop
      NEXTSTATE_DELETE (acursession,child_NEXTSTATE_rec.id,aInstanceid);
      end loop;
      --close child_NEXTSTATE;
    end ;
declare cursor chld_OBJSTATUS is select  instanceid ID from instance where OwnerPartName ='OBJSTATUS' and OwnerRowID=aOBJSTATUSid;
row_OBJSTATUS  chld_OBJSTATUS%ROWTYPE;
begin
--open chld_OBJSTATUS;
for row_OBJSTATUS in chld_OBJSTATUS loop
 Kernel.INSTANCE_OWNER (acursession,row_OBJSTATUS.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_OBJSTATUS.id);
end loop;
--close chld_OBJSTATUS;
end ;
  delete from  OBJSTATUS 
  where  OBJSTATUSID = aOBJSTATUSID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состояния*/
procedure OBJSTATUS_SAVE /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aOBJSTATUSid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aisStartup
 NUMBER/* Начальное *//* Начальное */
,aIsArchive
 NUMBER/* Архивное *//* Архивное */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJSTATUS where OBJSTATUSID=aOBJSTATUSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from OBJSTATUS where OBJSTATUSid=aOBJSTATUSID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:OBJSTATUS',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=OBJSTATUS');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJSTATUS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJSTATUSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJSTATUS');
    return;
  end if;
 -- update row  --
 update  OBJSTATUS set ChangeStamp=sysdate
,
  name=aname
,
  isStartup=aisStartup
,
  IsArchive=aIsArchive
,
  the_comment=athe_comment
  where  OBJSTATUSID = aOBJSTATUSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:OBJSTATUS',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=OBJSTATUS');
      return;
    end if;
 end if;
 OBJECTTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJSTATUS');
    return;
  end if;
 insert into   OBJSTATUS
 (  OBJSTATUSID 
,ParentStructRowID
,name

,isStartup

,IsArchive

,the_comment

 ) values ( aOBJSTATUSID 
,aParentStructRowID
,aname

,aisStartup

,aIsArchive

,athe_comment

 ); 
 OBJSTATUS_SINIT( aCURSESSION,aOBJSTATUSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure OBJSTATUS_PARENT /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from OBJSTATUS where  OBJSTATUSid=aRowID;
  aParentTable := 'OBJECTTYPE';
 end; 

procedure OBJSTATUS_ISLOCKED /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJSTATUS where OBJSTATUSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  OBJSTATUS_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure OBJSTATUS_LOCK /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 OBJSTATUS_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  OBJSTATUS_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from OBJSTATUS where OBJSTATUSid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=OBJSTATUS');
    return;
  end if;
   if  aLockMode =2  
   then   
    update OBJSTATUS set LockUserID =auserID ,LockSessionID =null where OBJSTATUSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJSTATUS set LockUserID =null,LockSessionID =aCURSESSION  where OBJSTATUSid=aRowID;
     return;
   end if;
 end ;

procedure OBJSTATUS_HCL /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_NEXTSTATE is select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aRowid;
row_NEXTSTATE lch_NEXTSTATE%ROWTYPE;
begin  
--open lch_NEXTSTATE;
for row_NEXTSTATE in lch_NEXTSTATE
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from NEXTSTATE where NEXTSTATEid=row_NEXTSTATE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_NEXTSTATE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_NEXTSTATE;
     return;
   end if; 
 end if;  
 NEXTSTATE_HCL (acursession,row_NEXTSTATE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_NEXTSTATE;
   return;
 end if;
end loop;
--close lch_NEXTSTATE;
end;
aIsLocked :=0;
end;

procedure OBJSTATUS_UNLOCK /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 OBJSTATUS_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJSTATUS set LockUserID =null  where OBJSTATUSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJSTATUS set LockSessionID =null  where OBJSTATUSid=aRowID;
     return;
   end if;
 end; 

procedure OBJSTATUS_SINIT /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from OBJSTATUS where OBJSTATUSid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =OBJSTATUS');
    return;
  end if;
if aSecurityStyleID is null then
 OBJSTATUS_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update OBJSTATUS set securitystyleid =aStyleID where OBJSTATUSid = aRowID;
else 
 update OBJSTATUS set securitystyleid =aSecurityStyleID where OBJSTATUSid = aRowID;
end if; 
end ; 

procedure OBJSTATUS_propagate /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from OBJSTATUS where OBJSTATUSid=aRowid;
declare cursor pch_NEXTSTATE  is select NEXTSTATE.NEXTSTATEid ID from NEXTSTATE where  NEXTSTATE.ParentStructRowID = aRowid;
row_NEXTSTATE  pch_NEXTSTATE%ROWTYPE;
begin
--open pch_NEXTSTATE;
for row_NEXTSTATE in pch_NEXTSTATE loop
   NEXTSTATE_SINIT( acursession,row_NEXTSTATE.id,assid);
   NEXTSTATE_propagate( acursession,row_NEXTSTATE.id);
end loop;
--close pch_NEXTSTATE;
end;
end;


procedure NEXTSTATE_BRIEF  (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aNEXTSTATEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from NEXTSTATE where NEXTSTATEid=aNEXTSTATEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=NEXTSTATE');
    return;
  end if;
  aBRIEF:=func.NEXTSTATE_BRIEF_F(aNEXTSTATEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure NEXTSTATE_DELETE /*Матрица переходов */ (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from NEXTSTATE where NEXTSTATEid=aNEXTSTATEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:NEXTSTATE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=NEXTSTATE');
      return;
    end if;
  end if;
 --  verify lock  --
 NEXTSTATE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNEXTSTATEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=NEXTSTATE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_NEXTSTATE is select  instanceid ID from instance where OwnerPartName ='NEXTSTATE' and OwnerRowID=aNEXTSTATEid;
row_NEXTSTATE  chld_NEXTSTATE%ROWTYPE;
begin
--open chld_NEXTSTATE;
for row_NEXTSTATE in chld_NEXTSTATE loop
 Kernel.INSTANCE_OWNER (acursession,row_NEXTSTATE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_NEXTSTATE.id);
end loop;
--close chld_NEXTSTATE;
end ;
  delete from  NEXTSTATE 
  where  NEXTSTATEID = aNEXTSTATEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные переходы*/
procedure NEXTSTATE_SAVE /*Матрица переходов */ (
 aCURSESSION CHAR,
 aNEXTSTATEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheState CHAR/* Разрешенное состояние *//* Разрешенное состояние */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from NEXTSTATE where NEXTSTATEID=aNEXTSTATEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from NEXTSTATE where NEXTSTATEid=aNEXTSTATEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:NEXTSTATE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=NEXTSTATE');
      return;
    end if;
  end if;
 --  verify lock  --
 NEXTSTATE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNEXTSTATEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=NEXTSTATE');
    return;
  end if;
 -- update row  --
 update  NEXTSTATE set ChangeStamp=sysdate
,
  TheState=aTheState
  where  NEXTSTATEID = aNEXTSTATEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJSTATUS where OBJSTATUSid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:NEXTSTATE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=NEXTSTATE');
      return;
    end if;
 end if;
 OBJSTATUS_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=NEXTSTATE');
    return;
  end if;
 insert into   NEXTSTATE
 (  NEXTSTATEID 
,ParentStructRowID
,TheState

 ) values ( aNEXTSTATEID 
,aParentStructRowID
,aTheState

 ); 
 NEXTSTATE_SINIT( aCURSESSION,aNEXTSTATEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure NEXTSTATE_PARENT /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from NEXTSTATE where  NEXTSTATEid=aRowID;
  aParentTable := 'OBJSTATUS';
 end; 

procedure NEXTSTATE_ISLOCKED /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from NEXTSTATE where NEXTSTATEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  NEXTSTATE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure NEXTSTATE_LOCK /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 NEXTSTATE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  NEXTSTATE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from NEXTSTATE where NEXTSTATEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=NEXTSTATE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update NEXTSTATE set LockUserID =auserID ,LockSessionID =null where NEXTSTATEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update NEXTSTATE set LockUserID =null,LockSessionID =aCURSESSION  where NEXTSTATEid=aRowID;
     return;
   end if;
 end ;

procedure NEXTSTATE_HCL /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure NEXTSTATE_UNLOCK /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 NEXTSTATE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update NEXTSTATE set LockUserID =null  where NEXTSTATEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update NEXTSTATE set LockSessionID =null  where NEXTSTATEid=aRowID;
     return;
   end if;
 end; 

procedure NEXTSTATE_SINIT /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from NEXTSTATE where NEXTSTATEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =NEXTSTATE');
    return;
  end if;
if aSecurityStyleID is null then
 NEXTSTATE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update NEXTSTATE set securitystyleid =aStyleID where NEXTSTATEid = aRowID;
else 
 update NEXTSTATE set securitystyleid =aSecurityStyleID where NEXTSTATEid = aRowID;
end if; 
end ; 

procedure NEXTSTATE_propagate /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from NEXTSTATE where NEXTSTATEid=aRowid;
end;


procedure OBJECTMODE_BRIEF  (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aOBJECTMODEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from OBJECTMODE where OBJECTMODEid=aOBJECTMODEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=OBJECTMODE');
    return;
  end if;
  aBRIEF:=func.OBJECTMODE_BRIEF_F(aOBJECTMODEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure OBJECTMODE_DELETE /*Режим работы*/ (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aOBJECTMODEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:OBJECTMODE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=OBJECTMODE');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJECTMODE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJECTMODEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=OBJECTMODE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_STRUCTRESTRICTION is select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aOBJECTMODEid;
    child_STRUCTRESTRICTION_rec  child_STRUCTRESTRICTION%ROWTYPE;
    begin
    --open child_STRUCTRESTRICTION;
      for child_STRUCTRESTRICTION_rec in child_STRUCTRESTRICTION loop
      STRUCTRESTRICTION_DELETE (acursession,child_STRUCTRESTRICTION_rec.id,aInstanceid);
      end loop;
      --close child_STRUCTRESTRICTION;
    end ;
    declare cursor child_METHODRESTRICTION is select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aOBJECTMODEid;
    child_METHODRESTRICTION_rec  child_METHODRESTRICTION%ROWTYPE;
    begin
    --open child_METHODRESTRICTION;
      for child_METHODRESTRICTION_rec in child_METHODRESTRICTION loop
      METHODRESTRICTION_DELETE (acursession,child_METHODRESTRICTION_rec.id,aInstanceid);
      end loop;
      --close child_METHODRESTRICTION;
    end ;
    declare cursor child_FIELDRESTRICTION is select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aOBJECTMODEid;
    child_FIELDRESTRICTION_rec  child_FIELDRESTRICTION%ROWTYPE;
    begin
    --open child_FIELDRESTRICTION;
      for child_FIELDRESTRICTION_rec in child_FIELDRESTRICTION loop
      FIELDRESTRICTION_DELETE (acursession,child_FIELDRESTRICTION_rec.id,aInstanceid);
      end loop;
      --close child_FIELDRESTRICTION;
    end ;
declare cursor chld_OBJECTMODE is select  instanceid ID from instance where OwnerPartName ='OBJECTMODE' and OwnerRowID=aOBJECTMODEid;
row_OBJECTMODE  chld_OBJECTMODE%ROWTYPE;
begin
--open chld_OBJECTMODE;
for row_OBJECTMODE in chld_OBJECTMODE loop
 Kernel.INSTANCE_OWNER (acursession,row_OBJECTMODE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_OBJECTMODE.id);
end loop;
--close chld_OBJECTMODE;
end ;
  delete from  OBJECTMODE 
  where  OBJECTMODEID = aOBJECTMODEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Режим работы*/
procedure OBJECTMODE_SAVE /*Режим работы*/ (
 aCURSESSION CHAR,
 aOBJECTMODEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название режима *//* Название режима */
,aDefaultMode
 NUMBER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from OBJECTMODE where OBJECTMODEID=aOBJECTMODEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aOBJECTMODEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:OBJECTMODE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=OBJECTMODE');
      return;
    end if;
  end if;
 --  verify lock  --
 OBJECTMODE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aOBJECTMODEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTMODE');
    return;
  end if;
 -- update row  --
 update  OBJECTMODE set ChangeStamp=sysdate
,
  Name=aName
,
  DefaultMode=aDefaultMode
,
  TheComment=aTheComment
  where  OBJECTMODEID = aOBJECTMODEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:OBJECTMODE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=OBJECTMODE');
      return;
    end if;
 end if;
 OBJECTTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=OBJECTMODE');
    return;
  end if;
 insert into   OBJECTMODE
 (  OBJECTMODEID 
,ParentStructRowID
,Name

,DefaultMode

,TheComment

 ) values ( aOBJECTMODEID 
,aParentStructRowID
,aName

,aDefaultMode

,aTheComment

 ); 
 OBJECTMODE_SINIT( aCURSESSION,aOBJECTMODEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure OBJECTMODE_PARENT /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from OBJECTMODE where  OBJECTMODEid=aRowID;
  aParentTable := 'OBJECTTYPE';
 end; 

procedure OBJECTMODE_ISLOCKED /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from OBJECTMODE where OBJECTMODEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  OBJECTMODE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure OBJECTMODE_LOCK /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 OBJECTMODE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  OBJECTMODE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=OBJECTMODE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update OBJECTMODE set LockUserID =auserID ,LockSessionID =null where OBJECTMODEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update OBJECTMODE set LockUserID =null,LockSessionID =aCURSESSION  where OBJECTMODEid=aRowID;
     return;
   end if;
 end ;

procedure OBJECTMODE_HCL /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_STRUCTRESTRICTION is select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aRowid;
row_STRUCTRESTRICTION lch_STRUCTRESTRICTION%ROWTYPE;
begin  
--open lch_STRUCTRESTRICTION;
for row_STRUCTRESTRICTION in lch_STRUCTRESTRICTION
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=row_STRUCTRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_STRUCTRESTRICTION;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_STRUCTRESTRICTION;
     return;
   end if; 
 end if;  
 STRUCTRESTRICTION_HCL (acursession,row_STRUCTRESTRICTION.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_STRUCTRESTRICTION;
   return;
 end if;
end loop;
--close lch_STRUCTRESTRICTION;
end;
declare cursor lch_METHODRESTRICTION is select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aRowid;
row_METHODRESTRICTION lch_METHODRESTRICTION%ROWTYPE;
begin  
--open lch_METHODRESTRICTION;
for row_METHODRESTRICTION in lch_METHODRESTRICTION
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from METHODRESTRICTION where METHODRESTRICTIONid=row_METHODRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_METHODRESTRICTION;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_METHODRESTRICTION;
     return;
   end if; 
 end if;  
 METHODRESTRICTION_HCL (acursession,row_METHODRESTRICTION.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_METHODRESTRICTION;
   return;
 end if;
end loop;
--close lch_METHODRESTRICTION;
end;
declare cursor lch_FIELDRESTRICTION is select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aRowid;
row_FIELDRESTRICTION lch_FIELDRESTRICTION%ROWTYPE;
begin  
--open lch_FIELDRESTRICTION;
for row_FIELDRESTRICTION in lch_FIELDRESTRICTION
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDRESTRICTION where FIELDRESTRICTIONid=row_FIELDRESTRICTION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDRESTRICTION;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDRESTRICTION;
     return;
   end if; 
 end if;  
 FIELDRESTRICTION_HCL (acursession,row_FIELDRESTRICTION.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDRESTRICTION;
   return;
 end if;
end loop;
--close lch_FIELDRESTRICTION;
end;
aIsLocked :=0;
end;

procedure OBJECTMODE_UNLOCK /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 OBJECTMODE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update OBJECTMODE set LockUserID =null  where OBJECTMODEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update OBJECTMODE set LockSessionID =null  where OBJECTMODEid=aRowID;
     return;
   end if;
 end; 

procedure OBJECTMODE_SINIT /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =OBJECTMODE');
    return;
  end if;
if aSecurityStyleID is null then
 OBJECTMODE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update OBJECTMODE set securitystyleid =aStyleID where OBJECTMODEid = aRowID;
else 
 update OBJECTMODE set securitystyleid =aSecurityStyleID where OBJECTMODEid = aRowID;
end if; 
end ; 

procedure OBJECTMODE_propagate /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from OBJECTMODE where OBJECTMODEid=aRowid;
declare cursor pch_STRUCTRESTRICTION  is select STRUCTRESTRICTION.STRUCTRESTRICTIONid ID from STRUCTRESTRICTION where  STRUCTRESTRICTION.ParentStructRowID = aRowid;
row_STRUCTRESTRICTION  pch_STRUCTRESTRICTION%ROWTYPE;
begin
--open pch_STRUCTRESTRICTION;
for row_STRUCTRESTRICTION in pch_STRUCTRESTRICTION loop
   STRUCTRESTRICTION_SINIT( acursession,row_STRUCTRESTRICTION.id,assid);
   STRUCTRESTRICTION_propagate( acursession,row_STRUCTRESTRICTION.id);
end loop;
--close pch_STRUCTRESTRICTION;
end;
declare cursor pch_METHODRESTRICTION  is select METHODRESTRICTION.METHODRESTRICTIONid ID from METHODRESTRICTION where  METHODRESTRICTION.ParentStructRowID = aRowid;
row_METHODRESTRICTION  pch_METHODRESTRICTION%ROWTYPE;
begin
--open pch_METHODRESTRICTION;
for row_METHODRESTRICTION in pch_METHODRESTRICTION loop
   METHODRESTRICTION_SINIT( acursession,row_METHODRESTRICTION.id,assid);
   METHODRESTRICTION_propagate( acursession,row_METHODRESTRICTION.id);
end loop;
--close pch_METHODRESTRICTION;
end;
declare cursor pch_FIELDRESTRICTION  is select FIELDRESTRICTION.FIELDRESTRICTIONid ID from FIELDRESTRICTION where  FIELDRESTRICTION.ParentStructRowID = aRowid;
row_FIELDRESTRICTION  pch_FIELDRESTRICTION%ROWTYPE;
begin
--open pch_FIELDRESTRICTION;
for row_FIELDRESTRICTION in pch_FIELDRESTRICTION loop
   FIELDRESTRICTION_SINIT( acursession,row_FIELDRESTRICTION.id,assid);
   FIELDRESTRICTION_propagate( acursession,row_FIELDRESTRICTION.id);
end loop;
--close pch_FIELDRESTRICTION;
end;
end;


procedure STRUCTRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aSTRUCTRESTRICTIONid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aSTRUCTRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=STRUCTRESTRICTION');
    return;
  end if;
  aBRIEF:=func.STRUCTRESTRICTION_BRIEF_F(aSTRUCTRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure STRUCTRESTRICTION_DELETE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aSTRUCTRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:STRUCTRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=STRUCTRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 STRUCTRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSTRUCTRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_STRUCTRESTRICTION is select  instanceid ID from instance where OwnerPartName ='STRUCTRESTRICTION' and OwnerRowID=aSTRUCTRESTRICTIONid;
row_STRUCTRESTRICTION  chld_STRUCTRESTRICTION%ROWTYPE;
begin
--open chld_STRUCTRESTRICTION;
for row_STRUCTRESTRICTION in chld_STRUCTRESTRICTION loop
 Kernel.INSTANCE_OWNER (acursession,row_STRUCTRESTRICTION.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_STRUCTRESTRICTION.id);
end loop;
--close chld_STRUCTRESTRICTION;
end ;
  delete from  STRUCTRESTRICTION 
  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Органичения разделов*/
procedure STRUCTRESTRICTION_SAVE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aSTRUCTRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aStruct CHAR/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aAllowRead
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowAdd
 NUMBER/* Разрешено добавлять *//* Разрешено добавлять */
,aAllowEdit
 NUMBER/* Разрешено изменять *//* Разрешено изменять */
,aAllowDelete
 NUMBER/* Разрешено удалять *//* Разрешено удалять */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from STRUCTRESTRICTION where STRUCTRESTRICTIONID=aSTRUCTRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aSTRUCTRESTRICTIONID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:STRUCTRESTRICTION',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=STRUCTRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 STRUCTRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSTRUCTRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
 -- update row  --
 update  STRUCTRESTRICTION set ChangeStamp=sysdate
,
  Struct=aStruct
,
  AllowRead=aAllowRead
,
  AllowAdd=aAllowAdd
,
  AllowEdit=aAllowEdit
,
  AllowDelete=aAllowDelete
  where  STRUCTRESTRICTIONID = aSTRUCTRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:STRUCTRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=STRUCTRESTRICTION');
      return;
    end if;
 end if;
 OBJECTMODE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=STRUCTRESTRICTION');
    return;
  end if;
 insert into   STRUCTRESTRICTION
 (  STRUCTRESTRICTIONID 
,ParentStructRowID
,Struct

,AllowRead

,AllowAdd

,AllowEdit

,AllowDelete

 ) values ( aSTRUCTRESTRICTIONID 
,aParentStructRowID
,aStruct

,aAllowRead

,aAllowAdd

,aAllowEdit

,aAllowDelete

 ); 
 STRUCTRESTRICTION_SINIT( aCURSESSION,aSTRUCTRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure STRUCTRESTRICTION_PARENT /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from STRUCTRESTRICTION where  STRUCTRESTRICTIONid=aRowID;
  aParentTable := 'OBJECTMODE';
 end; 

procedure STRUCTRESTRICTION_ISLOCKED /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  STRUCTRESTRICTION_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure STRUCTRESTRICTION_LOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 STRUCTRESTRICTION_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  STRUCTRESTRICTION_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=STRUCTRESTRICTION');
    return;
  end if;
   if  aLockMode =2  
   then   
    update STRUCTRESTRICTION set LockUserID =auserID ,LockSessionID =null where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update STRUCTRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
 end ;

procedure STRUCTRESTRICTION_HCL /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure STRUCTRESTRICTION_UNLOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 STRUCTRESTRICTION_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update STRUCTRESTRICTION set LockUserID =null  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update STRUCTRESTRICTION set LockSessionID =null  where STRUCTRESTRICTIONid=aRowID;
     return;
   end if;
 end; 

procedure STRUCTRESTRICTION_SINIT /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =STRUCTRESTRICTION');
    return;
  end if;
if aSecurityStyleID is null then
 STRUCTRESTRICTION_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update STRUCTRESTRICTION set securitystyleid =aStyleID where STRUCTRESTRICTIONid = aRowID;
else 
 update STRUCTRESTRICTION set securitystyleid =aSecurityStyleID where STRUCTRESTRICTIONid = aRowID;
end if; 
end ; 

procedure STRUCTRESTRICTION_propagate /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from STRUCTRESTRICTION where STRUCTRESTRICTIONid=aRowid;
end;


procedure METHODRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aMETHODRESTRICTIONid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from METHODRESTRICTION where METHODRESTRICTIONid=aMETHODRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=METHODRESTRICTION');
    return;
  end if;
  aBRIEF:=func.METHODRESTRICTION_BRIEF_F(aMETHODRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure METHODRESTRICTION_DELETE /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from METHODRESTRICTION where METHODRESTRICTIONid=aMETHODRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:METHODRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=METHODRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 METHODRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMETHODRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=METHODRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_METHODRESTRICTION is select  instanceid ID from instance where OwnerPartName ='METHODRESTRICTION' and OwnerRowID=aMETHODRESTRICTIONid;
row_METHODRESTRICTION  chld_METHODRESTRICTION%ROWTYPE;
begin
--open chld_METHODRESTRICTION;
for row_METHODRESTRICTION in chld_METHODRESTRICTION loop
 Kernel.INSTANCE_OWNER (acursession,row_METHODRESTRICTION.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_METHODRESTRICTION.id);
end loop;
--close chld_METHODRESTRICTION;
end ;
  delete from  METHODRESTRICTION 
  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничения методов*/
procedure METHODRESTRICTION_SAVE /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aMETHODRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aPart CHAR := null /* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,aMethod CHAR/* Метод *//* Метод */
,aIsRestricted
 NUMBER/* Запрещено использовать *//* Запрещено использовать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from METHODRESTRICTION where METHODRESTRICTIONID=aMETHODRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from METHODRESTRICTION where METHODRESTRICTIONid=aMETHODRESTRICTIONID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:METHODRESTRICTION',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=METHODRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 METHODRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMETHODRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=METHODRESTRICTION');
    return;
  end if;
 -- update row  --
 update  METHODRESTRICTION set ChangeStamp=sysdate
,
  Part=aPart
,
  Method=aMethod
,
  IsRestricted=aIsRestricted
  where  METHODRESTRICTIONID = aMETHODRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:METHODRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=METHODRESTRICTION');
      return;
    end if;
 end if;
 OBJECTMODE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=METHODRESTRICTION');
    return;
  end if;
 insert into   METHODRESTRICTION
 (  METHODRESTRICTIONID 
,ParentStructRowID
,Part

,Method

,IsRestricted

 ) values ( aMETHODRESTRICTIONID 
,aParentStructRowID
,aPart

,aMethod

,aIsRestricted

 ); 
 METHODRESTRICTION_SINIT( aCURSESSION,aMETHODRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure METHODRESTRICTION_PARENT /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from METHODRESTRICTION where  METHODRESTRICTIONid=aRowID;
  aParentTable := 'OBJECTMODE';
 end; 

procedure METHODRESTRICTION_ISLOCKED /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from METHODRESTRICTION where METHODRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  METHODRESTRICTION_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure METHODRESTRICTION_LOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 METHODRESTRICTION_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  METHODRESTRICTION_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from METHODRESTRICTION where METHODRESTRICTIONid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=METHODRESTRICTION');
    return;
  end if;
   if  aLockMode =2  
   then   
    update METHODRESTRICTION set LockUserID =auserID ,LockSessionID =null where METHODRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update METHODRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
 end ;

procedure METHODRESTRICTION_HCL /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure METHODRESTRICTION_UNLOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 METHODRESTRICTION_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update METHODRESTRICTION set LockUserID =null  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update METHODRESTRICTION set LockSessionID =null  where METHODRESTRICTIONid=aRowID;
     return;
   end if;
 end; 

procedure METHODRESTRICTION_SINIT /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from METHODRESTRICTION where METHODRESTRICTIONid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =METHODRESTRICTION');
    return;
  end if;
if aSecurityStyleID is null then
 METHODRESTRICTION_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update METHODRESTRICTION set securitystyleid =aStyleID where METHODRESTRICTIONid = aRowID;
else 
 update METHODRESTRICTION set securitystyleid =aSecurityStyleID where METHODRESTRICTIONid = aRowID;
end if; 
end ; 

procedure METHODRESTRICTION_propagate /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from METHODRESTRICTION where METHODRESTRICTIONid=aRowid;
end;


procedure FIELDRESTRICTION_BRIEF  (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDRESTRICTIONid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDRESTRICTION where FIELDRESTRICTIONid=aFIELDRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDRESTRICTION');
    return;
  end if;
  aBRIEF:=func.FIELDRESTRICTION_BRIEF_F(aFIELDRESTRICTIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDRESTRICTION_DELETE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDRESTRICTION where FIELDRESTRICTIONid=aFIELDRESTRICTIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDRESTRICTION is select  instanceid ID from instance where OwnerPartName ='FIELDRESTRICTION' and OwnerRowID=aFIELDRESTRICTIONid;
row_FIELDRESTRICTION  chld_FIELDRESTRICTION%ROWTYPE;
begin
--open chld_FIELDRESTRICTION;
for row_FIELDRESTRICTION in chld_FIELDRESTRICTION loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDRESTRICTION.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDRESTRICTION.id);
end loop;
--close chld_FIELDRESTRICTION;
end ;
  delete from  FIELDRESTRICTION 
  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничения полей*/
procedure FIELDRESTRICTION_SAVE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aFIELDRESTRICTIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aThePart CHAR/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,aTheField CHAR/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aAllowRead
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aAllowModify
 NUMBER/* Разрешена модификация *//* Разрешена модификация */
,aMandatoryField
 NUMBER := null /* Обязательное поле *//* Обязательное поле */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDRESTRICTION where FIELDRESTRICTIONID=aFIELDRESTRICTIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDRESTRICTION where FIELDRESTRICTIONid=aFIELDRESTRICTIONID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDRESTRICTION',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDRESTRICTION');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDRESTRICTION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDRESTRICTIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
 -- update row  --
 update  FIELDRESTRICTION set ChangeStamp=sysdate
,
  ThePart=aThePart
,
  TheField=aTheField
,
  AllowRead=aAllowRead
,
  AllowModify=aAllowModify
,
  MandatoryField=aMandatoryField
  where  FIELDRESTRICTIONID = aFIELDRESTRICTIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTMODE where OBJECTMODEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDRESTRICTION',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDRESTRICTION');
      return;
    end if;
 end if;
 OBJECTMODE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDRESTRICTION');
    return;
  end if;
 insert into   FIELDRESTRICTION
 (  FIELDRESTRICTIONID 
,ParentStructRowID
,ThePart

,TheField

,AllowRead

,AllowModify

,MandatoryField

 ) values ( aFIELDRESTRICTIONID 
,aParentStructRowID
,aThePart

,aTheField

,aAllowRead

,aAllowModify

,aMandatoryField

 ); 
 FIELDRESTRICTION_SINIT( aCURSESSION,aFIELDRESTRICTIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDRESTRICTION_PARENT /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDRESTRICTION where  FIELDRESTRICTIONid=aRowID;
  aParentTable := 'OBJECTMODE';
 end; 

procedure FIELDRESTRICTION_ISLOCKED /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDRESTRICTION where FIELDRESTRICTIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDRESTRICTION_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDRESTRICTION_LOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDRESTRICTION_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDRESTRICTION_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDRESTRICTION where FIELDRESTRICTIONid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDRESTRICTION');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDRESTRICTION set LockUserID =auserID ,LockSessionID =null where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDRESTRICTION set LockUserID =null,LockSessionID =aCURSESSION  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
 end ;

procedure FIELDRESTRICTION_HCL /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDRESTRICTION_UNLOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDRESTRICTION_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDRESTRICTION set LockUserID =null  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDRESTRICTION set LockSessionID =null  where FIELDRESTRICTIONid=aRowID;
     return;
   end if;
 end; 

procedure FIELDRESTRICTION_SINIT /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDRESTRICTION where FIELDRESTRICTIONid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDRESTRICTION');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDRESTRICTION_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDRESTRICTION set securitystyleid =aStyleID where FIELDRESTRICTIONid = aRowID;
else 
 update FIELDRESTRICTION set securitystyleid =aSecurityStyleID where FIELDRESTRICTIONid = aRowID;
end if; 
end ; 

procedure FIELDRESTRICTION_propagate /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDRESTRICTION where FIELDRESTRICTIONid=aRowid;
end;


procedure TYPEMENU_BRIEF  (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aTYPEMENUid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from TYPEMENU where TYPEMENUid=aTYPEMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=TYPEMENU');
    return;
  end if;
  aBRIEF:=func.TYPEMENU_BRIEF_F(aTYPEMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure TYPEMENU_DELETE /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from TYPEMENU where TYPEMENUid=aTYPEMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:TYPEMENU',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=TYPEMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 TYPEMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aTYPEMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=TYPEMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_TYPEMENU is select  instanceid ID from instance where OwnerPartName ='TYPEMENU' and OwnerRowID=aTYPEMENUid;
row_TYPEMENU  chld_TYPEMENU%ROWTYPE;
begin
--open chld_TYPEMENU;
for row_TYPEMENU in chld_TYPEMENU loop
 Kernel.INSTANCE_OWNER (acursession,row_TYPEMENU.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_TYPEMENU.id);
end loop;
--close chld_TYPEMENU;
end ;
  delete from  TYPEMENU 
  where  TYPEMENUID = aTYPEMENUID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы типа*/
procedure TYPEMENU_SAVE /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aTYPEMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_Action CHAR := null /* Метод *//* Метод */
,aIsMenuItem
 NUMBER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 NUMBER/* Включать в тулбар *//* Включать в тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from TYPEMENU where TYPEMENUID=aTYPEMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from TYPEMENU where TYPEMENUid=aTYPEMENUID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:TYPEMENU',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=TYPEMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 TYPEMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aTYPEMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=TYPEMENU');
    return;
  end if;
 -- update row  --
 update  TYPEMENU set ChangeStamp=sysdate
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  the_Action=athe_Action
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  TYPEMENUID = aTYPEMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:TYPEMENU',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=TYPEMENU');
      return;
    end if;
 end if;
 OBJECTTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=TYPEMENU');
    return;
  end if;
 insert into   TYPEMENU
 (  TYPEMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,the_Action

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aTYPEMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,athe_Action

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 TYPEMENU_SINIT( aCURSESSION,aTYPEMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure TYPEMENU_PARENT /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from TYPEMENU where  TYPEMENUid=aRowID;
  aParentTable := 'OBJECTTYPE';
 end; 

procedure TYPEMENU_ISLOCKED /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from TYPEMENU where TYPEMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  TYPEMENU_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure TYPEMENU_LOCK /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 TYPEMENU_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  TYPEMENU_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from TYPEMENU where TYPEMENUid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=TYPEMENU');
    return;
  end if;
   if  aLockMode =2  
   then   
    update TYPEMENU set LockUserID =auserID ,LockSessionID =null where TYPEMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update TYPEMENU set LockUserID =null,LockSessionID =aCURSESSION  where TYPEMENUid=aRowID;
     return;
   end if;
 end ;

procedure TYPEMENU_HCL /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure TYPEMENU_UNLOCK /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 TYPEMENU_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update TYPEMENU set LockUserID =null  where TYPEMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update TYPEMENU set LockSessionID =null  where TYPEMENUid=aRowID;
     return;
   end if;
 end; 

procedure TYPEMENU_SINIT /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from TYPEMENU where TYPEMENUid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =TYPEMENU');
    return;
  end if;
if aSecurityStyleID is null then
 TYPEMENU_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update TYPEMENU set securitystyleid =aStyleID where TYPEMENUid = aRowID;
else 
 update TYPEMENU set securitystyleid =aSecurityStyleID where TYPEMENUid = aRowID;
end if; 
end ; 

procedure TYPEMENU_propagate /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from TYPEMENU where TYPEMENUid=aRowid;
end;


procedure INSTANCEVALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aINSTANCEVALIDATORid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aINSTANCEVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=INSTANCEVALIDATOR');
    return;
  end if;
  aBRIEF:=func.INSTANCEVALIDATOR_BRIEF_F(aINSTANCEVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure INSTANCEVALIDATOR_DELETE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aINSTANCEVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:INSTANCEVALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=INSTANCEVALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 INSTANCEVALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aINSTANCEVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_INSTANCEVALIDATOR is select  instanceid ID from instance where OwnerPartName ='INSTANCEVALIDATOR' and OwnerRowID=aINSTANCEVALIDATORid;
row_INSTANCEVALIDATOR  chld_INSTANCEVALIDATOR%ROWTYPE;
begin
--open chld_INSTANCEVALIDATOR;
for row_INSTANCEVALIDATOR in chld_INSTANCEVALIDATOR loop
 Kernel.INSTANCE_OWNER (acursession,row_INSTANCEVALIDATOR.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_INSTANCEVALIDATOR.id);
end loop;
--close chld_INSTANCEVALIDATOR;
end ;
  delete from  INSTANCEVALIDATOR 
  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Проверка правильности*/
procedure INSTANCEVALIDATOR_SAVE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aINSTANCEVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from INSTANCEVALIDATOR where INSTANCEVALIDATORID=aINSTANCEVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aINSTANCEVALIDATORID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:INSTANCEVALIDATOR',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=INSTANCEVALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 INSTANCEVALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aINSTANCEVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
 -- update row  --
 update  INSTANCEVALIDATOR set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  INSTANCEVALIDATORID = aINSTANCEVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:INSTANCEVALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=INSTANCEVALIDATOR');
      return;
    end if;
 end if;
 OBJECTTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
 insert into   INSTANCEVALIDATOR
 (  INSTANCEVALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aINSTANCEVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 INSTANCEVALIDATOR_SINIT( aCURSESSION,aINSTANCEVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure INSTANCEVALIDATOR_PARENT /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from INSTANCEVALIDATOR where  INSTANCEVALIDATORid=aRowID;
  aParentTable := 'OBJECTTYPE';
 end; 

procedure INSTANCEVALIDATOR_ISLOCKED /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  INSTANCEVALIDATOR_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure INSTANCEVALIDATOR_LOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 INSTANCEVALIDATOR_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  INSTANCEVALIDATOR_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=INSTANCEVALIDATOR');
    return;
  end if;
   if  aLockMode =2  
   then   
    update INSTANCEVALIDATOR set LockUserID =auserID ,LockSessionID =null where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update INSTANCEVALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
 end ;

procedure INSTANCEVALIDATOR_HCL /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure INSTANCEVALIDATOR_UNLOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 INSTANCEVALIDATOR_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update INSTANCEVALIDATOR set LockUserID =null  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update INSTANCEVALIDATOR set LockSessionID =null  where INSTANCEVALIDATORid=aRowID;
     return;
   end if;
 end; 

procedure INSTANCEVALIDATOR_SINIT /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =INSTANCEVALIDATOR');
    return;
  end if;
if aSecurityStyleID is null then
 INSTANCEVALIDATOR_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update INSTANCEVALIDATOR set securitystyleid =aStyleID where INSTANCEVALIDATORid = aRowID;
else 
 update INSTANCEVALIDATOR set securitystyleid =aSecurityStyleID where INSTANCEVALIDATORid = aRowID;
end if; 
end ; 

procedure INSTANCEVALIDATOR_propagate /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from INSTANCEVALIDATOR where INSTANCEVALIDATORid=aRowid;
end;


procedure PART_BRIEF  (
 aCURSESSION CHAR,
 aPARTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PART where PARTid=aPARTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PART');
    return;
  end if;
  aBRIEF:=func.PART_BRIEF_F(aPARTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PART_DELETE /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aPARTid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PART where PARTid=aPARTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PART',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PART');
      return;
    end if;
  end if;
 --  verify lock  --
 PART_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PART');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_PARTMENU is select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aPARTid;
    child_PARTMENU_rec  child_PARTMENU%ROWTYPE;
    begin
    --open child_PARTMENU;
      for child_PARTMENU_rec in child_PARTMENU loop
      PARTMENU_DELETE (acursession,child_PARTMENU_rec.id,aInstanceid);
      end loop;
      --close child_PARTMENU;
    end ;
    declare cursor child_PARTVIEW is select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aPARTid;
    child_PARTVIEW_rec  child_PARTVIEW%ROWTYPE;
    begin
    --open child_PARTVIEW;
      for child_PARTVIEW_rec in child_PARTVIEW loop
      PARTVIEW_DELETE (acursession,child_PARTVIEW_rec.id,aInstanceid);
      end loop;
      --close child_PARTVIEW;
    end ;
    declare cursor child_VALIDATOR is select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aPARTid;
    child_VALIDATOR_rec  child_VALIDATOR%ROWTYPE;
    begin
    --open child_VALIDATOR;
      for child_VALIDATOR_rec in child_VALIDATOR loop
      VALIDATOR_DELETE (acursession,child_VALIDATOR_rec.id,aInstanceid);
      end loop;
      --close child_VALIDATOR;
    end ;
    declare cursor child_UNIQUECONSTRAINT is select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aPARTid;
    child_UNIQUECONSTRAINT_rec  child_UNIQUECONSTRAINT%ROWTYPE;
    begin
    --open child_UNIQUECONSTRAINT;
      for child_UNIQUECONSTRAINT_rec in child_UNIQUECONSTRAINT loop
      UNIQUECONSTRAINT_DELETE (acursession,child_UNIQUECONSTRAINT_rec.id,aInstanceid);
      end loop;
      --close child_UNIQUECONSTRAINT;
    end ;
    declare cursor child_ExtenderInterface is select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aPARTid;
    child_ExtenderInterface_rec  child_ExtenderInterface%ROWTYPE;
    begin
    --open child_ExtenderInterface;
      for child_ExtenderInterface_rec in child_ExtenderInterface loop
      ExtenderInterface_DELETE (acursession,child_ExtenderInterface_rec.id,aInstanceid);
      end loop;
      --close child_ExtenderInterface;
    end ;
    declare cursor child_FIELD is select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aPARTid;
    child_FIELD_rec  child_FIELD%ROWTYPE;
    begin
    --open child_FIELD;
      for child_FIELD_rec in child_FIELD loop
      FIELD_DELETE (acursession,child_FIELD_rec.id,aInstanceid);
      end loop;
      --close child_FIELD;
    end ;
declare cursor chld_PART is select  instanceid ID from instance where OwnerPartName ='PART' and OwnerRowID=aPARTid;
row_PART  chld_PART%ROWTYPE;
begin
--open chld_PART;
for row_PART in chld_PART loop
 Kernel.INSTANCE_OWNER (acursession,row_PART.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PART.id);
end loop;
--close chld_PART;
end ;
  delete from  PART 
  where  PARTID = aPARTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Раздел*/
procedure PART_SAVE /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aPARTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
, aParentRowid CHAR :=null
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aPartType
 NUMBER/* Тип структры *//* Тип структры */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aName
 VARCHAR2/* Название *//* Название */
,athe_Comment VARCHAR2 := null /* Описание *//* Описание */
,aNoLog
 NUMBER/* Не записывать в журнал *//* Не записывать в журнал */
,aManualRegister
 NUMBER/* Исключить из индексирования *//* Исключить из индексирования */
,aOnCreate CHAR := null /* При создании *//* При создании */
,aOnSave CHAR := null /* При сохранении *//* При сохранении */
,aOnRun CHAR := null /* При открытии *//* При открытии */
,aOnDelete CHAR := null /* При удалении *//* При удалении */
,aAddBehaivor
 NUMBER := null /* Поведение при добавлении *//* Поведение при добавлении */
,aExtenderObject CHAR := null /* Объект расширения *//* Объект расширения */
,ashablonBrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,aruleBrief
 VARCHAR2 := null /* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aIsJormalChange
 NUMBER/* Вести журнал изменений *//* Вести журнал изменений */
,aUseArchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aintegerpkey
 NUMBER/* Целочисленный ключ *//* Целочисленный ключ */
,apartIconCls
 VARCHAR2 := null /* Иконка раздела *//* Иконка раздела */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PART where PARTID=aPARTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PART where PARTid=aPARTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PART',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PART');
      return;
    end if;
  end if;
 --  verify lock  --
 PART_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PART');
    return;
  end if;
 -- update row  --
 update  PART set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  Sequence=aSequence
,
  PartType=aPartType
,
  Caption=aCaption
,
  Name=aName
,
  the_Comment=athe_Comment
,
  NoLog=aNoLog
,
  ManualRegister=aManualRegister
,
  OnCreate=aOnCreate
,
  OnSave=aOnSave
,
  OnRun=aOnRun
,
  OnDelete=aOnDelete
,
  AddBehaivor=aAddBehaivor
,
  ExtenderObject=aExtenderObject
,
  shablonBrief=ashablonBrief
,
  ruleBrief=aruleBrief
,
  IsJormalChange=aIsJormalChange
,
  UseArchiving=aUseArchiving
,
  integerpkey=aintegerpkey
,
  partIconCls=apartIconCls
  where  PARTID = aPARTID; 
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and Sequence=aSequence;
 else 
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and Sequence=aSequence;
 end if;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;
select Count(*) into aUniqueRowCount from PART where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from OBJECTTYPE where OBJECTTYPEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PART',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PART');
      return;
    end if;
 end if;
 OBJECTTYPE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PART');
    return;
  end if;
 insert into   PART
 (  PARTID 
,ParentRowid
,ParentStructRowID
,Sequence

,PartType

,Caption

,Name

,the_Comment

,NoLog

,ManualRegister

,OnCreate

,OnSave

,OnRun

,OnDelete

,AddBehaivor

,ExtenderObject

,shablonBrief

,ruleBrief

,IsJormalChange

,UseArchiving

,integerpkey

,partIconCls

 ) values ( aPARTID 
,aParentRowid
,aParentStructRowID
,aSequence

,aPartType

,aCaption

,aName

,athe_Comment

,aNoLog

,aManualRegister

,aOnCreate

,aOnSave

,aOnRun

,aOnDelete

,aAddBehaivor

,aExtenderObject

,ashablonBrief

,aruleBrief

,aIsJormalChange

,aUseArchiving

,aintegerpkey

,apartIconCls

 ); 
 PART_SINIT( aCURSESSION,aPARTid,atmpid);
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and Sequence=aSequence;
 else 
   select Count(*) into aUniqueRowCount from PART where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and Sequence=aSequence;
 end if;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;
select Count(*) into aUniqueRowCount from PART where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=PART');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure PART_PARENT /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PART where  PARTid=aRowID;
  aParentTable := 'OBJECTTYPE';
 end; 

procedure PART_ISLOCKED /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PART where PARTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PART_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PART_LOCK /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PART_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PART_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PART where PARTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PART');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PART set LockUserID =auserID ,LockSessionID =null where PARTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PART set LockUserID =null,LockSessionID =aCURSESSION  where PARTid=aRowID;
     return;
   end if;
 end ;

procedure PART_HCL /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_PARTMENU is select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aRowid;
row_PARTMENU lch_PARTMENU%ROWTYPE;
begin  
--open lch_PARTMENU;
for row_PARTMENU in lch_PARTMENU
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTMENU where PARTMENUid=row_PARTMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PARTMENU;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PARTMENU;
     return;
   end if; 
 end if;  
 PARTMENU_HCL (acursession,row_PARTMENU.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PARTMENU;
   return;
 end if;
end loop;
--close lch_PARTMENU;
end;
declare cursor lch_PARTVIEW is select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aRowid;
row_PARTVIEW lch_PARTVIEW%ROWTYPE;
begin  
--open lch_PARTVIEW;
for row_PARTVIEW in lch_PARTVIEW
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTVIEW where PARTVIEWid=row_PARTVIEW.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PARTVIEW;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PARTVIEW;
     return;
   end if; 
 end if;  
 PARTVIEW_HCL (acursession,row_PARTVIEW.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PARTVIEW;
   return;
 end if;
end loop;
--close lch_PARTVIEW;
end;
declare cursor lch_VALIDATOR is select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aRowid;
row_VALIDATOR lch_VALIDATOR%ROWTYPE;
begin  
--open lch_VALIDATOR;
for row_VALIDATOR in lch_VALIDATOR
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from VALIDATOR where VALIDATORid=row_VALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_VALIDATOR;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_VALIDATOR;
     return;
   end if; 
 end if;  
 VALIDATOR_HCL (acursession,row_VALIDATOR.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_VALIDATOR;
   return;
 end if;
end loop;
--close lch_VALIDATOR;
end;
declare cursor lch_UNIQUECONSTRAINT is select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aRowid;
row_UNIQUECONSTRAINT lch_UNIQUECONSTRAINT%ROWTYPE;
begin  
--open lch_UNIQUECONSTRAINT;
for row_UNIQUECONSTRAINT in lch_UNIQUECONSTRAINT
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=row_UNIQUECONSTRAINT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_UNIQUECONSTRAINT;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_UNIQUECONSTRAINT;
     return;
   end if; 
 end if;  
 UNIQUECONSTRAINT_HCL (acursession,row_UNIQUECONSTRAINT.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_UNIQUECONSTRAINT;
   return;
 end if;
end loop;
--close lch_UNIQUECONSTRAINT;
end;
declare cursor lch_ExtenderInterface is select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aRowid;
row_ExtenderInterface lch_ExtenderInterface%ROWTYPE;
begin  
--open lch_ExtenderInterface;
for row_ExtenderInterface in lch_ExtenderInterface
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ExtenderInterface where ExtenderInterfaceid=row_ExtenderInterface.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ExtenderInterface;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ExtenderInterface;
     return;
   end if; 
 end if;  
 ExtenderInterface_HCL (acursession,row_ExtenderInterface.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ExtenderInterface;
   return;
 end if;
end loop;
--close lch_ExtenderInterface;
end;
declare cursor lch_FIELD is select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aRowid;
row_FIELD lch_FIELD%ROWTYPE;
begin  
--open lch_FIELD;
for row_FIELD in lch_FIELD
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELD where FIELDid=row_FIELD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELD;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELD;
     return;
   end if; 
 end if;  
 FIELD_HCL (acursession,row_FIELD.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELD;
   return;
 end if;
end loop;
--close lch_FIELD;
end;
aIsLocked :=0;
end;

procedure PART_UNLOCK /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PART_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PART set LockUserID =null  where PARTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PART set LockSessionID =null  where PARTid=aRowID;
     return;
   end if;
 end; 

procedure PART_SINIT /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PART where PARTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PART');
    return;
  end if;
if aSecurityStyleID is null then
 PART_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PART set securitystyleid =aStyleID where PARTid = aRowID;
else 
 update PART set securitystyleid =aSecurityStyleID where PARTid = aRowID;
end if; 
end ; 

procedure PART_propagate /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PART where PARTid=aRowid;
declare cursor pch_PARTMENU  is select PARTMENU.PARTMENUid ID from PARTMENU where  PARTMENU.ParentStructRowID = aRowid;
row_PARTMENU  pch_PARTMENU%ROWTYPE;
begin
--open pch_PARTMENU;
for row_PARTMENU in pch_PARTMENU loop
   PARTMENU_SINIT( acursession,row_PARTMENU.id,assid);
   PARTMENU_propagate( acursession,row_PARTMENU.id);
end loop;
--close pch_PARTMENU;
end;
declare cursor pch_PARTVIEW  is select PARTVIEW.PARTVIEWid ID from PARTVIEW where  PARTVIEW.ParentStructRowID = aRowid;
row_PARTVIEW  pch_PARTVIEW%ROWTYPE;
begin
--open pch_PARTVIEW;
for row_PARTVIEW in pch_PARTVIEW loop
   PARTVIEW_SINIT( acursession,row_PARTVIEW.id,assid);
   PARTVIEW_propagate( acursession,row_PARTVIEW.id);
end loop;
--close pch_PARTVIEW;
end;
declare cursor pch_VALIDATOR  is select VALIDATOR.VALIDATORid ID from VALIDATOR where  VALIDATOR.ParentStructRowID = aRowid;
row_VALIDATOR  pch_VALIDATOR%ROWTYPE;
begin
--open pch_VALIDATOR;
for row_VALIDATOR in pch_VALIDATOR loop
   VALIDATOR_SINIT( acursession,row_VALIDATOR.id,assid);
   VALIDATOR_propagate( acursession,row_VALIDATOR.id);
end loop;
--close pch_VALIDATOR;
end;
declare cursor pch_UNIQUECONSTRAINT  is select UNIQUECONSTRAINT.UNIQUECONSTRAINTid ID from UNIQUECONSTRAINT where  UNIQUECONSTRAINT.ParentStructRowID = aRowid;
row_UNIQUECONSTRAINT  pch_UNIQUECONSTRAINT%ROWTYPE;
begin
--open pch_UNIQUECONSTRAINT;
for row_UNIQUECONSTRAINT in pch_UNIQUECONSTRAINT loop
   UNIQUECONSTRAINT_SINIT( acursession,row_UNIQUECONSTRAINT.id,assid);
   UNIQUECONSTRAINT_propagate( acursession,row_UNIQUECONSTRAINT.id);
end loop;
--close pch_UNIQUECONSTRAINT;
end;
declare cursor pch_ExtenderInterface  is select ExtenderInterface.ExtenderInterfaceid ID from ExtenderInterface where  ExtenderInterface.ParentStructRowID = aRowid;
row_ExtenderInterface  pch_ExtenderInterface%ROWTYPE;
begin
--open pch_ExtenderInterface;
for row_ExtenderInterface in pch_ExtenderInterface loop
   ExtenderInterface_SINIT( acursession,row_ExtenderInterface.id,assid);
   ExtenderInterface_propagate( acursession,row_ExtenderInterface.id);
end loop;
--close pch_ExtenderInterface;
end;
declare cursor pch_FIELD  is select FIELD.FIELDid ID from FIELD where  FIELD.ParentStructRowID = aRowid;
row_FIELD  pch_FIELD%ROWTYPE;
begin
--open pch_FIELD;
for row_FIELD in pch_FIELD loop
   FIELD_SINIT( acursession,row_FIELD.id,assid);
   FIELD_propagate( acursession,row_FIELD.id);
end loop;
--close pch_FIELD;
end;
end;


procedure PARTMENU_BRIEF  (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARTMENUid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PARTMENU where PARTMENUid=aPARTMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PARTMENU');
    return;
  end if;
  aBRIEF:=func.PARTMENU_BRIEF_F(aPARTMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PARTMENU_DELETE /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PARTMENU where PARTMENUid=aPARTMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PARTMENU',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PARTMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_PARTPARAMMAP is select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aPARTMENUid;
    child_PARTPARAMMAP_rec  child_PARTPARAMMAP%ROWTYPE;
    begin
    --open child_PARTPARAMMAP;
      for child_PARTPARAMMAP_rec in child_PARTPARAMMAP loop
      PARTPARAMMAP_DELETE (acursession,child_PARTPARAMMAP_rec.id,aInstanceid);
      end loop;
      --close child_PARTPARAMMAP;
    end ;
declare cursor chld_PARTMENU is select  instanceid ID from instance where OwnerPartName ='PARTMENU' and OwnerRowID=aPARTMENUid;
row_PARTMENU  chld_PARTMENU%ROWTYPE;
begin
--open chld_PARTMENU;
for row_PARTMENU in chld_PARTMENU loop
 Kernel.INSTANCE_OWNER (acursession,row_PARTMENU.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PARTMENU.id);
end loop;
--close chld_PARTMENU;
end ;
  delete from  PARTMENU 
  where  PARTMENUID = aPARTMENUID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы раздела*/
procedure PARTMENU_SAVE /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aPARTMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_Action CHAR := null /* Метод *//* Метод */
,aIsMenuItem
 NUMBER/* Включать в меню *//* Включать в меню */
,aIsToolBarButton
 NUMBER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTMENU where PARTMENUID=aPARTMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PARTMENU where PARTMENUid=aPARTMENUID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PARTMENU',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PARTMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTMENU');
    return;
  end if;
 -- update row  --
 update  PARTMENU set ChangeStamp=sysdate
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  the_Action=athe_Action
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  PARTMENUID = aPARTMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PARTMENU',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PARTMENU');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTMENU');
    return;
  end if;
 insert into   PARTMENU
 (  PARTMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,the_Action

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aPARTMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,athe_Action

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 PARTMENU_SINIT( aCURSESSION,aPARTMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure PARTMENU_PARENT /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PARTMENU where  PARTMENUid=aRowID;
  aParentTable := 'PART';
 end; 

procedure PARTMENU_ISLOCKED /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTMENU where PARTMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PARTMENU_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PARTMENU_LOCK /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PARTMENU_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PARTMENU_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PARTMENU where PARTMENUid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PARTMENU');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PARTMENU set LockUserID =auserID ,LockSessionID =null where PARTMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTMENU set LockUserID =null,LockSessionID =aCURSESSION  where PARTMENUid=aRowID;
     return;
   end if;
 end ;

procedure PARTMENU_HCL /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_PARTPARAMMAP is select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aRowid;
row_PARTPARAMMAP lch_PARTPARAMMAP%ROWTYPE;
begin  
--open lch_PARTPARAMMAP;
for row_PARTPARAMMAP in lch_PARTPARAMMAP
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTPARAMMAP where PARTPARAMMAPid=row_PARTPARAMMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PARTPARAMMAP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PARTPARAMMAP;
     return;
   end if; 
 end if;  
 PARTPARAMMAP_HCL (acursession,row_PARTPARAMMAP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PARTPARAMMAP;
   return;
 end if;
end loop;
--close lch_PARTPARAMMAP;
end;
aIsLocked :=0;
end;

procedure PARTMENU_UNLOCK /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PARTMENU_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTMENU set LockUserID =null  where PARTMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTMENU set LockSessionID =null  where PARTMENUid=aRowID;
     return;
   end if;
 end; 

procedure PARTMENU_SINIT /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PARTMENU where PARTMENUid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PARTMENU');
    return;
  end if;
if aSecurityStyleID is null then
 PARTMENU_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PARTMENU set securitystyleid =aStyleID where PARTMENUid = aRowID;
else 
 update PARTMENU set securitystyleid =aSecurityStyleID where PARTMENUid = aRowID;
end if; 
end ; 

procedure PARTMENU_propagate /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PARTMENU where PARTMENUid=aRowid;
declare cursor pch_PARTPARAMMAP  is select PARTPARAMMAP.PARTPARAMMAPid ID from PARTPARAMMAP where  PARTPARAMMAP.ParentStructRowID = aRowid;
row_PARTPARAMMAP  pch_PARTPARAMMAP%ROWTYPE;
begin
--open pch_PARTPARAMMAP;
for row_PARTPARAMMAP in pch_PARTPARAMMAP loop
   PARTPARAMMAP_SINIT( acursession,row_PARTPARAMMAP.id,assid);
   PARTPARAMMAP_propagate( acursession,row_PARTPARAMMAP.id);
end loop;
--close pch_PARTPARAMMAP;
end;
end;


procedure PARTPARAMMAP_BRIEF  (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARTPARAMMAPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PARTPARAMMAP where PARTPARAMMAPid=aPARTPARAMMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PARTPARAMMAP');
    return;
  end if;
  aBRIEF:=func.PARTPARAMMAP_BRIEF_F(aPARTPARAMMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PARTPARAMMAP_DELETE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PARTPARAMMAP where PARTPARAMMAPid=aPARTPARAMMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PARTPARAMMAP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PARTPARAMMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTPARAMMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTPARAMMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTPARAMMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_PARTPARAMMAP is select  instanceid ID from instance where OwnerPartName ='PARTPARAMMAP' and OwnerRowID=aPARTPARAMMAPid;
row_PARTPARAMMAP  chld_PARTPARAMMAP%ROWTYPE;
begin
--open chld_PARTPARAMMAP;
for row_PARTPARAMMAP in chld_PARTPARAMMAP loop
 Kernel.INSTANCE_OWNER (acursession,row_PARTPARAMMAP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PARTPARAMMAP.id);
end loop;
--close chld_PARTPARAMMAP;
end ;
  delete from  PARTPARAMMAP 
  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение параметров*/
procedure PARTPARAMMAP_SAVE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aPARTPARAMMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aFieldName
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR2/* Параметр *//* Параметр */
,aNoEdit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTPARAMMAP where PARTPARAMMAPID=aPARTPARAMMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PARTPARAMMAP where PARTPARAMMAPid=aPARTPARAMMAPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PARTPARAMMAP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PARTPARAMMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTPARAMMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTPARAMMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTPARAMMAP');
    return;
  end if;
 -- update row  --
 update  PARTPARAMMAP set ChangeStamp=sysdate
,
  FieldName=aFieldName
,
  ParamName=aParamName
,
  NoEdit=aNoEdit
  where  PARTPARAMMAPID = aPARTPARAMMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PARTMENU where PARTMENUid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PARTPARAMMAP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PARTPARAMMAP');
      return;
    end if;
 end if;
 PARTMENU_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTPARAMMAP');
    return;
  end if;
 insert into   PARTPARAMMAP
 (  PARTPARAMMAPID 
,ParentStructRowID
,FieldName

,ParamName

,NoEdit

 ) values ( aPARTPARAMMAPID 
,aParentStructRowID
,aFieldName

,aParamName

,aNoEdit

 ); 
 PARTPARAMMAP_SINIT( aCURSESSION,aPARTPARAMMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure PARTPARAMMAP_PARENT /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PARTPARAMMAP where  PARTPARAMMAPid=aRowID;
  aParentTable := 'PARTMENU';
 end; 

procedure PARTPARAMMAP_ISLOCKED /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTPARAMMAP where PARTPARAMMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PARTPARAMMAP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PARTPARAMMAP_LOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PARTPARAMMAP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PARTPARAMMAP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PARTPARAMMAP where PARTPARAMMAPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PARTPARAMMAP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PARTPARAMMAP set LockUserID =auserID ,LockSessionID =null where PARTPARAMMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTPARAMMAP set LockUserID =null,LockSessionID =aCURSESSION  where PARTPARAMMAPid=aRowID;
     return;
   end if;
 end ;

procedure PARTPARAMMAP_HCL /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure PARTPARAMMAP_UNLOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PARTPARAMMAP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTPARAMMAP set LockUserID =null  where PARTPARAMMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTPARAMMAP set LockSessionID =null  where PARTPARAMMAPid=aRowID;
     return;
   end if;
 end; 

procedure PARTPARAMMAP_SINIT /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PARTPARAMMAP where PARTPARAMMAPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PARTPARAMMAP');
    return;
  end if;
if aSecurityStyleID is null then
 PARTPARAMMAP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PARTPARAMMAP set securitystyleid =aStyleID where PARTPARAMMAPid = aRowID;
else 
 update PARTPARAMMAP set securitystyleid =aSecurityStyleID where PARTPARAMMAPid = aRowID;
end if; 
end ; 

procedure PARTPARAMMAP_propagate /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PARTPARAMMAP where PARTPARAMMAPid=aRowid;
end;


procedure PARTVIEW_BRIEF  (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARTVIEWid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PARTVIEW where PARTVIEWid=aPARTVIEWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PARTVIEW');
    return;
  end if;
  aBRIEF:=func.PARTVIEW_BRIEF_F(aPARTVIEWid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PARTVIEW_DELETE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aPARTVIEWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PARTVIEW',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PARTVIEW');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTVIEW_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTVIEWid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTVIEW');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ViewColumn is select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aPARTVIEWid;
    child_ViewColumn_rec  child_ViewColumn%ROWTYPE;
    begin
    --open child_ViewColumn;
      for child_ViewColumn_rec in child_ViewColumn loop
      ViewColumn_DELETE (acursession,child_ViewColumn_rec.id,aInstanceid);
      end loop;
      --close child_ViewColumn;
    end ;
    declare cursor child_PARTVIEW_LNK is select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aPARTVIEWid;
    child_PARTVIEW_LNK_rec  child_PARTVIEW_LNK%ROWTYPE;
    begin
    --open child_PARTVIEW_LNK;
      for child_PARTVIEW_LNK_rec in child_PARTVIEW_LNK loop
      PARTVIEW_LNK_DELETE (acursession,child_PARTVIEW_LNK_rec.id,aInstanceid);
      end loop;
      --close child_PARTVIEW_LNK;
    end ;
declare cursor chld_PARTVIEW is select  instanceid ID from instance where OwnerPartName ='PARTVIEW' and OwnerRowID=aPARTVIEWid;
row_PARTVIEW  chld_PARTVIEW%ROWTYPE;
begin
--open chld_PARTVIEW;
for row_PARTVIEW in chld_PARTVIEW loop
 Kernel.INSTANCE_OWNER (acursession,row_PARTVIEW.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PARTVIEW.id);
end loop;
--close chld_PARTVIEW;
end ;
  delete from  PARTVIEW 
  where  PARTVIEWID = aPARTVIEWID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Представление*/
procedure PARTVIEW_SAVE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aPARTVIEWid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2/* Псевдоним *//* Псевдоним */
,aForChoose
 NUMBER/* Для поиска *//* Для поиска */
,aFilterField0
 VARCHAR2 := null /* Поле - фильтр 0 *//* Поле - фильтр 0 */
,aFilterField1
 VARCHAR2 := null /* Поле - фильтр 1 *//* Поле - фильтр 1 */
,aFilterField2
 VARCHAR2 := null /* Поле - фильтр 2 *//* Поле - фильтр 2 */
,aFilterField3
 VARCHAR2 := null /* Поле - фильтр 3 *//* Поле - фильтр 3 */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTVIEW where PARTVIEWID=aPARTVIEWID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aPARTVIEWID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PARTVIEW',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PARTVIEW');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTVIEW_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTVIEWid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW');
    return;
  end if;
 -- update row  --
 update  PARTVIEW set ChangeStamp=sysdate
,
  Name=aName
,
  the_Alias=athe_Alias
,
  ForChoose=aForChoose
,
  FilterField0=aFilterField0
,
  FilterField1=aFilterField1
,
  FilterField2=aFilterField2
,
  FilterField3=aFilterField3
  where  PARTVIEWID = aPARTVIEWID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PARTVIEW',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PARTVIEW');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW');
    return;
  end if;
 insert into   PARTVIEW
 (  PARTVIEWID 
,ParentStructRowID
,Name

,the_Alias

,ForChoose

,FilterField0

,FilterField1

,FilterField2

,FilterField3

 ) values ( aPARTVIEWID 
,aParentStructRowID
,aName

,athe_Alias

,aForChoose

,aFilterField0

,aFilterField1

,aFilterField2

,aFilterField3

 ); 
 PARTVIEW_SINIT( aCURSESSION,aPARTVIEWid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure PARTVIEW_PARENT /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PARTVIEW where  PARTVIEWid=aRowID;
  aParentTable := 'PART';
 end; 

procedure PARTVIEW_ISLOCKED /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTVIEW where PARTVIEWid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PARTVIEW_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PARTVIEW_LOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PARTVIEW_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PARTVIEW_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PARTVIEW');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PARTVIEW set LockUserID =auserID ,LockSessionID =null where PARTVIEWid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTVIEW set LockUserID =null,LockSessionID =aCURSESSION  where PARTVIEWid=aRowID;
     return;
   end if;
 end ;

procedure PARTVIEW_HCL /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ViewColumn is select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aRowid;
row_ViewColumn lch_ViewColumn%ROWTYPE;
begin  
--open lch_ViewColumn;
for row_ViewColumn in lch_ViewColumn
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ViewColumn where ViewColumnid=row_ViewColumn.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ViewColumn;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ViewColumn;
     return;
   end if; 
 end if;  
 ViewColumn_HCL (acursession,row_ViewColumn.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ViewColumn;
   return;
 end if;
end loop;
--close lch_ViewColumn;
end;
declare cursor lch_PARTVIEW_LNK is select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aRowid;
row_PARTVIEW_LNK lch_PARTVIEW_LNK%ROWTYPE;
begin  
--open lch_PARTVIEW_LNK;
for row_PARTVIEW_LNK in lch_PARTVIEW_LNK
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from PARTVIEW_LNK where PARTVIEW_LNKid=row_PARTVIEW_LNK.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_PARTVIEW_LNK;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_PARTVIEW_LNK;
     return;
   end if; 
 end if;  
 PARTVIEW_LNK_HCL (acursession,row_PARTVIEW_LNK.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_PARTVIEW_LNK;
   return;
 end if;
end loop;
--close lch_PARTVIEW_LNK;
end;
aIsLocked :=0;
end;

procedure PARTVIEW_UNLOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PARTVIEW_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTVIEW set LockUserID =null  where PARTVIEWid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTVIEW set LockSessionID =null  where PARTVIEWid=aRowID;
     return;
   end if;
 end; 

procedure PARTVIEW_SINIT /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PARTVIEW');
    return;
  end if;
if aSecurityStyleID is null then
 PARTVIEW_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PARTVIEW set securitystyleid =aStyleID where PARTVIEWid = aRowID;
else 
 update PARTVIEW set securitystyleid =aSecurityStyleID where PARTVIEWid = aRowID;
end if; 
end ; 

procedure PARTVIEW_propagate /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PARTVIEW where PARTVIEWid=aRowid;
declare cursor pch_ViewColumn  is select ViewColumn.ViewColumnid ID from ViewColumn where  ViewColumn.ParentStructRowID = aRowid;
row_ViewColumn  pch_ViewColumn%ROWTYPE;
begin
--open pch_ViewColumn;
for row_ViewColumn in pch_ViewColumn loop
   ViewColumn_SINIT( acursession,row_ViewColumn.id,assid);
   ViewColumn_propagate( acursession,row_ViewColumn.id);
end loop;
--close pch_ViewColumn;
end;
declare cursor pch_PARTVIEW_LNK  is select PARTVIEW_LNK.PARTVIEW_LNKid ID from PARTVIEW_LNK where  PARTVIEW_LNK.ParentStructRowID = aRowid;
row_PARTVIEW_LNK  pch_PARTVIEW_LNK%ROWTYPE;
begin
--open pch_PARTVIEW_LNK;
for row_PARTVIEW_LNK in pch_PARTVIEW_LNK loop
   PARTVIEW_LNK_SINIT( acursession,row_PARTVIEW_LNK.id,assid);
   PARTVIEW_LNK_propagate( acursession,row_PARTVIEW_LNK.id);
end loop;
--close pch_PARTVIEW_LNK;
end;
end;


procedure ViewColumn_BRIEF  (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aViewColumnid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ViewColumn where ViewColumnid=aViewColumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ViewColumn');
    return;
  end if;
  aBRIEF:=func.ViewColumn_BRIEF_F(aViewColumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ViewColumn_DELETE /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ViewColumn where ViewColumnid=aViewColumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ViewColumn',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ViewColumn');
      return;
    end if;
  end if;
 --  verify lock  --
 ViewColumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aViewColumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ViewColumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ViewColumn is select  instanceid ID from instance where OwnerPartName ='ViewColumn' and OwnerRowID=aViewColumnid;
row_ViewColumn  chld_ViewColumn%ROWTYPE;
begin
--open chld_ViewColumn;
for row_ViewColumn in chld_ViewColumn loop
 Kernel.INSTANCE_OWNER (acursession,row_ViewColumn.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ViewColumn.id);
end loop;
--close chld_ViewColumn;
end ;
  delete from  ViewColumn 
  where  ViewColumnID = aViewColumnID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Колонка*/
procedure ViewColumn_SAVE /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aViewColumnid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER := null /* № *//* № */
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2/* Псвдоним *//* Псвдоним */
,aFromPart CHAR/* Раздел *//* Раздел */
,aField CHAR/* Поле *//* Поле */
,aAggregation
 NUMBER/* Агрегация *//* Агрегация */
,aExpression VARCHAR2 := null /* Формула *//* Формула */
,aForCombo
 NUMBER/* Для комбо *//* Для комбо */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ViewColumn where ViewColumnID=aViewColumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ViewColumn where ViewColumnid=aViewColumnID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ViewColumn',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ViewColumn');
      return;
    end if;
  end if;
 --  verify lock  --
 ViewColumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aViewColumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ViewColumn');
    return;
  end if;
 -- update row  --
 update  ViewColumn set ChangeStamp=sysdate
,
  sequence=asequence
,
  Name=aName
,
  the_Alias=athe_Alias
,
  FromPart=aFromPart
,
  Field=aField
,
  Aggregation=aAggregation
,
  Expression=aExpression
,
  ForCombo=aForCombo
  where  ViewColumnID = aViewColumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ViewColumn',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ViewColumn');
      return;
    end if;
 end if;
 PARTVIEW_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ViewColumn');
    return;
  end if;
 insert into   ViewColumn
 (  ViewColumnID 
,ParentStructRowID
,sequence

,Name

,the_Alias

,FromPart

,Field

,Aggregation

,Expression

,ForCombo

 ) values ( aViewColumnID 
,aParentStructRowID
,asequence

,aName

,athe_Alias

,aFromPart

,aField

,aAggregation

,aExpression

,aForCombo

 ); 
 ViewColumn_SINIT( aCURSESSION,aViewColumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ViewColumn_PARENT /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ViewColumn where  ViewColumnid=aRowID;
  aParentTable := 'PARTVIEW';
 end; 

procedure ViewColumn_ISLOCKED /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ViewColumn where ViewColumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ViewColumn_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ViewColumn_LOCK /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ViewColumn_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ViewColumn_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ViewColumn where ViewColumnid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ViewColumn');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ViewColumn set LockUserID =auserID ,LockSessionID =null where ViewColumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ViewColumn set LockUserID =null,LockSessionID =aCURSESSION  where ViewColumnid=aRowID;
     return;
   end if;
 end ;

procedure ViewColumn_HCL /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ViewColumn_UNLOCK /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ViewColumn_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ViewColumn set LockUserID =null  where ViewColumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ViewColumn set LockSessionID =null  where ViewColumnid=aRowID;
     return;
   end if;
 end; 

procedure ViewColumn_SINIT /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ViewColumn where ViewColumnid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ViewColumn');
    return;
  end if;
if aSecurityStyleID is null then
 ViewColumn_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ViewColumn set securitystyleid =aStyleID where ViewColumnid = aRowID;
else 
 update ViewColumn set securitystyleid =aSecurityStyleID where ViewColumnid = aRowID;
end if; 
end ; 

procedure ViewColumn_propagate /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ViewColumn where ViewColumnid=aRowid;
end;


procedure PARTVIEW_LNK_BRIEF  (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aPARTVIEW_LNKid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from PARTVIEW_LNK where PARTVIEW_LNKid=aPARTVIEW_LNKID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=PARTVIEW_LNK');
    return;
  end if;
  aBRIEF:=func.PARTVIEW_LNK_BRIEF_F(aPARTVIEW_LNKid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure PARTVIEW_LNK_DELETE /**/ (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from PARTVIEW_LNK where PARTVIEW_LNKid=aPARTVIEW_LNKID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:PARTVIEW_LNK',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=PARTVIEW_LNK');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTVIEW_LNK_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTVIEW_LNKid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_PARTVIEW_LNK is select  instanceid ID from instance where OwnerPartName ='PARTVIEW_LNK' and OwnerRowID=aPARTVIEW_LNKid;
row_PARTVIEW_LNK  chld_PARTVIEW_LNK%ROWTYPE;
begin
--open chld_PARTVIEW_LNK;
for row_PARTVIEW_LNK in chld_PARTVIEW_LNK loop
 Kernel.INSTANCE_OWNER (acursession,row_PARTVIEW_LNK.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_PARTVIEW_LNK.id);
end loop;
--close chld_PARTVIEW_LNK;
end ;
  delete from  PARTVIEW_LNK 
  where  PARTVIEW_LNKID = aPARTVIEW_LNKID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Связанные представления*/
procedure PARTVIEW_LNK_SAVE /**/ (
 aCURSESSION CHAR,
 aPARTVIEW_LNKid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheView CHAR/* Представление *//* Представление */
,aTheJoinSource CHAR := null /* Связь: Поле для join источник *//* Связь: Поле для join источник */
,aRefType
 NUMBER/* Связывать как *//* Связывать как */
,aTheJoinDestination CHAR := null /* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,aHandJoin
 VARCHAR2 := null /* Ручной join *//* Ручной join */
,aSEQ
 NUMBER/* Порядок *//* Порядок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from PARTVIEW_LNK where PARTVIEW_LNKID=aPARTVIEW_LNKID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from PARTVIEW_LNK where PARTVIEW_LNKid=aPARTVIEW_LNKID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:PARTVIEW_LNK',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=PARTVIEW_LNK');
      return;
    end if;
  end if;
 --  verify lock  --
 PARTVIEW_LNK_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aPARTVIEW_LNKid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
 -- update row  --
 update  PARTVIEW_LNK set ChangeStamp=sysdate
,
  TheView=aTheView
,
  TheJoinSource=aTheJoinSource
,
  RefType=aRefType
,
  TheJoinDestination=aTheJoinDestination
,
  HandJoin=aHandJoin
,
  SEQ=aSEQ
  where  PARTVIEW_LNKID = aPARTVIEW_LNKID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PARTVIEW where PARTVIEWid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:PARTVIEW_LNK',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=PARTVIEW_LNK');
      return;
    end if;
 end if;
 PARTVIEW_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=PARTVIEW_LNK');
    return;
  end if;
 insert into   PARTVIEW_LNK
 (  PARTVIEW_LNKID 
,ParentStructRowID
,TheView

,TheJoinSource

,RefType

,TheJoinDestination

,HandJoin

,SEQ

 ) values ( aPARTVIEW_LNKID 
,aParentStructRowID
,aTheView

,aTheJoinSource

,aRefType

,aTheJoinDestination

,aHandJoin

,aSEQ

 ); 
 PARTVIEW_LNK_SINIT( aCURSESSION,aPARTVIEW_LNKid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure PARTVIEW_LNK_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from PARTVIEW_LNK where  PARTVIEW_LNKid=aRowID;
  aParentTable := 'PARTVIEW';
 end; 

procedure PARTVIEW_LNK_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from PARTVIEW_LNK where PARTVIEW_LNKid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  PARTVIEW_LNK_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure PARTVIEW_LNK_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 PARTVIEW_LNK_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  PARTVIEW_LNK_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from PARTVIEW_LNK where PARTVIEW_LNKid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=PARTVIEW_LNK');
    return;
  end if;
   if  aLockMode =2  
   then   
    update PARTVIEW_LNK set LockUserID =auserID ,LockSessionID =null where PARTVIEW_LNKid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update PARTVIEW_LNK set LockUserID =null,LockSessionID =aCURSESSION  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
 end ;

procedure PARTVIEW_LNK_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure PARTVIEW_LNK_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 PARTVIEW_LNK_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update PARTVIEW_LNK set LockUserID =null  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update PARTVIEW_LNK set LockSessionID =null  where PARTVIEW_LNKid=aRowID;
     return;
   end if;
 end; 

procedure PARTVIEW_LNK_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from PARTVIEW_LNK where PARTVIEW_LNKid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =PARTVIEW_LNK');
    return;
  end if;
if aSecurityStyleID is null then
 PARTVIEW_LNK_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update PARTVIEW_LNK set securitystyleid =aStyleID where PARTVIEW_LNKid = aRowID;
else 
 update PARTVIEW_LNK set securitystyleid =aSecurityStyleID where PARTVIEW_LNKid = aRowID;
end if; 
end ; 

procedure PARTVIEW_LNK_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from PARTVIEW_LNK where PARTVIEW_LNKid=aRowid;
end;


procedure VALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aVALIDATORid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from VALIDATOR where VALIDATORid=aVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=VALIDATOR');
    return;
  end if;
  aBRIEF:=func.VALIDATOR_BRIEF_F(aVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure VALIDATOR_DELETE /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from VALIDATOR where VALIDATORid=aVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:VALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=VALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 VALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=VALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_VALIDATOR is select  instanceid ID from instance where OwnerPartName ='VALIDATOR' and OwnerRowID=aVALIDATORid;
row_VALIDATOR  chld_VALIDATOR%ROWTYPE;
begin
--open chld_VALIDATOR;
for row_VALIDATOR in chld_VALIDATOR loop
 Kernel.INSTANCE_OWNER (acursession,row_VALIDATOR.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_VALIDATOR.id);
end loop;
--close chld_VALIDATOR;
end ;
  delete from  VALIDATOR 
  where  VALIDATORID = aVALIDATORID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Логика на форме*/
procedure VALIDATOR_SAVE /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from VALIDATOR where VALIDATORID=aVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from VALIDATOR where VALIDATORid=aVALIDATORID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:VALIDATOR',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=VALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 VALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=VALIDATOR');
    return;
  end if;
 -- update row  --
 update  VALIDATOR set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  VALIDATORID = aVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:VALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=VALIDATOR');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=VALIDATOR');
    return;
  end if;
 insert into   VALIDATOR
 (  VALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 VALIDATOR_SINIT( aCURSESSION,aVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure VALIDATOR_PARENT /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from VALIDATOR where  VALIDATORid=aRowID;
  aParentTable := 'PART';
 end; 

procedure VALIDATOR_ISLOCKED /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from VALIDATOR where VALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  VALIDATOR_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure VALIDATOR_LOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 VALIDATOR_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  VALIDATOR_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from VALIDATOR where VALIDATORid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=VALIDATOR');
    return;
  end if;
   if  aLockMode =2  
   then   
    update VALIDATOR set LockUserID =auserID ,LockSessionID =null where VALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update VALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where VALIDATORid=aRowID;
     return;
   end if;
 end ;

procedure VALIDATOR_HCL /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure VALIDATOR_UNLOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 VALIDATOR_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update VALIDATOR set LockUserID =null  where VALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update VALIDATOR set LockSessionID =null  where VALIDATORid=aRowID;
     return;
   end if;
 end; 

procedure VALIDATOR_SINIT /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from VALIDATOR where VALIDATORid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =VALIDATOR');
    return;
  end if;
if aSecurityStyleID is null then
 VALIDATOR_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update VALIDATOR set securitystyleid =aStyleID where VALIDATORid = aRowID;
else 
 update VALIDATOR set securitystyleid =aSecurityStyleID where VALIDATORid = aRowID;
end if; 
end ; 

procedure VALIDATOR_propagate /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from VALIDATOR where VALIDATORid=aRowid;
end;


procedure UNIQUECONSTRAINT_BRIEF  (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aUNIQUECONSTRAINTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aUNIQUECONSTRAINTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=UNIQUECONSTRAINT');
    return;
  end if;
  aBRIEF:=func.UNIQUECONSTRAINT_BRIEF_F(aUNIQUECONSTRAINTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure UNIQUECONSTRAINT_DELETE /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aUNIQUECONSTRAINTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:UNIQUECONSTRAINT',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=UNIQUECONSTRAINT');
      return;
    end if;
  end if;
 --  verify lock  --
 UNIQUECONSTRAINT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aUNIQUECONSTRAINTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_CONSTRAINTFIELD is select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aUNIQUECONSTRAINTid;
    child_CONSTRAINTFIELD_rec  child_CONSTRAINTFIELD%ROWTYPE;
    begin
    --open child_CONSTRAINTFIELD;
      for child_CONSTRAINTFIELD_rec in child_CONSTRAINTFIELD loop
      CONSTRAINTFIELD_DELETE (acursession,child_CONSTRAINTFIELD_rec.id,aInstanceid);
      end loop;
      --close child_CONSTRAINTFIELD;
    end ;
declare cursor chld_UNIQUECONSTRAINT is select  instanceid ID from instance where OwnerPartName ='UNIQUECONSTRAINT' and OwnerRowID=aUNIQUECONSTRAINTid;
row_UNIQUECONSTRAINT  chld_UNIQUECONSTRAINT%ROWTYPE;
begin
--open chld_UNIQUECONSTRAINT;
for row_UNIQUECONSTRAINT in chld_UNIQUECONSTRAINT loop
 Kernel.INSTANCE_OWNER (acursession,row_UNIQUECONSTRAINT.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_UNIQUECONSTRAINT.id);
end loop;
--close chld_UNIQUECONSTRAINT;
end ;
  delete from  UNIQUECONSTRAINT 
  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничение уникальности*/
procedure UNIQUECONSTRAINT_SAVE /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aUNIQUECONSTRAINTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aPerParent
 NUMBER/* По родителю *//* По родителю */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from UNIQUECONSTRAINT where UNIQUECONSTRAINTID=aUNIQUECONSTRAINTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aUNIQUECONSTRAINTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:UNIQUECONSTRAINT',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=UNIQUECONSTRAINT');
      return;
    end if;
  end if;
 --  verify lock  --
 UNIQUECONSTRAINT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aUNIQUECONSTRAINTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
 -- update row  --
 update  UNIQUECONSTRAINT set ChangeStamp=sysdate
,
  Name=aName
,
  PerParent=aPerParent
,
  TheComment=aTheComment
  where  UNIQUECONSTRAINTID = aUNIQUECONSTRAINTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:UNIQUECONSTRAINT',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=UNIQUECONSTRAINT');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
 insert into   UNIQUECONSTRAINT
 (  UNIQUECONSTRAINTID 
,ParentStructRowID
,Name

,PerParent

,TheComment

 ) values ( aUNIQUECONSTRAINTID 
,aParentStructRowID
,aName

,aPerParent

,aTheComment

 ); 
 UNIQUECONSTRAINT_SINIT( aCURSESSION,aUNIQUECONSTRAINTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure UNIQUECONSTRAINT_PARENT /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from UNIQUECONSTRAINT where  UNIQUECONSTRAINTid=aRowID;
  aParentTable := 'PART';
 end; 

procedure UNIQUECONSTRAINT_ISLOCKED /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  UNIQUECONSTRAINT_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure UNIQUECONSTRAINT_LOCK /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 UNIQUECONSTRAINT_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  UNIQUECONSTRAINT_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=UNIQUECONSTRAINT');
    return;
  end if;
   if  aLockMode =2  
   then   
    update UNIQUECONSTRAINT set LockUserID =auserID ,LockSessionID =null where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update UNIQUECONSTRAINT set LockUserID =null,LockSessionID =aCURSESSION  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
 end ;

procedure UNIQUECONSTRAINT_HCL /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_CONSTRAINTFIELD is select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aRowid;
row_CONSTRAINTFIELD lch_CONSTRAINTFIELD%ROWTYPE;
begin  
--open lch_CONSTRAINTFIELD;
for row_CONSTRAINTFIELD in lch_CONSTRAINTFIELD
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from CONSTRAINTFIELD where CONSTRAINTFIELDid=row_CONSTRAINTFIELD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_CONSTRAINTFIELD;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_CONSTRAINTFIELD;
     return;
   end if; 
 end if;  
 CONSTRAINTFIELD_HCL (acursession,row_CONSTRAINTFIELD.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_CONSTRAINTFIELD;
   return;
 end if;
end loop;
--close lch_CONSTRAINTFIELD;
end;
aIsLocked :=0;
end;

procedure UNIQUECONSTRAINT_UNLOCK /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 UNIQUECONSTRAINT_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update UNIQUECONSTRAINT set LockUserID =null  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update UNIQUECONSTRAINT set LockSessionID =null  where UNIQUECONSTRAINTid=aRowID;
     return;
   end if;
 end; 

procedure UNIQUECONSTRAINT_SINIT /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =UNIQUECONSTRAINT');
    return;
  end if;
if aSecurityStyleID is null then
 UNIQUECONSTRAINT_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update UNIQUECONSTRAINT set securitystyleid =aStyleID where UNIQUECONSTRAINTid = aRowID;
else 
 update UNIQUECONSTRAINT set securitystyleid =aSecurityStyleID where UNIQUECONSTRAINTid = aRowID;
end if; 
end ; 

procedure UNIQUECONSTRAINT_propagate /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aRowid;
declare cursor pch_CONSTRAINTFIELD  is select CONSTRAINTFIELD.CONSTRAINTFIELDid ID from CONSTRAINTFIELD where  CONSTRAINTFIELD.ParentStructRowID = aRowid;
row_CONSTRAINTFIELD  pch_CONSTRAINTFIELD%ROWTYPE;
begin
--open pch_CONSTRAINTFIELD;
for row_CONSTRAINTFIELD in pch_CONSTRAINTFIELD loop
   CONSTRAINTFIELD_SINIT( acursession,row_CONSTRAINTFIELD.id,assid);
   CONSTRAINTFIELD_propagate( acursession,row_CONSTRAINTFIELD.id);
end loop;
--close pch_CONSTRAINTFIELD;
end;
end;


procedure CONSTRAINTFIELD_BRIEF  (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aCONSTRAINTFIELDid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from CONSTRAINTFIELD where CONSTRAINTFIELDid=aCONSTRAINTFIELDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=CONSTRAINTFIELD');
    return;
  end if;
  aBRIEF:=func.CONSTRAINTFIELD_BRIEF_F(aCONSTRAINTFIELDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure CONSTRAINTFIELD_DELETE /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aCONSTRAINTFIELDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:CONSTRAINTFIELD',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=CONSTRAINTFIELD');
      return;
    end if;
  end if;
 --  verify lock  --
 CONSTRAINTFIELD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aCONSTRAINTFIELDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_CONSTRAINTFIELD is select  instanceid ID from instance where OwnerPartName ='CONSTRAINTFIELD' and OwnerRowID=aCONSTRAINTFIELDid;
row_CONSTRAINTFIELD  chld_CONSTRAINTFIELD%ROWTYPE;
begin
--open chld_CONSTRAINTFIELD;
for row_CONSTRAINTFIELD in chld_CONSTRAINTFIELD loop
 Kernel.INSTANCE_OWNER (acursession,row_CONSTRAINTFIELD.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_CONSTRAINTFIELD.id);
end loop;
--close chld_CONSTRAINTFIELD;
end ;
  delete from  CONSTRAINTFIELD 
  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поля ограничения*/
procedure CONSTRAINTFIELD_SAVE /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aCONSTRAINTFIELDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheField CHAR/* Поле *//* Поле */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from CONSTRAINTFIELD where CONSTRAINTFIELDID=aCONSTRAINTFIELDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aCONSTRAINTFIELDID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:CONSTRAINTFIELD',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=CONSTRAINTFIELD');
      return;
    end if;
  end if;
 --  verify lock  --
 CONSTRAINTFIELD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aCONSTRAINTFIELDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
 -- update row  --
 update  CONSTRAINTFIELD set ChangeStamp=sysdate
,
  TheField=aTheField
  where  CONSTRAINTFIELDID = aCONSTRAINTFIELDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from UNIQUECONSTRAINT where UNIQUECONSTRAINTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:CONSTRAINTFIELD',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=CONSTRAINTFIELD');
      return;
    end if;
 end if;
 UNIQUECONSTRAINT_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=CONSTRAINTFIELD');
    return;
  end if;
 insert into   CONSTRAINTFIELD
 (  CONSTRAINTFIELDID 
,ParentStructRowID
,TheField

 ) values ( aCONSTRAINTFIELDID 
,aParentStructRowID
,aTheField

 ); 
 CONSTRAINTFIELD_SINIT( aCURSESSION,aCONSTRAINTFIELDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure CONSTRAINTFIELD_PARENT /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from CONSTRAINTFIELD where  CONSTRAINTFIELDid=aRowID;
  aParentTable := 'UNIQUECONSTRAINT';
 end; 

procedure CONSTRAINTFIELD_ISLOCKED /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  CONSTRAINTFIELD_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure CONSTRAINTFIELD_LOCK /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 CONSTRAINTFIELD_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  CONSTRAINTFIELD_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=CONSTRAINTFIELD');
    return;
  end if;
   if  aLockMode =2  
   then   
    update CONSTRAINTFIELD set LockUserID =auserID ,LockSessionID =null where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update CONSTRAINTFIELD set LockUserID =null,LockSessionID =aCURSESSION  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
 end ;

procedure CONSTRAINTFIELD_HCL /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure CONSTRAINTFIELD_UNLOCK /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 CONSTRAINTFIELD_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update CONSTRAINTFIELD set LockUserID =null  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update CONSTRAINTFIELD set LockSessionID =null  where CONSTRAINTFIELDid=aRowID;
     return;
   end if;
 end; 

procedure CONSTRAINTFIELD_SINIT /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =CONSTRAINTFIELD');
    return;
  end if;
if aSecurityStyleID is null then
 CONSTRAINTFIELD_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update CONSTRAINTFIELD set securitystyleid =aStyleID where CONSTRAINTFIELDid = aRowID;
else 
 update CONSTRAINTFIELD set securitystyleid =aSecurityStyleID where CONSTRAINTFIELDid = aRowID;
end if; 
end ; 

procedure CONSTRAINTFIELD_propagate /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from CONSTRAINTFIELD where CONSTRAINTFIELDid=aRowid;
end;


procedure ExtenderInterface_BRIEF  (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aExtenderInterfaceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ExtenderInterface where ExtenderInterfaceid=aExtenderInterfaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ExtenderInterface');
    return;
  end if;
  aBRIEF:=func.ExtenderInterface_BRIEF_F(aExtenderInterfaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ExtenderInterface_DELETE /**/ (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ExtenderInterface where ExtenderInterfaceid=aExtenderInterfaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ExtenderInterface',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ExtenderInterface');
      return;
    end if;
  end if;
 --  verify lock  --
 ExtenderInterface_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aExtenderInterfaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ExtenderInterface');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ExtenderInterface is select  instanceid ID from instance where OwnerPartName ='ExtenderInterface' and OwnerRowID=aExtenderInterfaceid;
row_ExtenderInterface  chld_ExtenderInterface%ROWTYPE;
begin
--open chld_ExtenderInterface;
for row_ExtenderInterface in chld_ExtenderInterface loop
 Kernel.INSTANCE_OWNER (acursession,row_ExtenderInterface.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ExtenderInterface.id);
end loop;
--close chld_ExtenderInterface;
end ;
  delete from  ExtenderInterface 
  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Интерфейсы расширения*/
procedure ExtenderInterface_SAVE /**/ (
 aCURSESSION CHAR,
 aExtenderInterfaceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheName
 VARCHAR2/* Название *//* Название */
,aTargetPlatform CHAR/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR2/* Объект *//* Объект */
,aTheConfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ExtenderInterface where ExtenderInterfaceID=aExtenderInterfaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ExtenderInterface where ExtenderInterfaceid=aExtenderInterfaceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ExtenderInterface',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ExtenderInterface');
      return;
    end if;
  end if;
 --  verify lock  --
 ExtenderInterface_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aExtenderInterfaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ExtenderInterface');
    return;
  end if;
 -- update row  --
 update  ExtenderInterface set ChangeStamp=sysdate
,
  TheName=aTheName
,
  TargetPlatform=aTargetPlatform
,
  TheObject=aTheObject
,
  TheConfig=aTheConfig
  where  ExtenderInterfaceID = aExtenderInterfaceID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ExtenderInterface',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ExtenderInterface');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ExtenderInterface');
    return;
  end if;
 insert into   ExtenderInterface
 (  ExtenderInterfaceID 
,ParentStructRowID
,TheName

,TargetPlatform

,TheObject

,TheConfig

 ) values ( aExtenderInterfaceID 
,aParentStructRowID
,aTheName

,aTargetPlatform

,aTheObject

,aTheConfig

 ); 
 ExtenderInterface_SINIT( aCURSESSION,aExtenderInterfaceid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ExtenderInterface_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ExtenderInterface where  ExtenderInterfaceid=aRowID;
  aParentTable := 'PART';
 end; 

procedure ExtenderInterface_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ExtenderInterface where ExtenderInterfaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ExtenderInterface_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ExtenderInterface_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ExtenderInterface_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ExtenderInterface_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ExtenderInterface where ExtenderInterfaceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ExtenderInterface');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ExtenderInterface set LockUserID =auserID ,LockSessionID =null where ExtenderInterfaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ExtenderInterface set LockUserID =null,LockSessionID =aCURSESSION  where ExtenderInterfaceid=aRowID;
     return;
   end if;
 end ;

procedure ExtenderInterface_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ExtenderInterface_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ExtenderInterface_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ExtenderInterface set LockUserID =null  where ExtenderInterfaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ExtenderInterface set LockSessionID =null  where ExtenderInterfaceid=aRowID;
     return;
   end if;
 end; 

procedure ExtenderInterface_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ExtenderInterface where ExtenderInterfaceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ExtenderInterface');
    return;
  end if;
if aSecurityStyleID is null then
 ExtenderInterface_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ExtenderInterface set securitystyleid =aStyleID where ExtenderInterfaceid = aRowID;
else 
 update ExtenderInterface set securitystyleid =aSecurityStyleID where ExtenderInterfaceid = aRowID;
end if; 
end ; 

procedure ExtenderInterface_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ExtenderInterface where ExtenderInterfaceid=aRowid;
end;


procedure FIELD_BRIEF  (
 aCURSESSION CHAR,
 aFIELDid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELD where FIELDid=aFIELDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELD');
    return;
  end if;
  aBRIEF:=func.FIELD_BRIEF_F(aFIELDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELD_DELETE /*Поле*/ (
 aCURSESSION CHAR,
 aFIELDid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELD where FIELDid=aFIELDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELD',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELD');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_FldExtenders is select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aFIELDid;
    child_FldExtenders_rec  child_FldExtenders%ROWTYPE;
    begin
    --open child_FldExtenders;
      for child_FldExtenders_rec in child_FldExtenders loop
      FldExtenders_DELETE (acursession,child_FldExtenders_rec.id,aInstanceid);
      end loop;
      --close child_FldExtenders;
    end ;
    declare cursor child_FIELDSRCDEF is select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aFIELDid;
    child_FIELDSRCDEF_rec  child_FIELDSRCDEF%ROWTYPE;
    begin
    --open child_FIELDSRCDEF;
      for child_FIELDSRCDEF_rec in child_FIELDSRCDEF loop
      FIELDSRCDEF_DELETE (acursession,child_FIELDSRCDEF_rec.id,aInstanceid);
      end loop;
      --close child_FIELDSRCDEF;
    end ;
    declare cursor child_DINAMICFILTERSCRIPT is select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aFIELDid;
    child_DINAMICFILTERSCRIPT_rec  child_DINAMICFILTERSCRIPT%ROWTYPE;
    begin
    --open child_DINAMICFILTERSCRIPT;
      for child_DINAMICFILTERSCRIPT_rec in child_DINAMICFILTERSCRIPT loop
      DINAMICFILTERSCRIPT_DELETE (acursession,child_DINAMICFILTERSCRIPT_rec.id,aInstanceid);
      end loop;
      --close child_DINAMICFILTERSCRIPT;
    end ;
    declare cursor child_FIELDEXPRESSION is select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aFIELDid;
    child_FIELDEXPRESSION_rec  child_FIELDEXPRESSION%ROWTYPE;
    begin
    --open child_FIELDEXPRESSION;
      for child_FIELDEXPRESSION_rec in child_FIELDEXPRESSION loop
      FIELDEXPRESSION_DELETE (acursession,child_FIELDEXPRESSION_rec.id,aInstanceid);
      end loop;
      --close child_FIELDEXPRESSION;
    end ;
    declare cursor child_FIELDVALIDATOR is select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aFIELDid;
    child_FIELDVALIDATOR_rec  child_FIELDVALIDATOR%ROWTYPE;
    begin
    --open child_FIELDVALIDATOR;
      for child_FIELDVALIDATOR_rec in child_FIELDVALIDATOR loop
      FIELDVALIDATOR_DELETE (acursession,child_FIELDVALIDATOR_rec.id,aInstanceid);
      end loop;
      --close child_FIELDVALIDATOR;
    end ;
    declare cursor child_FIELDMENU is select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aFIELDid;
    child_FIELDMENU_rec  child_FIELDMENU%ROWTYPE;
    begin
    --open child_FIELDMENU;
      for child_FIELDMENU_rec in child_FIELDMENU loop
      FIELDMENU_DELETE (acursession,child_FIELDMENU_rec.id,aInstanceid);
      end loop;
      --close child_FIELDMENU;
    end ;
declare cursor chld_FIELD is select  instanceid ID from instance where OwnerPartName ='FIELD' and OwnerRowID=aFIELDid;
row_FIELD  chld_FIELD%ROWTYPE;
begin
--open chld_FIELD;
for row_FIELD in chld_FIELD loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELD.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELD.id);
end loop;
--close chld_FIELD;
end ;
  delete from  FIELD 
  where  FIELDID = aFIELDID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поле*/
procedure FIELD_SAVE /*Поле*/ (
 aCURSESSION CHAR,
 aFIELDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTabName
 VARCHAR2 := null /* Имя вкладки *//* Имя вкладки */
,aFieldGroupBox
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aName
 VARCHAR2/* Имя поля *//* Имя поля */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aIsBrief
 NUMBER/* Краткая информация *//* Краткая информация */
,aIsTabBrief
 NUMBER/* Для отображения в таблице *//* Для отображения в таблице */
,aAllowNull
 NUMBER/* Может быть пустым *//* Может быть пустым */
,aDataSize
 NUMBER := null /* Размер поля *//* Размер поля */
,aReferenceType
 NUMBER/* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,aRefToPart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
,aTheStyle
 VARCHAR2 := null /* Стиль *//* Стиль */
,aInternalReference
 NUMBER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,aCreateRefOnly
 NUMBER/* Только создание объекта *//* Только создание объекта */
,aIsAutoNumber
 NUMBER/* Автонумерация *//* Автонумерация */
,aTheNumerator CHAR := null /* Нумератор *//* Нумератор */
,aZoneTemplate
 VARCHAR2 := null /* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,aNumberDateField CHAR := null /* Поле для расчета даты *//* Поле для расчета даты */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,ashablonBrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,atheNameClass
 VARCHAR2 := null /* Имя класса для мастера строк *//* Имя класса для мастера строк */
,aTheMask
 VARCHAR2 := null /* Маска *//* Маска */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELD where FIELDID=aFIELDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELD where FIELDid=aFIELDID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELD',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELD');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELD');
    return;
  end if;
 -- update row  --
 update  FIELD set ChangeStamp=sysdate
,
  TabName=aTabName
,
  FieldGroupBox=aFieldGroupBox
,
  Sequence=aSequence
,
  Caption=aCaption
,
  Name=aName
,
  FieldType=aFieldType
,
  IsBrief=aIsBrief
,
  IsTabBrief=aIsTabBrief
,
  AllowNull=aAllowNull
,
  DataSize=aDataSize
,
  ReferenceType=aReferenceType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
,
  TheStyle=aTheStyle
,
  InternalReference=aInternalReference
,
  CreateRefOnly=aCreateRefOnly
,
  IsAutoNumber=aIsAutoNumber
,
  TheNumerator=aTheNumerator
,
  ZoneTemplate=aZoneTemplate
,
  NumberDateField=aNumberDateField
,
  TheComment=aTheComment
,
  shablonBrief=ashablonBrief
,
  theNameClass=atheNameClass
,
  TheMask=aTheMask
  where  FIELDID = aFIELDID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;
select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Sequence=aSequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from PART where PARTid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELD',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELD');
      return;
    end if;
 end if;
 PART_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELD');
    return;
  end if;
 insert into   FIELD
 (  FIELDID 
,ParentStructRowID
,TabName

,FieldGroupBox

,Sequence

,Caption

,Name

,FieldType

,IsBrief

,IsTabBrief

,AllowNull

,DataSize

,ReferenceType

,RefToType

,RefToPart

,TheStyle

,InternalReference

,CreateRefOnly

,IsAutoNumber

,TheNumerator

,ZoneTemplate

,NumberDateField

,TheComment

,shablonBrief

,theNameClass

,TheMask

 ) values ( aFIELDID 
,aParentStructRowID
,aTabName

,aFieldGroupBox

,aSequence

,aCaption

,aName

,aFieldType

,aIsBrief

,aIsTabBrief

,aAllowNull

,aDataSize

,aReferenceType

,aRefToType

,aRefToPart

,aTheStyle

,aInternalReference

,aCreateRefOnly

,aIsAutoNumber

,aTheNumerator

,aZoneTemplate

,aNumberDateField

,aTheComment

,ashablonBrief

,atheNameClass

,aTheMask

 ); 
 FIELD_SINIT( aCURSESSION,aFIELDid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;
select Count(*) into aUniqueRowCount from FIELD where ParentStructRowID=aParentStructRowID 
 and Sequence=aSequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=FIELD');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure FIELD_PARENT /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELD where  FIELDid=aRowID;
  aParentTable := 'PART';
 end; 

procedure FIELD_ISLOCKED /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELD where FIELDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELD_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELD_LOCK /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELD_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELD_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELD');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELD set LockUserID =auserID ,LockSessionID =null where FIELDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELD set LockUserID =null,LockSessionID =aCURSESSION  where FIELDid=aRowID;
     return;
   end if;
 end ;

procedure FIELD_HCL /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_FldExtenders is select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aRowid;
row_FldExtenders lch_FldExtenders%ROWTYPE;
begin  
--open lch_FldExtenders;
for row_FldExtenders in lch_FldExtenders
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FldExtenders where FldExtendersid=row_FldExtenders.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FldExtenders;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FldExtenders;
     return;
   end if; 
 end if;  
 FldExtenders_HCL (acursession,row_FldExtenders.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FldExtenders;
   return;
 end if;
end loop;
--close lch_FldExtenders;
end;
declare cursor lch_FIELDSRCDEF is select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aRowid;
row_FIELDSRCDEF lch_FIELDSRCDEF%ROWTYPE;
begin  
--open lch_FIELDSRCDEF;
for row_FIELDSRCDEF in lch_FIELDSRCDEF
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDSRCDEF where FIELDSRCDEFid=row_FIELDSRCDEF.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDSRCDEF;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDSRCDEF;
     return;
   end if; 
 end if;  
 FIELDSRCDEF_HCL (acursession,row_FIELDSRCDEF.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDSRCDEF;
   return;
 end if;
end loop;
--close lch_FIELDSRCDEF;
end;
declare cursor lch_DINAMICFILTERSCRIPT is select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aRowid;
row_DINAMICFILTERSCRIPT lch_DINAMICFILTERSCRIPT%ROWTYPE;
begin  
--open lch_DINAMICFILTERSCRIPT;
for row_DINAMICFILTERSCRIPT in lch_DINAMICFILTERSCRIPT
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=row_DINAMICFILTERSCRIPT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_DINAMICFILTERSCRIPT;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_DINAMICFILTERSCRIPT;
     return;
   end if; 
 end if;  
 DINAMICFILTERSCRIPT_HCL (acursession,row_DINAMICFILTERSCRIPT.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_DINAMICFILTERSCRIPT;
   return;
 end if;
end loop;
--close lch_DINAMICFILTERSCRIPT;
end;
declare cursor lch_FIELDEXPRESSION is select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aRowid;
row_FIELDEXPRESSION lch_FIELDEXPRESSION%ROWTYPE;
begin  
--open lch_FIELDEXPRESSION;
for row_FIELDEXPRESSION in lch_FIELDEXPRESSION
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDEXPRESSION where FIELDEXPRESSIONid=row_FIELDEXPRESSION.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDEXPRESSION;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDEXPRESSION;
     return;
   end if; 
 end if;  
 FIELDEXPRESSION_HCL (acursession,row_FIELDEXPRESSION.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDEXPRESSION;
   return;
 end if;
end loop;
--close lch_FIELDEXPRESSION;
end;
declare cursor lch_FIELDVALIDATOR is select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aRowid;
row_FIELDVALIDATOR lch_FIELDVALIDATOR%ROWTYPE;
begin  
--open lch_FIELDVALIDATOR;
for row_FIELDVALIDATOR in lch_FIELDVALIDATOR
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDVALIDATOR where FIELDVALIDATORid=row_FIELDVALIDATOR.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDVALIDATOR;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDVALIDATOR;
     return;
   end if; 
 end if;  
 FIELDVALIDATOR_HCL (acursession,row_FIELDVALIDATOR.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDVALIDATOR;
   return;
 end if;
end loop;
--close lch_FIELDVALIDATOR;
end;
declare cursor lch_FIELDMENU is select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aRowid;
row_FIELDMENU lch_FIELDMENU%ROWTYPE;
begin  
--open lch_FIELDMENU;
for row_FIELDMENU in lch_FIELDMENU
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDMENU where FIELDMENUid=row_FIELDMENU.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDMENU;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDMENU;
     return;
   end if; 
 end if;  
 FIELDMENU_HCL (acursession,row_FIELDMENU.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDMENU;
   return;
 end if;
end loop;
--close lch_FIELDMENU;
end;
aIsLocked :=0;
end;

procedure FIELD_UNLOCK /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELD_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELD set LockUserID =null  where FIELDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELD set LockSessionID =null  where FIELDid=aRowID;
     return;
   end if;
 end; 

procedure FIELD_SINIT /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELD');
    return;
  end if;
if aSecurityStyleID is null then
 FIELD_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELD set securitystyleid =aStyleID where FIELDid = aRowID;
else 
 update FIELD set securitystyleid =aSecurityStyleID where FIELDid = aRowID;
end if; 
end ; 

procedure FIELD_propagate /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELD where FIELDid=aRowid;
declare cursor pch_FldExtenders  is select FldExtenders.FldExtendersid ID from FldExtenders where  FldExtenders.ParentStructRowID = aRowid;
row_FldExtenders  pch_FldExtenders%ROWTYPE;
begin
--open pch_FldExtenders;
for row_FldExtenders in pch_FldExtenders loop
   FldExtenders_SINIT( acursession,row_FldExtenders.id,assid);
   FldExtenders_propagate( acursession,row_FldExtenders.id);
end loop;
--close pch_FldExtenders;
end;
declare cursor pch_FIELDSRCDEF  is select FIELDSRCDEF.FIELDSRCDEFid ID from FIELDSRCDEF where  FIELDSRCDEF.ParentStructRowID = aRowid;
row_FIELDSRCDEF  pch_FIELDSRCDEF%ROWTYPE;
begin
--open pch_FIELDSRCDEF;
for row_FIELDSRCDEF in pch_FIELDSRCDEF loop
   FIELDSRCDEF_SINIT( acursession,row_FIELDSRCDEF.id,assid);
   FIELDSRCDEF_propagate( acursession,row_FIELDSRCDEF.id);
end loop;
--close pch_FIELDSRCDEF;
end;
declare cursor pch_DINAMICFILTERSCRIPT  is select DINAMICFILTERSCRIPT.DINAMICFILTERSCRIPTid ID from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPT.ParentStructRowID = aRowid;
row_DINAMICFILTERSCRIPT  pch_DINAMICFILTERSCRIPT%ROWTYPE;
begin
--open pch_DINAMICFILTERSCRIPT;
for row_DINAMICFILTERSCRIPT in pch_DINAMICFILTERSCRIPT loop
   DINAMICFILTERSCRIPT_SINIT( acursession,row_DINAMICFILTERSCRIPT.id,assid);
   DINAMICFILTERSCRIPT_propagate( acursession,row_DINAMICFILTERSCRIPT.id);
end loop;
--close pch_DINAMICFILTERSCRIPT;
end;
declare cursor pch_FIELDEXPRESSION  is select FIELDEXPRESSION.FIELDEXPRESSIONid ID from FIELDEXPRESSION where  FIELDEXPRESSION.ParentStructRowID = aRowid;
row_FIELDEXPRESSION  pch_FIELDEXPRESSION%ROWTYPE;
begin
--open pch_FIELDEXPRESSION;
for row_FIELDEXPRESSION in pch_FIELDEXPRESSION loop
   FIELDEXPRESSION_SINIT( acursession,row_FIELDEXPRESSION.id,assid);
   FIELDEXPRESSION_propagate( acursession,row_FIELDEXPRESSION.id);
end loop;
--close pch_FIELDEXPRESSION;
end;
declare cursor pch_FIELDVALIDATOR  is select FIELDVALIDATOR.FIELDVALIDATORid ID from FIELDVALIDATOR where  FIELDVALIDATOR.ParentStructRowID = aRowid;
row_FIELDVALIDATOR  pch_FIELDVALIDATOR%ROWTYPE;
begin
--open pch_FIELDVALIDATOR;
for row_FIELDVALIDATOR in pch_FIELDVALIDATOR loop
   FIELDVALIDATOR_SINIT( acursession,row_FIELDVALIDATOR.id,assid);
   FIELDVALIDATOR_propagate( acursession,row_FIELDVALIDATOR.id);
end loop;
--close pch_FIELDVALIDATOR;
end;
declare cursor pch_FIELDMENU  is select FIELDMENU.FIELDMENUid ID from FIELDMENU where  FIELDMENU.ParentStructRowID = aRowid;
row_FIELDMENU  pch_FIELDMENU%ROWTYPE;
begin
--open pch_FIELDMENU;
for row_FIELDMENU in pch_FIELDMENU loop
   FIELDMENU_SINIT( acursession,row_FIELDMENU.id,assid);
   FIELDMENU_propagate( acursession,row_FIELDMENU.id);
end loop;
--close pch_FIELDMENU;
end;
end;


procedure FldExtenders_BRIEF  (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFldExtendersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FldExtenders where FldExtendersid=aFldExtendersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FldExtenders');
    return;
  end if;
  aBRIEF:=func.FldExtenders_BRIEF_F(aFldExtendersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FldExtenders_DELETE /**/ (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FldExtenders where FldExtendersid=aFldExtendersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FldExtenders',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FldExtenders');
      return;
    end if;
  end if;
 --  verify lock  --
 FldExtenders_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFldExtendersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FldExtenders');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FldExtenders is select  instanceid ID from instance where OwnerPartName ='FldExtenders' and OwnerRowID=aFldExtendersid;
row_FldExtenders  chld_FldExtenders%ROWTYPE;
begin
--open chld_FldExtenders;
for row_FldExtenders in chld_FldExtenders loop
 Kernel.INSTANCE_OWNER (acursession,row_FldExtenders.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FldExtenders.id);
end loop;
--close chld_FldExtenders;
end ;
  delete from  FldExtenders 
  where  FldExtendersID = aFldExtendersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Интерфейсы расширения*/
procedure FldExtenders_SAVE /**/ (
 aCURSESSION CHAR,
 aFldExtendersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheName
 VARCHAR2/* Название *//* Название */
,aTargetPlatform CHAR/* Целевая платформа *//* Целевая платформа */
,aTheObject
 VARCHAR2/* Объект *//* Объект */
,aTheConfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FldExtenders where FldExtendersID=aFldExtendersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FldExtenders where FldExtendersid=aFldExtendersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FldExtenders',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FldExtenders');
      return;
    end if;
  end if;
 --  verify lock  --
 FldExtenders_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFldExtendersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FldExtenders');
    return;
  end if;
 -- update row  --
 update  FldExtenders set ChangeStamp=sysdate
,
  TheName=aTheName
,
  TargetPlatform=aTargetPlatform
,
  TheObject=aTheObject
,
  TheConfig=aTheConfig
  where  FldExtendersID = aFldExtendersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FldExtenders',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FldExtenders');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FldExtenders');
    return;
  end if;
 insert into   FldExtenders
 (  FldExtendersID 
,ParentStructRowID
,TheName

,TargetPlatform

,TheObject

,TheConfig

 ) values ( aFldExtendersID 
,aParentStructRowID
,aTheName

,aTargetPlatform

,aTheObject

,aTheConfig

 ); 
 FldExtenders_SINIT( aCURSESSION,aFldExtendersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FldExtenders_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FldExtenders where  FldExtendersid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure FldExtenders_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FldExtenders where FldExtendersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FldExtenders_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FldExtenders_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FldExtenders_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FldExtenders_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FldExtenders where FldExtendersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FldExtenders');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FldExtenders set LockUserID =auserID ,LockSessionID =null where FldExtendersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FldExtenders set LockUserID =null,LockSessionID =aCURSESSION  where FldExtendersid=aRowID;
     return;
   end if;
 end ;

procedure FldExtenders_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FldExtenders_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FldExtenders_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FldExtenders set LockUserID =null  where FldExtendersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FldExtenders set LockSessionID =null  where FldExtendersid=aRowID;
     return;
   end if;
 end; 

procedure FldExtenders_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FldExtenders where FldExtendersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FldExtenders');
    return;
  end if;
if aSecurityStyleID is null then
 FldExtenders_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FldExtenders set securitystyleid =aStyleID where FldExtendersid = aRowID;
else 
 update FldExtenders set securitystyleid =aSecurityStyleID where FldExtendersid = aRowID;
end if; 
end ; 

procedure FldExtenders_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FldExtenders where FldExtendersid=aRowid;
end;


procedure FIELDSRCDEF_BRIEF  (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDSRCDEFid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDSRCDEF where FIELDSRCDEFid=aFIELDSRCDEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDSRCDEF');
    return;
  end if;
  aBRIEF:=func.FIELDSRCDEF_BRIEF_F(aFIELDSRCDEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDSRCDEF_DELETE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDSRCDEF where FIELDSRCDEFid=aFIELDSRCDEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDSRCDEF',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDSRCDEF');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDSRCDEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDSRCDEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDSRCDEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDSRCDEF is select  instanceid ID from instance where OwnerPartName ='FIELDSRCDEF' and OwnerRowID=aFIELDSRCDEFid;
row_FIELDSRCDEF  chld_FIELDSRCDEF%ROWTYPE;
begin
--open chld_FIELDSRCDEF;
for row_FIELDSRCDEF in chld_FIELDSRCDEF loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDSRCDEF.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDSRCDEF.id);
end loop;
--close chld_FIELDSRCDEF;
end ;
  delete from  FIELDSRCDEF 
  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание источника данных*/
procedure FIELDSRCDEF_SAVE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aFIELDSRCDEFid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aProvider
 VARCHAR2 := null /* Провайдер *//* Провайдер */
,aConnectionString
 VARCHAR2 := null /* Строка соединения с источником *//* Строка соединения с источником */
,aDataSource
 VARCHAR2/* Источник данных *//* Источник данных */
,aIDField
 VARCHAR2 := null /* ID *//* ID */
,aBriefString
 VARCHAR2 := null /* Источник краткой информации *//* Источник краткой информации */
,aFilterString
 VARCHAR2 := null /* Фильтр источника данных *//* Фильтр источника данных */
,aSortField
 VARCHAR2 := null /* Сортировка источника данных *//* Сортировка источника данных */
,aDescriptionString VARCHAR2 := null /* Примечания *//* Примечания */
,aDontShowDialog
 NUMBER := null /* Не показывать форму выбора *//* Не показывать форму выбора */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDSRCDEF where FIELDSRCDEFID=aFIELDSRCDEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDSRCDEF where FIELDSRCDEFid=aFIELDSRCDEFID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDSRCDEF',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDSRCDEF');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDSRCDEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDSRCDEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDSRCDEF');
    return;
  end if;
 -- update row  --
 update  FIELDSRCDEF set ChangeStamp=sysdate
,
  Provider=aProvider
,
  ConnectionString=aConnectionString
,
  DataSource=aDataSource
,
  IDField=aIDField
,
  BriefString=aBriefString
,
  FilterString=aFilterString
,
  SortField=aSortField
,
  DescriptionString=aDescriptionString
,
  DontShowDialog=aDontShowDialog
  where  FIELDSRCDEFID = aFIELDSRCDEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDSRCDEF',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDSRCDEF');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDSRCDEF');
    return;
  end if;
select Count(*) into existsCnt from FIELDSRCDEF where 
ParentStructRowID=aParentStructRowID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;FIELDSRCDEF&gt;');
    return;
 End if;
 insert into   FIELDSRCDEF
 (  FIELDSRCDEFID 
,ParentStructRowID
,Provider

,ConnectionString

,DataSource

,IDField

,BriefString

,FilterString

,SortField

,DescriptionString

,DontShowDialog

 ) values ( aFIELDSRCDEFID 
,aParentStructRowID
,aProvider

,aConnectionString

,aDataSource

,aIDField

,aBriefString

,aFilterString

,aSortField

,aDescriptionString

,aDontShowDialog

 ); 
 FIELDSRCDEF_SINIT( aCURSESSION,aFIELDSRCDEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDSRCDEF_PARENT /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDSRCDEF where  FIELDSRCDEFid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure FIELDSRCDEF_ISLOCKED /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDSRCDEF where FIELDSRCDEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDSRCDEF_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDSRCDEF_LOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDSRCDEF_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDSRCDEF_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDSRCDEF where FIELDSRCDEFid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDSRCDEF');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDSRCDEF set LockUserID =auserID ,LockSessionID =null where FIELDSRCDEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDSRCDEF set LockUserID =null,LockSessionID =aCURSESSION  where FIELDSRCDEFid=aRowID;
     return;
   end if;
 end ;

procedure FIELDSRCDEF_HCL /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDSRCDEF_UNLOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDSRCDEF_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDSRCDEF set LockUserID =null  where FIELDSRCDEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDSRCDEF set LockSessionID =null  where FIELDSRCDEFid=aRowID;
     return;
   end if;
 end; 

procedure FIELDSRCDEF_SINIT /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDSRCDEF where FIELDSRCDEFid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDSRCDEF');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDSRCDEF_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDSRCDEF set securitystyleid =aStyleID where FIELDSRCDEFid = aRowID;
else 
 update FIELDSRCDEF set securitystyleid =aSecurityStyleID where FIELDSRCDEFid = aRowID;
end if; 
end ; 

procedure FIELDSRCDEF_propagate /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDSRCDEF where FIELDSRCDEFid=aRowid;
end;


procedure DINAMICFILTERSCRIPT_BRIEF  (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aDINAMICFILTERSCRIPTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aDINAMICFILTERSCRIPTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=DINAMICFILTERSCRIPT');
    return;
  end if;
  aBRIEF:=func.DINAMICFILTERSCRIPT_BRIEF_F(aDINAMICFILTERSCRIPTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure DINAMICFILTERSCRIPT_DELETE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aDINAMICFILTERSCRIPTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:DINAMICFILTERSCRIPT',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=DINAMICFILTERSCRIPT');
      return;
    end if;
  end if;
 --  verify lock  --
 DINAMICFILTERSCRIPT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aDINAMICFILTERSCRIPTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_DINAMICFILTERSCRIPT is select  instanceid ID from instance where OwnerPartName ='DINAMICFILTERSCRIPT' and OwnerRowID=aDINAMICFILTERSCRIPTid;
row_DINAMICFILTERSCRIPT  chld_DINAMICFILTERSCRIPT%ROWTYPE;
begin
--open chld_DINAMICFILTERSCRIPT;
for row_DINAMICFILTERSCRIPT in chld_DINAMICFILTERSCRIPT loop
 Kernel.INSTANCE_OWNER (acursession,row_DINAMICFILTERSCRIPT.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_DINAMICFILTERSCRIPT.id);
end loop;
--close chld_DINAMICFILTERSCRIPT;
end ;
  delete from  DINAMICFILTERSCRIPT 
  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Динамический фильтр*/
procedure DINAMICFILTERSCRIPT_SAVE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aDINAMICFILTERSCRIPTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Целевая платформа *//* Целевая платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTID=aDINAMICFILTERSCRIPTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aDINAMICFILTERSCRIPTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:DINAMICFILTERSCRIPT',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=DINAMICFILTERSCRIPT');
      return;
    end if;
  end if;
 --  verify lock  --
 DINAMICFILTERSCRIPT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aDINAMICFILTERSCRIPTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
 -- update row  --
 update  DINAMICFILTERSCRIPT set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  DINAMICFILTERSCRIPTID = aDINAMICFILTERSCRIPTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:DINAMICFILTERSCRIPT',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=DINAMICFILTERSCRIPT');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
 insert into   DINAMICFILTERSCRIPT
 (  DINAMICFILTERSCRIPTID 
,ParentStructRowID
,Target

,Code

 ) values ( aDINAMICFILTERSCRIPTID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 DINAMICFILTERSCRIPT_SINIT( aCURSESSION,aDINAMICFILTERSCRIPTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure DINAMICFILTERSCRIPT_PARENT /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from DINAMICFILTERSCRIPT where  DINAMICFILTERSCRIPTid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure DINAMICFILTERSCRIPT_ISLOCKED /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  DINAMICFILTERSCRIPT_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure DINAMICFILTERSCRIPT_LOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 DINAMICFILTERSCRIPT_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  DINAMICFILTERSCRIPT_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=DINAMICFILTERSCRIPT');
    return;
  end if;
   if  aLockMode =2  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =auserID ,LockSessionID =null where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =null,LockSessionID =aCURSESSION  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
 end ;

procedure DINAMICFILTERSCRIPT_HCL /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure DINAMICFILTERSCRIPT_UNLOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 DINAMICFILTERSCRIPT_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update DINAMICFILTERSCRIPT set LockUserID =null  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update DINAMICFILTERSCRIPT set LockSessionID =null  where DINAMICFILTERSCRIPTid=aRowID;
     return;
   end if;
 end; 

procedure DINAMICFILTERSCRIPT_SINIT /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =DINAMICFILTERSCRIPT');
    return;
  end if;
if aSecurityStyleID is null then
 DINAMICFILTERSCRIPT_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update DINAMICFILTERSCRIPT set securitystyleid =aStyleID where DINAMICFILTERSCRIPTid = aRowID;
else 
 update DINAMICFILTERSCRIPT set securitystyleid =aSecurityStyleID where DINAMICFILTERSCRIPTid = aRowID;
end if; 
end ; 

procedure DINAMICFILTERSCRIPT_propagate /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from DINAMICFILTERSCRIPT where DINAMICFILTERSCRIPTid=aRowid;
end;


procedure FIELDEXPRESSION_BRIEF  (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDEXPRESSIONid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDEXPRESSION where FIELDEXPRESSIONid=aFIELDEXPRESSIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDEXPRESSION');
    return;
  end if;
  aBRIEF:=func.FIELDEXPRESSION_BRIEF_F(aFIELDEXPRESSIONid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDEXPRESSION_DELETE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDEXPRESSION where FIELDEXPRESSIONid=aFIELDEXPRESSIONID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDEXPRESSION',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDEXPRESSION');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDEXPRESSION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDEXPRESSIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDEXPRESSION is select  instanceid ID from instance where OwnerPartName ='FIELDEXPRESSION' and OwnerRowID=aFIELDEXPRESSIONid;
row_FIELDEXPRESSION  chld_FIELDEXPRESSION%ROWTYPE;
begin
--open chld_FIELDEXPRESSION;
for row_FIELDEXPRESSION in chld_FIELDEXPRESSION loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDEXPRESSION.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDEXPRESSION.id);
end loop;
--close chld_FIELDEXPRESSION;
end ;
  delete from  FIELDEXPRESSION 
  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Значение по умолчанию*/
procedure FIELDEXPRESSION_SAVE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aFIELDEXPRESSIONid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDEXPRESSION where FIELDEXPRESSIONID=aFIELDEXPRESSIONID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDEXPRESSION where FIELDEXPRESSIONid=aFIELDEXPRESSIONID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDEXPRESSION',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDEXPRESSION');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDEXPRESSION_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDEXPRESSIONid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
 -- update row  --
 update  FIELDEXPRESSION set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  FIELDEXPRESSIONID = aFIELDEXPRESSIONID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDEXPRESSION',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDEXPRESSION');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDEXPRESSION');
    return;
  end if;
 insert into   FIELDEXPRESSION
 (  FIELDEXPRESSIONID 
,ParentStructRowID
,Target

,Code

 ) values ( aFIELDEXPRESSIONID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 FIELDEXPRESSION_SINIT( aCURSESSION,aFIELDEXPRESSIONid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDEXPRESSION_PARENT /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDEXPRESSION where  FIELDEXPRESSIONid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure FIELDEXPRESSION_ISLOCKED /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDEXPRESSION where FIELDEXPRESSIONid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDEXPRESSION_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDEXPRESSION_LOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDEXPRESSION_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDEXPRESSION_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDEXPRESSION where FIELDEXPRESSIONid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDEXPRESSION');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDEXPRESSION set LockUserID =auserID ,LockSessionID =null where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDEXPRESSION set LockUserID =null,LockSessionID =aCURSESSION  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
 end ;

procedure FIELDEXPRESSION_HCL /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDEXPRESSION_UNLOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDEXPRESSION_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDEXPRESSION set LockUserID =null  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDEXPRESSION set LockSessionID =null  where FIELDEXPRESSIONid=aRowID;
     return;
   end if;
 end; 

procedure FIELDEXPRESSION_SINIT /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDEXPRESSION where FIELDEXPRESSIONid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDEXPRESSION');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDEXPRESSION_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDEXPRESSION set securitystyleid =aStyleID where FIELDEXPRESSIONid = aRowID;
else 
 update FIELDEXPRESSION set securitystyleid =aSecurityStyleID where FIELDEXPRESSIONid = aRowID;
end if; 
end ; 

procedure FIELDEXPRESSION_propagate /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDEXPRESSION where FIELDEXPRESSIONid=aRowid;
end;


procedure FIELDVALIDATOR_BRIEF  (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDVALIDATORid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDVALIDATOR where FIELDVALIDATORid=aFIELDVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDVALIDATOR');
    return;
  end if;
  aBRIEF:=func.FIELDVALIDATOR_BRIEF_F(aFIELDVALIDATORid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDVALIDATOR_DELETE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDVALIDATOR where FIELDVALIDATORid=aFIELDVALIDATORID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDVALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDVALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDVALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDVALIDATOR is select  instanceid ID from instance where OwnerPartName ='FIELDVALIDATOR' and OwnerRowID=aFIELDVALIDATORid;
row_FIELDVALIDATOR  chld_FIELDVALIDATOR%ROWTYPE;
begin
--open chld_FIELDVALIDATOR;
for row_FIELDVALIDATOR in chld_FIELDVALIDATOR loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDVALIDATOR.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDVALIDATOR.id);
end loop;
--close chld_FIELDVALIDATOR;
end ;
  delete from  FIELDVALIDATOR 
  where  FIELDVALIDATORID = aFIELDVALIDATORID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Логика поля на форме*/
procedure FIELDVALIDATOR_SAVE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aFIELDVALIDATORid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTarget CHAR/* Платформа *//* Платформа */
,aCode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDVALIDATOR where FIELDVALIDATORID=aFIELDVALIDATORID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDVALIDATOR where FIELDVALIDATORid=aFIELDVALIDATORID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDVALIDATOR',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDVALIDATOR');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDVALIDATOR_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDVALIDATORid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
 -- update row  --
 update  FIELDVALIDATOR set ChangeStamp=sysdate
,
  Target=aTarget
,
  Code=aCode
  where  FIELDVALIDATORID = aFIELDVALIDATORID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDVALIDATOR',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDVALIDATOR');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDVALIDATOR');
    return;
  end if;
 insert into   FIELDVALIDATOR
 (  FIELDVALIDATORID 
,ParentStructRowID
,Target

,Code

 ) values ( aFIELDVALIDATORID 
,aParentStructRowID
,aTarget

,aCode

 ); 
 FIELDVALIDATOR_SINIT( aCURSESSION,aFIELDVALIDATORid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDVALIDATOR_PARENT /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDVALIDATOR where  FIELDVALIDATORid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure FIELDVALIDATOR_ISLOCKED /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDVALIDATOR where FIELDVALIDATORid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDVALIDATOR_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDVALIDATOR_LOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDVALIDATOR_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDVALIDATOR_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDVALIDATOR where FIELDVALIDATORid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDVALIDATOR');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDVALIDATOR set LockUserID =auserID ,LockSessionID =null where FIELDVALIDATORid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDVALIDATOR set LockUserID =null,LockSessionID =aCURSESSION  where FIELDVALIDATORid=aRowID;
     return;
   end if;
 end ;

procedure FIELDVALIDATOR_HCL /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDVALIDATOR_UNLOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDVALIDATOR_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDVALIDATOR set LockUserID =null  where FIELDVALIDATORid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDVALIDATOR set LockSessionID =null  where FIELDVALIDATORid=aRowID;
     return;
   end if;
 end; 

procedure FIELDVALIDATOR_SINIT /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDVALIDATOR where FIELDVALIDATORid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDVALIDATOR');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDVALIDATOR_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDVALIDATOR set securitystyleid =aStyleID where FIELDVALIDATORid = aRowID;
else 
 update FIELDVALIDATOR set securitystyleid =aSecurityStyleID where FIELDVALIDATORid = aRowID;
end if; 
end ; 

procedure FIELDVALIDATOR_propagate /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDVALIDATOR where FIELDVALIDATORid=aRowid;
end;


procedure FIELDMENU_BRIEF  (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDMENUid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDMENU where FIELDMENUid=aFIELDMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDMENU');
    return;
  end if;
  aBRIEF:=func.FIELDMENU_BRIEF_F(aFIELDMENUid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDMENU_DELETE /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDMENU where FIELDMENUid=aFIELDMENUID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDMENU',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDMENU');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_FIELDPARAMMAP is select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aFIELDMENUid;
    child_FIELDPARAMMAP_rec  child_FIELDPARAMMAP%ROWTYPE;
    begin
    --open child_FIELDPARAMMAP;
      for child_FIELDPARAMMAP_rec in child_FIELDPARAMMAP loop
      FIELDPARAMMAP_DELETE (acursession,child_FIELDPARAMMAP_rec.id,aInstanceid);
      end loop;
      --close child_FIELDPARAMMAP;
    end ;
declare cursor chld_FIELDMENU is select  instanceid ID from instance where OwnerPartName ='FIELDMENU' and OwnerRowID=aFIELDMENUid;
row_FIELDMENU  chld_FIELDMENU%ROWTYPE;
begin
--open chld_FIELDMENU;
for row_FIELDMENU in chld_FIELDMENU loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDMENU.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDMENU.id);
end loop;
--close chld_FIELDMENU;
end ;
  delete from  FIELDMENU 
  where  FIELDMENUID = aFIELDMENUID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы поля*/
procedure FIELDMENU_SAVE /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aFIELDMENUid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aToolTip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,aActionID CHAR/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aIsMenuItem
 NUMBER/* В меню *//* В меню */
,aIsToolBarButton
 NUMBER/* В тулбар *//* В тулбар */
,aHotKey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDMENU where FIELDMENUID=aFIELDMENUID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDMENU where FIELDMENUid=aFIELDMENUID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDMENU',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDMENU');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDMENU_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDMENUid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDMENU');
    return;
  end if;
 -- update row  --
 update  FIELDMENU set ChangeStamp=sysdate
,
  Name=aName
,
  Caption=aCaption
,
  ToolTip=aToolTip
,
  ActionID=aActionID
,
  IsMenuItem=aIsMenuItem
,
  IsToolBarButton=aIsToolBarButton
,
  HotKey=aHotKey
  where  FIELDMENUID = aFIELDMENUID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELD where FIELDid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDMENU',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDMENU');
      return;
    end if;
 end if;
 FIELD_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDMENU');
    return;
  end if;
 insert into   FIELDMENU
 (  FIELDMENUID 
,ParentStructRowID
,Name

,Caption

,ToolTip

,ActionID

,IsMenuItem

,IsToolBarButton

,HotKey

 ) values ( aFIELDMENUID 
,aParentStructRowID
,aName

,aCaption

,aToolTip

,aActionID

,aIsMenuItem

,aIsToolBarButton

,aHotKey

 ); 
 FIELDMENU_SINIT( aCURSESSION,aFIELDMENUid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDMENU_PARENT /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDMENU where  FIELDMENUid=aRowID;
  aParentTable := 'FIELD';
 end; 

procedure FIELDMENU_ISLOCKED /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDMENU where FIELDMENUid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDMENU_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDMENU_LOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDMENU_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDMENU_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDMENU where FIELDMENUid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDMENU');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDMENU set LockUserID =auserID ,LockSessionID =null where FIELDMENUid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDMENU set LockUserID =null,LockSessionID =aCURSESSION  where FIELDMENUid=aRowID;
     return;
   end if;
 end ;

procedure FIELDMENU_HCL /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_FIELDPARAMMAP is select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aRowid;
row_FIELDPARAMMAP lch_FIELDPARAMMAP%ROWTYPE;
begin  
--open lch_FIELDPARAMMAP;
for row_FIELDPARAMMAP in lch_FIELDPARAMMAP
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FIELDPARAMMAP where FIELDPARAMMAPid=row_FIELDPARAMMAP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FIELDPARAMMAP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FIELDPARAMMAP;
     return;
   end if; 
 end if;  
 FIELDPARAMMAP_HCL (acursession,row_FIELDPARAMMAP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FIELDPARAMMAP;
   return;
 end if;
end loop;
--close lch_FIELDPARAMMAP;
end;
aIsLocked :=0;
end;

procedure FIELDMENU_UNLOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDMENU_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDMENU set LockUserID =null  where FIELDMENUid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDMENU set LockSessionID =null  where FIELDMENUid=aRowID;
     return;
   end if;
 end; 

procedure FIELDMENU_SINIT /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDMENU where FIELDMENUid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDMENU');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDMENU_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDMENU set securitystyleid =aStyleID where FIELDMENUid = aRowID;
else 
 update FIELDMENU set securitystyleid =aSecurityStyleID where FIELDMENUid = aRowID;
end if; 
end ; 

procedure FIELDMENU_propagate /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDMENU where FIELDMENUid=aRowid;
declare cursor pch_FIELDPARAMMAP  is select FIELDPARAMMAP.FIELDPARAMMAPid ID from FIELDPARAMMAP where  FIELDPARAMMAP.ParentStructRowID = aRowid;
row_FIELDPARAMMAP  pch_FIELDPARAMMAP%ROWTYPE;
begin
--open pch_FIELDPARAMMAP;
for row_FIELDPARAMMAP in pch_FIELDPARAMMAP loop
   FIELDPARAMMAP_SINIT( acursession,row_FIELDPARAMMAP.id,assid);
   FIELDPARAMMAP_propagate( acursession,row_FIELDPARAMMAP.id);
end loop;
--close pch_FIELDPARAMMAP;
end;
end;


procedure FIELDPARAMMAP_BRIEF  (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFIELDPARAMMAPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FIELDPARAMMAP where FIELDPARAMMAPid=aFIELDPARAMMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FIELDPARAMMAP');
    return;
  end if;
  aBRIEF:=func.FIELDPARAMMAP_BRIEF_F(aFIELDPARAMMAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FIELDPARAMMAP_DELETE /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FIELDPARAMMAP where FIELDPARAMMAPid=aFIELDPARAMMAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FIELDPARAMMAP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FIELDPARAMMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDPARAMMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDPARAMMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FIELDPARAMMAP is select  instanceid ID from instance where OwnerPartName ='FIELDPARAMMAP' and OwnerRowID=aFIELDPARAMMAPid;
row_FIELDPARAMMAP  chld_FIELDPARAMMAP%ROWTYPE;
begin
--open chld_FIELDPARAMMAP;
for row_FIELDPARAMMAP in chld_FIELDPARAMMAP loop
 Kernel.INSTANCE_OWNER (acursession,row_FIELDPARAMMAP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FIELDPARAMMAP.id);
end loop;
--close chld_FIELDPARAMMAP;
end ;
  delete from  FIELDPARAMMAP 
  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение параметров*/
procedure FIELDPARAMMAP_SAVE /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aFIELDPARAMMAPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aFieldName
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aParamName
 VARCHAR2/* Параметр *//* Параметр */
,aNoEdit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FIELDPARAMMAP where FIELDPARAMMAPID=aFIELDPARAMMAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FIELDPARAMMAP where FIELDPARAMMAPid=aFIELDPARAMMAPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FIELDPARAMMAP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FIELDPARAMMAP');
      return;
    end if;
  end if;
 --  verify lock  --
 FIELDPARAMMAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFIELDPARAMMAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
 -- update row  --
 update  FIELDPARAMMAP set ChangeStamp=sysdate
,
  FieldName=aFieldName
,
  ParamName=aParamName
,
  NoEdit=aNoEdit
  where  FIELDPARAMMAPID = aFIELDPARAMMAPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FIELDMENU where FIELDMENUid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FIELDPARAMMAP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FIELDPARAMMAP');
      return;
    end if;
 end if;
 FIELDMENU_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FIELDPARAMMAP');
    return;
  end if;
 insert into   FIELDPARAMMAP
 (  FIELDPARAMMAPID 
,ParentStructRowID
,FieldName

,ParamName

,NoEdit

 ) values ( aFIELDPARAMMAPID 
,aParentStructRowID
,aFieldName

,aParamName

,aNoEdit

 ); 
 FIELDPARAMMAP_SINIT( aCURSESSION,aFIELDPARAMMAPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FIELDPARAMMAP_PARENT /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FIELDPARAMMAP where  FIELDPARAMMAPid=aRowID;
  aParentTable := 'FIELDMENU';
 end; 

procedure FIELDPARAMMAP_ISLOCKED /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FIELDPARAMMAP where FIELDPARAMMAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FIELDPARAMMAP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FIELDPARAMMAP_LOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FIELDPARAMMAP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FIELDPARAMMAP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FIELDPARAMMAP where FIELDPARAMMAPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FIELDPARAMMAP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FIELDPARAMMAP set LockUserID =auserID ,LockSessionID =null where FIELDPARAMMAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FIELDPARAMMAP set LockUserID =null,LockSessionID =aCURSESSION  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
 end ;

procedure FIELDPARAMMAP_HCL /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FIELDPARAMMAP_UNLOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FIELDPARAMMAP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FIELDPARAMMAP set LockUserID =null  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FIELDPARAMMAP set LockSessionID =null  where FIELDPARAMMAPid=aRowID;
     return;
   end if;
 end; 

procedure FIELDPARAMMAP_SINIT /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FIELDPARAMMAP where FIELDPARAMMAPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FIELDPARAMMAP');
    return;
  end if;
if aSecurityStyleID is null then
 FIELDPARAMMAP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FIELDPARAMMAP set securitystyleid =aStyleID where FIELDPARAMMAPid = aRowID;
else 
 update FIELDPARAMMAP set securitystyleid =aSecurityStyleID where FIELDPARAMMAPid = aRowID;
end if; 
end ; 

procedure FIELDPARAMMAP_propagate /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FIELDPARAMMAP where FIELDPARAMMAPid=aRowid;
end;


procedure MTZAPP_BRIEF  (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aMTZAPPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from MTZAPP where MTZAPPid=aMTZAPPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=MTZAPP');
    return;
  end if;
  aBRIEF:=func.MTZAPP_BRIEF_F(aMTZAPPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure MTZAPP_DELETE /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from MTZAPP where MTZAPPid=aMTZAPPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:MTZAPP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=MTZAPP');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZAPP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZAPPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZAPP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ParentPackage is select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aMTZAPPid;
    child_ParentPackage_rec  child_ParentPackage%ROWTYPE;
    begin
    --open child_ParentPackage;
      for child_ParentPackage_rec in child_ParentPackage loop
      ParentPackage_DELETE (acursession,child_ParentPackage_rec.id,aInstanceid);
      end loop;
      --close child_ParentPackage;
    end ;
declare cursor chld_MTZAPP is select  instanceid ID from instance where OwnerPartName ='MTZAPP' and OwnerRowID=aMTZAPPid;
row_MTZAPP  chld_MTZAPP%ROWTYPE;
begin
--open chld_MTZAPP;
for row_MTZAPP in chld_MTZAPP loop
 Kernel.INSTANCE_OWNER (acursession,row_MTZAPP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_MTZAPP.id);
end loop;
--close chld_MTZAPP;
end ;
  delete from  MTZAPP 
  where  MTZAPPID = aMTZAPPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Приложение*/
procedure MTZAPP_SAVE /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aMTZAPPid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aDBName
 VARCHAR2 := null /* База данных *//* База данных */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZAPP where MTZAPPID=aMTZAPPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from MTZAPP where MTZAPPid=aMTZAPPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:MTZAPP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=MTZAPP');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZAPP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZAPPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZAPP');
    return;
  end if;
 -- update row  --
 update  MTZAPP set ChangeStamp=sysdate
,
  Name=aName
,
  DBName=aDBName
,
  TheComment=aTheComment
  where  MTZAPPID = aMTZAPPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:MTZAPP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=MTZAPP');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZAPP');
    return;
  end if;
 insert into   MTZAPP
 (  MTZAPPID 
,InstanceID
,Name

,DBName

,TheComment

 ) values ( aMTZAPPID 
,aInstanceID
,aName

,aDBName

,aTheComment

 ); 
 MTZAPP_SINIT( aCURSESSION,aMTZAPPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure MTZAPP_PARENT /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from MTZAPP where  MTZAPPid=aRowID;
 end; 

procedure MTZAPP_ISLOCKED /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZAPP where MTZAPPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  MTZAPP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure MTZAPP_LOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 MTZAPP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  MTZAPP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from MTZAPP where MTZAPPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=MTZAPP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update MTZAPP set LockUserID =auserID ,LockSessionID =null where MTZAPPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZAPP set LockUserID =null,LockSessionID =aCURSESSION  where MTZAPPid=aRowID;
     return;
   end if;
 end ;

procedure MTZAPP_HCL /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ParentPackage is select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aRowid;
row_ParentPackage lch_ParentPackage%ROWTYPE;
begin  
--open lch_ParentPackage;
for row_ParentPackage in lch_ParentPackage
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ParentPackage where ParentPackageid=row_ParentPackage.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ParentPackage;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ParentPackage;
     return;
   end if; 
 end if;  
 ParentPackage_HCL (acursession,row_ParentPackage.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ParentPackage;
   return;
 end if;
end loop;
--close lch_ParentPackage;
end;
aIsLocked :=0;
end;

procedure MTZAPP_UNLOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 MTZAPP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZAPP set LockUserID =null  where MTZAPPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZAPP set LockSessionID =null  where MTZAPPid=aRowID;
     return;
   end if;
 end; 

procedure MTZAPP_SINIT /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from MTZAPP where MTZAPPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =MTZAPP');
    return;
  end if;
if aSecurityStyleID is null then
 MTZAPP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update MTZAPP set securitystyleid =aStyleID where MTZAPPid = aRowID;
else 
 update MTZAPP set securitystyleid =aSecurityStyleID where MTZAPPid = aRowID;
end if; 
end ; 

procedure MTZAPP_propagate /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from MTZAPP where MTZAPPid=aRowid;
declare cursor pch_ParentPackage  is select ParentPackage.ParentPackageid ID from ParentPackage where  ParentPackage.ParentStructRowID = aRowid;
row_ParentPackage  pch_ParentPackage%ROWTYPE;
begin
--open pch_ParentPackage;
for row_ParentPackage in pch_ParentPackage loop
   ParentPackage_SINIT( acursession,row_ParentPackage.id,assid);
   ParentPackage_propagate( acursession,row_ParentPackage.id);
end loop;
--close pch_ParentPackage;
end;
end;


procedure ParentPackage_BRIEF  (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aParentPackageid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ParentPackage where ParentPackageid=aParentPackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ParentPackage');
    return;
  end if;
  aBRIEF:=func.ParentPackage_BRIEF_F(aParentPackageid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ParentPackage_DELETE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ParentPackage where ParentPackageid=aParentPackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ParentPackage',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ParentPackage');
      return;
    end if;
  end if;
 --  verify lock  --
 ParentPackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aParentPackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ParentPackage');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ParentPackage is select  instanceid ID from instance where OwnerPartName ='ParentPackage' and OwnerRowID=aParentPackageid;
row_ParentPackage  chld_ParentPackage%ROWTYPE;
begin
--open chld_ParentPackage;
for row_ParentPackage in chld_ParentPackage loop
 Kernel.INSTANCE_OWNER (acursession,row_ParentPackage.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ParentPackage.id);
end loop;
--close chld_ParentPackage;
end ;
  delete from  ParentPackage 
  where  ParentPackageID = aParentPackageID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Обязательные приложения*/
procedure ParentPackage_SAVE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aParentPackageid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aPackage CHAR/* Приложение *//* Приложение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ParentPackage where ParentPackageID=aParentPackageID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ParentPackage where ParentPackageid=aParentPackageID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ParentPackage',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ParentPackage');
      return;
    end if;
  end if;
 --  verify lock  --
 ParentPackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aParentPackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ParentPackage');
    return;
  end if;
 -- update row  --
 update  ParentPackage set ChangeStamp=sysdate
,
  Package=aPackage
  where  ParentPackageID = aParentPackageID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from MTZAPP where MTZAPPid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ParentPackage',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ParentPackage');
      return;
    end if;
 end if;
 MTZAPP_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ParentPackage');
    return;
  end if;
 insert into   ParentPackage
 (  ParentPackageID 
,ParentStructRowID
,Package

 ) values ( aParentPackageID 
,aParentStructRowID
,aPackage

 ); 
 ParentPackage_SINIT( aCURSESSION,aParentPackageid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ParentPackage_PARENT /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ParentPackage where  ParentPackageid=aRowID;
  aParentTable := 'MTZAPP';
 end; 

procedure ParentPackage_ISLOCKED /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ParentPackage where ParentPackageid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ParentPackage_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZMetaModel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ParentPackage_LOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ParentPackage_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ParentPackage_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ParentPackage where ParentPackageid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ParentPackage');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ParentPackage set LockUserID =auserID ,LockSessionID =null where ParentPackageid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ParentPackage set LockUserID =null,LockSessionID =aCURSESSION  where ParentPackageid=aRowID;
     return;
   end if;
 end ;

procedure ParentPackage_HCL /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ParentPackage_UNLOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ParentPackage_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ParentPackage set LockUserID =null  where ParentPackageid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ParentPackage set LockSessionID =null  where ParentPackageid=aRowID;
     return;
   end if;
 end; 

procedure ParentPackage_SINIT /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ParentPackage where ParentPackageid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ParentPackage');
    return;
  end if;
if aSecurityStyleID is null then
 ParentPackage_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ParentPackage set securitystyleid =aStyleID where ParentPackageid = aRowID;
else 
 update ParentPackage set securitystyleid =aSecurityStyleID where ParentPackageid = aRowID;
end if; 
end ; 

procedure ParentPackage_propagate /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ParentPackage where ParentPackageid=aRowid;
end;
end MTZMetaModel;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZJrnl" BlockCode=" create or replace package body MTZJrnl as

procedure MTZJrnl_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZJrnl'
then
declare cursor child_JournalColumn is select JournalColumn.JournalColumnid ID from JournalColumn where  JournalColumn.InstanceID = ainstanceid;
row_JournalColumn  child_JournalColumn%ROWTYPE;
begin
--open child_JournalColumn;
for row_JournalColumn in child_JournalColumn loop
 JournalColumn_DELETE (acursession,row_JournalColumn.id,aInstanceID);
end loop;
--close child_JournalColumn;
end;
declare cursor child_JournalSrc is select JournalSrc.JournalSrcid ID from JournalSrc where  JournalSrc.InstanceID = ainstanceid;
row_JournalSrc  child_JournalSrc%ROWTYPE;
begin
--open child_JournalSrc;
for row_JournalSrc in child_JournalSrc loop
 JournalSrc_DELETE (acursession,row_JournalSrc.id,aInstanceID);
end loop;
--close child_JournalSrc;
end;
declare cursor child_Journal is select Journal.Journalid ID from Journal where  Journal.InstanceID = ainstanceid;
row_Journal  child_Journal%ROWTYPE;
begin
--open child_Journal;
for row_Journal in child_Journal loop
 Journal_DELETE (acursession,row_Journal.id,aInstanceID);
end loop;
--close child_Journal;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZJrnl_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZJrnl'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_JournalColumn is select JournalColumn.JournalColumnid ID from JournalColumn where  JournalColumn.InstanceID = arowid;
ROW_JournalColumn  lch_JournalColumn%ROWTYPE;
begin
--open lch_JournalColumn;
for row_JournalColumn in lch_JournalColumn loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from JournalColumn where JournalColumnid=row_JournalColumn.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_JournalColumn;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_JournalColumn;
     return;
   end if; 
 end if; 
 JournalColumn_HCL (acursession,ROW_JournalColumn.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_JournalColumn;
   return;
 end if;
 end loop;
--close lch_JournalColumn;
end;
declare cursor lch_JournalSrc is select JournalSrc.JournalSrcid ID from JournalSrc where  JournalSrc.InstanceID = arowid;
ROW_JournalSrc  lch_JournalSrc%ROWTYPE;
begin
--open lch_JournalSrc;
for row_JournalSrc in lch_JournalSrc loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from JournalSrc where JournalSrcid=row_JournalSrc.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_JournalSrc;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_JournalSrc;
     return;
   end if; 
 end if; 
 JournalSrc_HCL (acursession,ROW_JournalSrc.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_JournalSrc;
   return;
 end if;
 end loop;
--close lch_JournalSrc;
end;
declare cursor lch_Journal is select Journal.Journalid ID from Journal where  Journal.InstanceID = arowid;
ROW_Journal  lch_Journal%ROWTYPE;
begin
--open lch_Journal;
for row_Journal in lch_Journal loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Journal where Journalid=row_Journal.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Journal;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Journal;
     return;
   end if; 
 end if; 
 Journal_HCL (acursession,ROW_Journal.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Journal;
   return;
 end if;
 end loop;
--close lch_Journal;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZJrnl_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZJrnl'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_JournalColumn is select JournalColumn.JournalColumnid id from JournalColumn where  JournalColumn.InstanceID = arowid;
row_JournalColumn  pch_JournalColumn%ROWTYPE;
begin
--open pch_JournalColumn;
for row_JournalColumn in  pch_JournalColumn loop
 JournalColumn_SINIT( acursession,row_JournalColumn.id,assid);
 JournalColumn_propagate( acursession,row_JournalColumn.id);
end loop;
--close pch_JournalColumn;
end;
declare cursor pch_JournalSrc is select JournalSrc.JournalSrcid id from JournalSrc where  JournalSrc.InstanceID = arowid;
row_JournalSrc  pch_JournalSrc%ROWTYPE;
begin
--open pch_JournalSrc;
for row_JournalSrc in  pch_JournalSrc loop
 JournalSrc_SINIT( acursession,row_JournalSrc.id,assid);
 JournalSrc_propagate( acursession,row_JournalSrc.id);
end loop;
--close pch_JournalSrc;
end;
declare cursor pch_Journal is select Journal.Journalid id from Journal where  Journal.InstanceID = arowid;
row_Journal  pch_Journal%ROWTYPE;
begin
--open pch_Journal;
for row_Journal in  pch_Journal loop
 Journal_SINIT( acursession,row_Journal.id,assid);
 Journal_propagate( acursession,row_Journal.id);
end loop;
--close pch_Journal;
end;
 end if; 
end;


procedure JournalColumn_BRIEF  (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aJournalColumnid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from JournalColumn where JournalColumnid=aJournalColumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=JournalColumn');
    return;
  end if;
  aBRIEF:=func.JournalColumn_BRIEF_F(aJournalColumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure JournalColumn_DELETE /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from JournalColumn where JournalColumnid=aJournalColumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:JournalColumn',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=JournalColumn');
      return;
    end if;
  end if;
 --  verify lock  --
 JournalColumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalColumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JournalColumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_JColumnSource is select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aJournalColumnid;
    child_JColumnSource_rec  child_JColumnSource%ROWTYPE;
    begin
    --open child_JColumnSource;
      for child_JColumnSource_rec in child_JColumnSource loop
      JColumnSource_DELETE (acursession,child_JColumnSource_rec.id,aInstanceid);
      end loop;
      --close child_JColumnSource;
    end ;
declare cursor chld_JournalColumn is select  instanceid ID from instance where OwnerPartName ='JournalColumn' and OwnerRowID=aJournalColumnid;
row_JournalColumn  chld_JournalColumn%ROWTYPE;
begin
--open chld_JournalColumn;
for row_JournalColumn in chld_JournalColumn loop
 Kernel.INSTANCE_OWNER (acursession,row_JournalColumn.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_JournalColumn.id);
end loop;
--close chld_JournalColumn;
end ;
  delete from  JournalColumn 
  where  JournalColumnID = aJournalColumnID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Колонки журнала*/
procedure JournalColumn_SAVE /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aJournalColumnid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER := null /* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,aColumnAlignment
 NUMBER/* Выравнивание *//* Выравнивание */
,aColSort
 NUMBER/* Сортировка колонки *//* Сортировка колонки */
,aGroupAggregation
 NUMBER/* Аггрегация при группировке *//* Аггрегация при группировке */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JournalColumn where JournalColumnID=aJournalColumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from JournalColumn where JournalColumnid=aJournalColumnID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:JournalColumn',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=JournalColumn');
      return;
    end if;
  end if;
 --  verify lock  --
 JournalColumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalColumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalColumn');
    return;
  end if;
 -- update row  --
 update  JournalColumn set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  ColumnAlignment=aColumnAlignment
,
  ColSort=aColSort
,
  GroupAggregation=aGroupAggregation
  where  JournalColumnID = aJournalColumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:JournalColumn',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=JournalColumn');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalColumn');
    return;
  end if;
 insert into   JournalColumn
 (  JournalColumnID 
,InstanceID
,sequence

,name

,ColumnAlignment

,ColSort

,GroupAggregation

 ) values ( aJournalColumnID 
,aInstanceID
,asequence

,aname

,aColumnAlignment

,aColSort

,aGroupAggregation

 ); 
 JournalColumn_SINIT( aCURSESSION,aJournalColumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure JournalColumn_PARENT /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from JournalColumn where  JournalColumnid=aRowID;
 end; 

procedure JournalColumn_ISLOCKED /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JournalColumn where JournalColumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  JournalColumn_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZJrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure JournalColumn_LOCK /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 JournalColumn_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  JournalColumn_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from JournalColumn where JournalColumnid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=JournalColumn');
    return;
  end if;
   if  aLockMode =2  
   then   
    update JournalColumn set LockUserID =auserID ,LockSessionID =null where JournalColumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JournalColumn set LockUserID =null,LockSessionID =aCURSESSION  where JournalColumnid=aRowID;
     return;
   end if;
 end ;

procedure JournalColumn_HCL /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_JColumnSource is select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aRowid;
row_JColumnSource lch_JColumnSource%ROWTYPE;
begin  
--open lch_JColumnSource;
for row_JColumnSource in lch_JColumnSource
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from JColumnSource where JColumnSourceid=row_JColumnSource.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_JColumnSource;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_JColumnSource;
     return;
   end if; 
 end if;  
 JColumnSource_HCL (acursession,row_JColumnSource.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_JColumnSource;
   return;
 end if;
end loop;
--close lch_JColumnSource;
end;
aIsLocked :=0;
end;

procedure JournalColumn_UNLOCK /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 JournalColumn_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JournalColumn set LockUserID =null  where JournalColumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JournalColumn set LockSessionID =null  where JournalColumnid=aRowID;
     return;
   end if;
 end; 

procedure JournalColumn_SINIT /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from JournalColumn where JournalColumnid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =JournalColumn');
    return;
  end if;
if aSecurityStyleID is null then
 JournalColumn_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update JournalColumn set securitystyleid =aStyleID where JournalColumnid = aRowID;
else 
 update JournalColumn set securitystyleid =aSecurityStyleID where JournalColumnid = aRowID;
end if; 
end ; 

procedure JournalColumn_propagate /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from JournalColumn where JournalColumnid=aRowid;
declare cursor pch_JColumnSource  is select JColumnSource.JColumnSourceid ID from JColumnSource where  JColumnSource.ParentStructRowID = aRowid;
row_JColumnSource  pch_JColumnSource%ROWTYPE;
begin
--open pch_JColumnSource;
for row_JColumnSource in pch_JColumnSource loop
   JColumnSource_SINIT( acursession,row_JColumnSource.id,assid);
   JColumnSource_propagate( acursession,row_JColumnSource.id);
end loop;
--close pch_JColumnSource;
end;
end;


procedure JColumnSource_BRIEF  (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aJColumnSourceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from JColumnSource where JColumnSourceid=aJColumnSourceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=JColumnSource');
    return;
  end if;
  aBRIEF:=func.JColumnSource_BRIEF_F(aJColumnSourceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure JColumnSource_DELETE /*Состав колонки*/ (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from JColumnSource where JColumnSourceid=aJColumnSourceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:JColumnSource',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=JColumnSource');
      return;
    end if;
  end if;
 --  verify lock  --
 JColumnSource_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJColumnSourceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JColumnSource');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_JColumnSource is select  instanceid ID from instance where OwnerPartName ='JColumnSource' and OwnerRowID=aJColumnSourceid;
row_JColumnSource  chld_JColumnSource%ROWTYPE;
begin
--open chld_JColumnSource;
for row_JColumnSource in chld_JColumnSource loop
 Kernel.INSTANCE_OWNER (acursession,row_JColumnSource.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_JColumnSource.id);
end loop;
--close chld_JColumnSource;
end ;
  delete from  JColumnSource 
  where  JColumnSourceID = aJColumnSourceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состав колонки*/
procedure JColumnSource_SAVE /*Состав колонки*/ (
 aCURSESSION CHAR,
 aJColumnSourceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aSrcPartView CHAR/* Представление *//* Представление */
,aViewField
 VARCHAR2/* Поле представления *//* Поле представления */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JColumnSource where JColumnSourceID=aJColumnSourceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from JColumnSource where JColumnSourceid=aJColumnSourceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:JColumnSource',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=JColumnSource');
      return;
    end if;
  end if;
 --  verify lock  --
 JColumnSource_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJColumnSourceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JColumnSource');
    return;
  end if;
 -- update row  --
 update  JColumnSource set ChangeStamp=sysdate
,
  SrcPartView=aSrcPartView
,
  ViewField=aViewField
  where  JColumnSourceID = aJColumnSourceID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from JColumnSource where ParentStructRowID=aParentStructRowID 
 and SrcPartView=aSrcPartView;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JColumnSource');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from JournalColumn where JournalColumnid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:JColumnSource',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=JColumnSource');
      return;
    end if;
 end if;
 JournalColumn_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JColumnSource');
    return;
  end if;
 insert into   JColumnSource
 (  JColumnSourceID 
,ParentStructRowID
,SrcPartView

,ViewField

 ) values ( aJColumnSourceID 
,aParentStructRowID
,aSrcPartView

,aViewField

 ); 
 JColumnSource_SINIT( aCURSESSION,aJColumnSourceid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from JColumnSource where ParentStructRowID=aParentStructRowID 
 and SrcPartView=aSrcPartView;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JColumnSource');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure JColumnSource_PARENT /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from JColumnSource where  JColumnSourceid=aRowID;
  aParentTable := 'JournalColumn';
 end; 

procedure JColumnSource_ISLOCKED /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JColumnSource where JColumnSourceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  JColumnSource_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZJrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure JColumnSource_LOCK /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 JColumnSource_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  JColumnSource_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from JColumnSource where JColumnSourceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=JColumnSource');
    return;
  end if;
   if  aLockMode =2  
   then   
    update JColumnSource set LockUserID =auserID ,LockSessionID =null where JColumnSourceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JColumnSource set LockUserID =null,LockSessionID =aCURSESSION  where JColumnSourceid=aRowID;
     return;
   end if;
 end ;

procedure JColumnSource_HCL /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure JColumnSource_UNLOCK /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 JColumnSource_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JColumnSource set LockUserID =null  where JColumnSourceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JColumnSource set LockSessionID =null  where JColumnSourceid=aRowID;
     return;
   end if;
 end; 

procedure JColumnSource_SINIT /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from JColumnSource where JColumnSourceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =JColumnSource');
    return;
  end if;
if aSecurityStyleID is null then
 JColumnSource_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update JColumnSource set securitystyleid =aStyleID where JColumnSourceid = aRowID;
else 
 update JColumnSource set securitystyleid =aSecurityStyleID where JColumnSourceid = aRowID;
end if; 
end ; 

procedure JColumnSource_propagate /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from JColumnSource where JColumnSourceid=aRowid;
end;


procedure JournalSrc_BRIEF  (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aJournalSrcid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from JournalSrc where JournalSrcid=aJournalSrcID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=JournalSrc');
    return;
  end if;
  aBRIEF:=func.JournalSrc_BRIEF_F(aJournalSrcid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure JournalSrc_DELETE /*Источники журнала*/ (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from JournalSrc where JournalSrcid=aJournalSrcID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:JournalSrc',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=JournalSrc');
      return;
    end if;
  end if;
 --  verify lock  --
 JournalSrc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalSrcid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=JournalSrc');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_JournalSrc is select  instanceid ID from instance where OwnerPartName ='JournalSrc' and OwnerRowID=aJournalSrcid;
row_JournalSrc  chld_JournalSrc%ROWTYPE;
begin
--open chld_JournalSrc;
for row_JournalSrc in chld_JournalSrc loop
 Kernel.INSTANCE_OWNER (acursession,row_JournalSrc.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_JournalSrc.id);
end loop;
--close chld_JournalSrc;
end ;
  delete from  JournalSrc 
  where  JournalSrcID = aJournalSrcID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Источники журнала*/
procedure JournalSrc_SAVE /*Источники журнала*/ (
 aCURSESSION CHAR,
 aJournalSrcid CHAR,
aInstanceID CHAR 
,aPartView CHAR/* Представление *//* Представление */
,aOnRun
 NUMBER/* При открытии *//* При открытии */
,aOpenMode
 VARCHAR2 := null /* Режим открытия *//* Режим открытия */
,aViewAlias
 VARCHAR2 := null /* Псевдоним представления *//* Псевдоним представления */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from JournalSrc where JournalSrcID=aJournalSrcID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from JournalSrc where JournalSrcid=aJournalSrcID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:JournalSrc',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=JournalSrc');
      return;
    end if;
  end if;
 --  verify lock  --
 JournalSrc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalSrcid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalSrc');
    return;
  end if;
 -- update row  --
 update  JournalSrc set ChangeStamp=sysdate
,
  PartView=aPartView
,
  OnRun=aOnRun
,
  OpenMode=aOpenMode
,
  ViewAlias=aViewAlias
  where  JournalSrcID = aJournalSrcID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from JournalSrc where InstanceID=aInstanceID 
 and PartView=aPartView;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JournalSrc');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:JournalSrc',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=JournalSrc');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=JournalSrc');
    return;
  end if;
 insert into   JournalSrc
 (  JournalSrcID 
,InstanceID
,PartView

,OnRun

,OpenMode

,ViewAlias

 ) values ( aJournalSrcID 
,aInstanceID
,aPartView

,aOnRun

,aOpenMode

,aViewAlias

 ); 
 JournalSrc_SINIT( aCURSESSION,aJournalSrcid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from JournalSrc where InstanceID=aInstanceID 
 and PartView=aPartView;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=JournalSrc');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure JournalSrc_PARENT /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from JournalSrc where  JournalSrcid=aRowID;
 end; 

procedure JournalSrc_ISLOCKED /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from JournalSrc where JournalSrcid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  JournalSrc_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZJrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure JournalSrc_LOCK /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 JournalSrc_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  JournalSrc_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from JournalSrc where JournalSrcid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=JournalSrc');
    return;
  end if;
   if  aLockMode =2  
   then   
    update JournalSrc set LockUserID =auserID ,LockSessionID =null where JournalSrcid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update JournalSrc set LockUserID =null,LockSessionID =aCURSESSION  where JournalSrcid=aRowID;
     return;
   end if;
 end ;

procedure JournalSrc_HCL /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure JournalSrc_UNLOCK /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 JournalSrc_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update JournalSrc set LockUserID =null  where JournalSrcid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update JournalSrc set LockSessionID =null  where JournalSrcid=aRowID;
     return;
   end if;
 end; 

procedure JournalSrc_SINIT /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from JournalSrc where JournalSrcid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =JournalSrc');
    return;
  end if;
if aSecurityStyleID is null then
 JournalSrc_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update JournalSrc set securitystyleid =aStyleID where JournalSrcid = aRowID;
else 
 update JournalSrc set securitystyleid =aSecurityStyleID where JournalSrcid = aRowID;
end if; 
end ; 

procedure JournalSrc_propagate /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from JournalSrc where JournalSrcid=aRowid;
end;


procedure Journal_BRIEF  (
 aCURSESSION CHAR,
 aJournalid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aJournalid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Journal where Journalid=aJournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Journal');
    return;
  end if;
  aBRIEF:=func.Journal_BRIEF_F(aJournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Journal_DELETE /*Журнал*/ (
 aCURSESSION CHAR,
 aJournalid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Journal where Journalid=aJournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Journal',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Journal');
      return;
    end if;
  end if;
 --  verify lock  --
 Journal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Journal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Journal is select  instanceid ID from instance where OwnerPartName ='Journal' and OwnerRowID=aJournalid;
row_Journal  chld_Journal%ROWTYPE;
begin
--open chld_Journal;
for row_Journal in chld_Journal loop
 Kernel.INSTANCE_OWNER (acursession,row_Journal.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Journal.id);
end loop;
--close chld_Journal;
end ;
  delete from  Journal 
  where  JournalID = aJournalID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Журнал*/
procedure Journal_SAVE /*Журнал*/ (
 aCURSESSION CHAR,
 aJournalid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,athe_Alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,ajrnlIconCls
 VARCHAR2 := null /* Иконка журнала *//* Иконка журнала */
,aUseFavorites
 NUMBER/* Массовое выделение *//* Массовое выделение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Journal where JournalID=aJournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Journal where Journalid=aJournalID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Journal',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Journal');
      return;
    end if;
  end if;
 --  verify lock  --
 Journal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aJournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Journal');
    return;
  end if;
 -- update row  --
 update  Journal set ChangeStamp=sysdate
,
  Name=aName
,
  the_Alias=athe_Alias
,
  TheComment=aTheComment
,
  jrnlIconCls=ajrnlIconCls
,
  UseFavorites=aUseFavorites
  where  JournalID = aJournalID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and the_Alias=athe_Alias;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Journal',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Journal');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Journal');
    return;
  end if;
select Count(*) into existsCnt from Journal where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Journal&gt;');
    return;
 End if;
 insert into   Journal
 (  JournalID 
,InstanceID
,Name

,the_Alias

,TheComment

,jrnlIconCls

,UseFavorites

 ) values ( aJournalID 
,aInstanceID
,aName

,athe_Alias

,aTheComment

,ajrnlIconCls

,aUseFavorites

 ); 
 Journal_SINIT( aCURSESSION,aJournalid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;
select Count(*) into aUniqueRowCount from Journal where 1=1  
 and the_Alias=athe_Alias;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Journal');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure Journal_PARENT /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Journal where  Journalid=aRowID;
 end; 

procedure Journal_ISLOCKED /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Journal where Journalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Journal_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZJrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Journal_LOCK /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Journal_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Journal_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Journal where Journalid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Journal');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Journal set LockUserID =auserID ,LockSessionID =null where Journalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Journal set LockUserID =null,LockSessionID =aCURSESSION  where Journalid=aRowID;
     return;
   end if;
 end ;

procedure Journal_HCL /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Journal_UNLOCK /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Journal_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Journal set LockUserID =null  where Journalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Journal set LockSessionID =null  where Journalid=aRowID;
     return;
   end if;
 end; 

procedure Journal_SINIT /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Journal where Journalid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Journal');
    return;
  end if;
if aSecurityStyleID is null then
 Journal_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Journal set securitystyleid =aStyleID where Journalid = aRowID;
else 
 update Journal set securitystyleid =aSecurityStyleID where Journalid = aRowID;
end if; 
end ; 

procedure Journal_propagate /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Journal where Journalid=aRowid;
end;
end MTZJrnl;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tod" BlockCode=" create or replace package body tod as

procedure tod_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tod'
then
declare cursor child_tod_bug is select tod_bug.tod_bugid ID from tod_bug where  tod_bug.InstanceID = ainstanceid;
row_tod_bug  child_tod_bug%ROWTYPE;
begin
--open child_tod_bug;
for row_tod_bug in child_tod_bug loop
 tod_bug_DELETE (acursession,row_tod_bug.id,aInstanceID);
end loop;
--close child_tod_bug;
end;
declare cursor child_tod_st is select tod_st.tod_stid ID from tod_st where  tod_st.InstanceID = ainstanceid;
row_tod_st  child_tod_st%ROWTYPE;
begin
--open child_tod_st;
for row_tod_st in child_tod_st loop
 tod_st_DELETE (acursession,row_tod_st.id,aInstanceID);
end loop;
--close child_tod_st;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tod_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tod'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_tod_bug is select tod_bug.tod_bugid ID from tod_bug where  tod_bug.InstanceID = arowid;
ROW_tod_bug  lch_tod_bug%ROWTYPE;
begin
--open lch_tod_bug;
for row_tod_bug in lch_tod_bug loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_bug where tod_bugid=row_tod_bug.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_bug;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_bug;
     return;
   end if; 
 end if; 
 tod_bug_HCL (acursession,ROW_tod_bug.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_bug;
   return;
 end if;
 end loop;
--close lch_tod_bug;
end;
declare cursor lch_tod_st is select tod_st.tod_stid ID from tod_st where  tod_st.InstanceID = arowid;
ROW_tod_st  lch_tod_st%ROWTYPE;
begin
--open lch_tod_st;
for row_tod_st in lch_tod_st loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_st where tod_stid=row_tod_st.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_st;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_st;
     return;
   end if; 
 end if; 
 tod_st_HCL (acursession,ROW_tod_st.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_st;
   return;
 end if;
 end loop;
--close lch_tod_st;
end;
 end if;
aIsLocked:=0;
end;
procedure tod_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tod'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_tod_bug is select tod_bug.tod_bugid id from tod_bug where  tod_bug.InstanceID = arowid;
row_tod_bug  pch_tod_bug%ROWTYPE;
begin
--open pch_tod_bug;
for row_tod_bug in  pch_tod_bug loop
 tod_bug_SINIT( acursession,row_tod_bug.id,assid);
 tod_bug_propagate( acursession,row_tod_bug.id);
end loop;
--close pch_tod_bug;
end;
declare cursor pch_tod_st is select tod_st.tod_stid id from tod_st where  tod_st.InstanceID = arowid;
row_tod_st  pch_tod_st%ROWTYPE;
begin
--open pch_tod_st;
for row_tod_st in  pch_tod_st loop
 tod_st_SINIT( acursession,row_tod_st.id,assid);
 tod_st_propagate( acursession,row_tod_st.id);
end loop;
--close pch_tod_st;
end;
 end if; 
end;


procedure tod_bug_BRIEF  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_bugid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_bug');
    return;
  end if;
  aBRIEF:=func.tod_bug_BRIEF_F(atod_bugid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_bug_DELETE /**/ (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_bug',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_bug');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_bug_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_bugid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_bug');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_bugid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_bug is select  instanceid ID from instance where OwnerPartName ='tod_bug' and OwnerRowID=atod_bugid;
row_tod_bug  chld_tod_bug%ROWTYPE;
begin
--open chld_tod_bug;
for row_tod_bug in chld_tod_bug loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_bug.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_bug.id);
end loop;
--close chld_tod_bug;
end ;
  delete from  tod_bug 
  where  tod_bugID = atod_bugID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Типичные проблемы*/
procedure tod_bug_SAVE /**/ (
 aCURSESSION CHAR,
 atod_bugid CHAR,
aInstanceID CHAR 
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_bug',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_bug');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_bug_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_bugid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_bug');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_bugid,aLogInstanceID=&gt;aInstanceID);
 update  tod_bug set ChangeStamp=sysdate
  where  tod_bugID = atod_bugID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_bug',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_bug');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_bug');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_bugid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_bug
 (  tod_bugID 
,InstanceID
 ) values ( atod_bugID 
,aInstanceID
 ); 
 tod_bug_SINIT( aCURSESSION,atod_bugid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_bug_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_bug where  tod_bugid=aRowID;
 end; 

procedure tod_bug_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_bug where tod_bugid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_bug_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_bug_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_bug_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_bug_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_bug where tod_bugid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_bug');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_bug set LockUserID =auserID ,LockSessionID =null where tod_bugid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_bug set LockUserID =null,LockSessionID =aCURSESSION  where tod_bugid=aRowID;
     return;
   end if;
 end ;

procedure tod_bug_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_bug_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_bug_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_bug set LockUserID =null  where tod_bugid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_bug set LockSessionID =null  where tod_bugid=aRowID;
     return;
   end if;
 end; 

procedure tod_bug_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_bug where tod_bugid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_bug');
    return;
  end if;
if aSecurityStyleID is null then
 tod_bug_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_bug set securitystyleid =aStyleID where tod_bugid = aRowID;
else 
 update tod_bug set securitystyleid =aSecurityStyleID where tod_bugid = aRowID;
end if; 
end ; 

procedure tod_bug_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_bug where tod_bugid=aRowid;
end;


procedure tod_st_BRIEF  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_stid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_st where tod_stid=atod_stID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_st');
    return;
  end if;
  aBRIEF:=func.tod_st_BRIEF_F(atod_stid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_st_DELETE /**/ (
 aCURSESSION CHAR,
 atod_stid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_st where tod_stid=atod_stID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_st',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_st');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_st_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_stid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_st');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_stid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_st is select  instanceid ID from instance where OwnerPartName ='tod_st' and OwnerRowID=atod_stid;
row_tod_st  chld_tod_st%ROWTYPE;
begin
--open chld_tod_st;
for row_tod_st in chld_tod_st loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_st.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_st.id);
end loop;
--close chld_tod_st;
end ;
  delete from  tod_st 
  where  tod_stID = atod_stID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Станки*/
procedure tod_st_SAVE /**/ (
 aCURSESSION CHAR,
 atod_stid CHAR,
aInstanceID CHAR 
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_st where tod_stid=atod_stID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_st',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_st');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_st_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_stid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_st');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_stid,aLogInstanceID=&gt;aInstanceID);
 update  tod_st set ChangeStamp=sysdate
  where  tod_stID = atod_stID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_st',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_st');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_st');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_stid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_st
 (  tod_stID 
,InstanceID
 ) values ( atod_stID 
,aInstanceID
 ); 
 tod_st_SINIT( aCURSESSION,atod_stid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_st_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_st where  tod_stid=aRowID;
 end; 

procedure tod_st_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_st where tod_stid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_st_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_st_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_st_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_st_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_st where tod_stid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_st');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_st set LockUserID =auserID ,LockSessionID =null where tod_stid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_st set LockUserID =null,LockSessionID =aCURSESSION  where tod_stid=aRowID;
     return;
   end if;
 end ;

procedure tod_st_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_st_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_st_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_st set LockUserID =null  where tod_stid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_st set LockSessionID =null  where tod_stid=aRowID;
     return;
   end if;
 end; 

procedure tod_st_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_st where tod_stid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_st');
    return;
  end if;
if aSecurityStyleID is null then
 tod_st_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_st set securitystyleid =aStyleID where tod_stid = aRowID;
else 
 update tod_st set securitystyleid =aSecurityStyleID where tod_stid = aRowID;
end if; 
end ; 

procedure tod_st_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_st where tod_stid=aRowid;
end;
end tod;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--STDInfoStore" BlockCode=" create or replace package body STDInfoStore as

procedure STDInfoStore_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='STDInfoStore'
then
declare cursor child_Folder is select Folder.Folderid ID from Folder where  Folder.InstanceID = ainstanceid;
row_Folder  child_Folder%ROWTYPE;
begin
--open child_Folder;
for row_Folder in child_Folder loop
 Folder_DELETE (acursession,row_Folder.id,aInstanceID);
end loop;
--close child_Folder;
end;
declare cursor child_InfoStoreDef is select InfoStoreDef.InfoStoreDefid ID from InfoStoreDef where  InfoStoreDef.InstanceID = ainstanceid;
row_InfoStoreDef  child_InfoStoreDef%ROWTYPE;
begin
--open child_InfoStoreDef;
for row_InfoStoreDef in child_InfoStoreDef loop
 InfoStoreDef_DELETE (acursession,row_InfoStoreDef.id,aInstanceID);
end loop;
--close child_InfoStoreDef;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure STDInfoStore_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'STDInfoStore'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_Folder is select Folder.Folderid ID from Folder where  Folder.InstanceID = arowid;
ROW_Folder  lch_Folder%ROWTYPE;
begin
--open lch_Folder;
for row_Folder in lch_Folder loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Folder where Folderid=row_Folder.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Folder;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Folder;
     return;
   end if; 
 end if; 
 Folder_HCL (acursession,ROW_Folder.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Folder;
   return;
 end if;
 end loop;
--close lch_Folder;
end;
declare cursor lch_InfoStoreDef is select InfoStoreDef.InfoStoreDefid ID from InfoStoreDef where  InfoStoreDef.InstanceID = arowid;
ROW_InfoStoreDef  lch_InfoStoreDef%ROWTYPE;
begin
--open lch_InfoStoreDef;
for row_InfoStoreDef in lch_InfoStoreDef loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from InfoStoreDef where InfoStoreDefid=row_InfoStoreDef.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_InfoStoreDef;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_InfoStoreDef;
     return;
   end if; 
 end if; 
 InfoStoreDef_HCL (acursession,ROW_InfoStoreDef.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_InfoStoreDef;
   return;
 end if;
 end loop;
--close lch_InfoStoreDef;
end;
 end if;
aIsLocked:=0;
end;
procedure STDInfoStore_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'STDInfoStore'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_Folder is select Folder.Folderid id from Folder where  Folder.InstanceID = arowid;
row_Folder  pch_Folder%ROWTYPE;
begin
--open pch_Folder;
for row_Folder in  pch_Folder loop
 Folder_SINIT( acursession,row_Folder.id,assid);
 Folder_propagate( acursession,row_Folder.id);
end loop;
--close pch_Folder;
end;
declare cursor pch_InfoStoreDef is select InfoStoreDef.InfoStoreDefid id from InfoStoreDef where  InfoStoreDef.InstanceID = arowid;
row_InfoStoreDef  pch_InfoStoreDef%ROWTYPE;
begin
--open pch_InfoStoreDef;
for row_InfoStoreDef in  pch_InfoStoreDef loop
 InfoStoreDef_SINIT( acursession,row_InfoStoreDef.id,assid);
 InfoStoreDef_propagate( acursession,row_InfoStoreDef.id);
end loop;
--close pch_InfoStoreDef;
end;
 end if; 
end;


procedure Folder_BRIEF  (
 aCURSESSION CHAR,
 aFolderid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFolderid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Folder where Folderid=aFolderID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Folder');
    return;
  end if;
  aBRIEF:=func.Folder_BRIEF_F(aFolderid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Folder_DELETE /*Папка каталога*/ (
 aCURSESSION CHAR,
 aFolderid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Folder where Folderid=aFolderID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Folder',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Folder');
      return;
    end if;
  end if;
 --  verify lock  --
 Folder_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFolderid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Folder');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_Shortcut is select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aFolderid;
    child_Shortcut_rec  child_Shortcut%ROWTYPE;
    begin
    --open child_Shortcut;
      for child_Shortcut_rec in child_Shortcut loop
      Shortcut_DELETE (acursession,child_Shortcut_rec.id,aInstanceid);
      end loop;
      --close child_Shortcut;
    end ;
declare cursor chld_Folder is select  instanceid ID from instance where OwnerPartName ='Folder' and OwnerRowID=aFolderid;
row_Folder  chld_Folder%ROWTYPE;
begin
--open chld_Folder;
for row_Folder in chld_Folder loop
 Kernel.INSTANCE_OWNER (acursession,row_Folder.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Folder.id);
end loop;
--close chld_Folder;
end ;
  delete from  Folder 
  where  FolderID = aFolderID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Папка*/
procedure Folder_SAVE /*Папка каталога*/ (
 aCURSESSION CHAR,
 aFolderid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aName
 VARCHAR2/* Название *//* Название */
,aFolderType
 NUMBER/* Тип папки *//* Тип папки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Folder where FolderID=aFolderID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Folder where Folderid=aFolderID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Folder',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Folder');
      return;
    end if;
  end if;
 --  verify lock  --
 Folder_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFolderid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Folder');
    return;
  end if;
 -- update row  --
 update  Folder set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  Name=aName
,
  FolderType=aFolderType
  where  FolderID = aFolderID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Folder',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Folder');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Folder');
    return;
  end if;
 insert into   Folder
 (  FolderID 
,ParentRowid
,InstanceID
,Name

,FolderType

 ) values ( aFolderID 
,aParentRowid
,aInstanceID
,aName

,aFolderType

 ); 
 Folder_SINIT( aCURSESSION,aFolderid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure Folder_PARENT /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Folder where  Folderid=aRowID;
 end; 

procedure Folder_ISLOCKED /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Folder where Folderid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Folder_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDInfoStore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Folder_LOCK /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Folder_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Folder_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Folder where Folderid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Folder');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Folder set LockUserID =auserID ,LockSessionID =null where Folderid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Folder set LockUserID =null,LockSessionID =aCURSESSION  where Folderid=aRowID;
     return;
   end if;
 end ;

procedure Folder_HCL /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_Shortcut is select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aRowid;
row_Shortcut lch_Shortcut%ROWTYPE;
begin  
--open lch_Shortcut;
for row_Shortcut in lch_Shortcut
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from Shortcut where Shortcutid=row_Shortcut.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Shortcut;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_Shortcut;
     return;
   end if; 
 end if;  
 Shortcut_HCL (acursession,row_Shortcut.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Shortcut;
   return;
 end if;
end loop;
--close lch_Shortcut;
end;
aIsLocked :=0;
end;

procedure Folder_UNLOCK /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Folder_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Folder set LockUserID =null  where Folderid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Folder set LockSessionID =null  where Folderid=aRowID;
     return;
   end if;
 end; 

procedure Folder_SINIT /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Folder where Folderid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Folder');
    return;
  end if;
if aSecurityStyleID is null then
 Folder_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Folder set securitystyleid =aStyleID where Folderid = aRowID;
else 
 update Folder set securitystyleid =aSecurityStyleID where Folderid = aRowID;
end if; 
end ; 

procedure Folder_propagate /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Folder where Folderid=aRowid;
declare cursor pch_Shortcut  is select Shortcut.Shortcutid ID from Shortcut where  Shortcut.ParentStructRowID = aRowid;
row_Shortcut  pch_Shortcut%ROWTYPE;
begin
--open pch_Shortcut;
for row_Shortcut in pch_Shortcut loop
   Shortcut_SINIT( acursession,row_Shortcut.id,assid);
   Shortcut_propagate( acursession,row_Shortcut.id);
end loop;
--close pch_Shortcut;
end;
end;


procedure Shortcut_BRIEF  (
 aCURSESSION CHAR,
 aShortcutid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aShortcutid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Shortcut where Shortcutid=aShortcutID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Shortcut');
    return;
  end if;
  aBRIEF:=func.Shortcut_BRIEF_F(aShortcutid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Shortcut_DELETE /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aShortcutid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Shortcut where Shortcutid=aShortcutID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Shortcut',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Shortcut');
      return;
    end if;
  end if;
 --  verify lock  --
 Shortcut_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aShortcutid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Shortcut');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Shortcut is select  instanceid ID from instance where OwnerPartName ='Shortcut' and OwnerRowID=aShortcutid;
row_Shortcut  chld_Shortcut%ROWTYPE;
begin
--open chld_Shortcut;
for row_Shortcut in chld_Shortcut loop
 Kernel.INSTANCE_OWNER (acursession,row_Shortcut.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Shortcut.id);
end loop;
--close chld_Shortcut;
end ;
  delete from  Shortcut 
  where  ShortcutID = aShortcutID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Документы*/
procedure Shortcut_SAVE /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aShortcutid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aDocItem CHAR/* Документ *//* Документ */
,aStartMode
 VARCHAR2 := null /* Режим *//* Режим */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Shortcut where ShortcutID=aShortcutID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Shortcut where Shortcutid=aShortcutID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Shortcut',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Shortcut');
      return;
    end if;
  end if;
 --  verify lock  --
 Shortcut_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aShortcutid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Shortcut');
    return;
  end if;
 -- update row  --
 update  Shortcut set ChangeStamp=sysdate
,
  DocItem=aDocItem
,
  StartMode=aStartMode
  where  ShortcutID = aShortcutID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from Folder where Folderid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Shortcut',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Shortcut');
      return;
    end if;
 end if;
 Folder_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Shortcut');
    return;
  end if;
 insert into   Shortcut
 (  ShortcutID 
,ParentStructRowID
,DocItem

,StartMode

 ) values ( aShortcutID 
,aParentStructRowID
,aDocItem

,aStartMode

 ); 
 Shortcut_SINIT( aCURSESSION,aShortcutid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure Shortcut_PARENT /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from Shortcut where  Shortcutid=aRowID;
  aParentTable := 'Folder';
 end; 

procedure Shortcut_ISLOCKED /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Shortcut where Shortcutid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Shortcut_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDInfoStore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Shortcut_LOCK /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Shortcut_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Shortcut_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Shortcut where Shortcutid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Shortcut');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Shortcut set LockUserID =auserID ,LockSessionID =null where Shortcutid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Shortcut set LockUserID =null,LockSessionID =aCURSESSION  where Shortcutid=aRowID;
     return;
   end if;
 end ;

procedure Shortcut_HCL /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Shortcut_UNLOCK /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Shortcut_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Shortcut set LockUserID =null  where Shortcutid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Shortcut set LockSessionID =null  where Shortcutid=aRowID;
     return;
   end if;
 end; 

procedure Shortcut_SINIT /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Shortcut where Shortcutid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Shortcut');
    return;
  end if;
if aSecurityStyleID is null then
 Shortcut_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Shortcut set securitystyleid =aStyleID where Shortcutid = aRowID;
else 
 update Shortcut set securitystyleid =aSecurityStyleID where Shortcutid = aRowID;
end if; 
end ; 

procedure Shortcut_propagate /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Shortcut where Shortcutid=aRowid;
end;


procedure InfoStoreDef_BRIEF  (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aInfoStoreDefid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from InfoStoreDef where InfoStoreDefid=aInfoStoreDefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=InfoStoreDef');
    return;
  end if;
  aBRIEF:=func.InfoStoreDef_BRIEF_F(aInfoStoreDefid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure InfoStoreDef_DELETE /*Описание каталога*/ (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from InfoStoreDef where InfoStoreDefid=aInfoStoreDefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:InfoStoreDef',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=InfoStoreDef');
      return;
    end if;
  end if;
 --  verify lock  --
 InfoStoreDef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInfoStoreDefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=InfoStoreDef');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_InfoStoreDef is select  instanceid ID from instance where OwnerPartName ='InfoStoreDef' and OwnerRowID=aInfoStoreDefid;
row_InfoStoreDef  chld_InfoStoreDef%ROWTYPE;
begin
--open chld_InfoStoreDef;
for row_InfoStoreDef in chld_InfoStoreDef loop
 Kernel.INSTANCE_OWNER (acursession,row_InfoStoreDef.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_InfoStoreDef.id);
end loop;
--close chld_InfoStoreDef;
end ;
  delete from  InfoStoreDef 
  where  InfoStoreDefID = aInfoStoreDefID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure InfoStoreDef_SAVE /*Описание каталога*/ (
 aCURSESSION CHAR,
 aInfoStoreDefid CHAR,
aInstanceID CHAR 
,aTheGroup CHAR := null /* Группа *//* Группа */
,aName
 VARCHAR2/* Название *//* Название */
,aInfoStoreType
 NUMBER/* Тип каталога *//* Тип каталога */
,aTheUser CHAR := null /* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from InfoStoreDef where InfoStoreDefID=aInfoStoreDefID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from InfoStoreDef where InfoStoreDefid=aInfoStoreDefID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:InfoStoreDef',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=InfoStoreDef');
      return;
    end if;
  end if;
 --  verify lock  --
 InfoStoreDef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInfoStoreDefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=InfoStoreDef');
    return;
  end if;
 -- update row  --
 update  InfoStoreDef set ChangeStamp=sysdate
,
  TheGroup=aTheGroup
,
  Name=aName
,
  InfoStoreType=aInfoStoreType
,
  TheUser=aTheUser
  where  InfoStoreDefID = aInfoStoreDefID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:InfoStoreDef',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=InfoStoreDef');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=InfoStoreDef');
    return;
  end if;
select Count(*) into existsCnt from InfoStoreDef where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;InfoStoreDef&gt;');
    return;
 End if;
 insert into   InfoStoreDef
 (  InfoStoreDefID 
,InstanceID
,TheGroup

,Name

,InfoStoreType

,TheUser

 ) values ( aInfoStoreDefID 
,aInstanceID
,aTheGroup

,aName

,aInfoStoreType

,aTheUser

 ); 
 InfoStoreDef_SINIT( aCURSESSION,aInfoStoreDefid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure InfoStoreDef_PARENT /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from InfoStoreDef where  InfoStoreDefid=aRowID;
 end; 

procedure InfoStoreDef_ISLOCKED /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from InfoStoreDef where InfoStoreDefid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  InfoStoreDef_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDInfoStore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure InfoStoreDef_LOCK /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 InfoStoreDef_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  InfoStoreDef_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from InfoStoreDef where InfoStoreDefid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=InfoStoreDef');
    return;
  end if;
   if  aLockMode =2  
   then   
    update InfoStoreDef set LockUserID =auserID ,LockSessionID =null where InfoStoreDefid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update InfoStoreDef set LockUserID =null,LockSessionID =aCURSESSION  where InfoStoreDefid=aRowID;
     return;
   end if;
 end ;

procedure InfoStoreDef_HCL /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure InfoStoreDef_UNLOCK /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 InfoStoreDef_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update InfoStoreDef set LockUserID =null  where InfoStoreDefid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update InfoStoreDef set LockSessionID =null  where InfoStoreDefid=aRowID;
     return;
   end if;
 end; 

procedure InfoStoreDef_SINIT /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from InfoStoreDef where InfoStoreDefid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =InfoStoreDef');
    return;
  end if;
if aSecurityStyleID is null then
 InfoStoreDef_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update InfoStoreDef set securitystyleid =aStyleID where InfoStoreDefid = aRowID;
else 
 update InfoStoreDef set securitystyleid =aSecurityStyleID where InfoStoreDefid = aRowID;
end if; 
end ; 

procedure InfoStoreDef_propagate /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from InfoStoreDef where InfoStoreDefid=aRowid;
end;
end STDInfoStore;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZSystem" BlockCode=" create or replace package body MTZSystem as

procedure MTZSystem_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZSystem'
then
declare cursor child_the_Session is select the_Session.the_Sessionid ID from the_Session where  the_Session.InstanceID = ainstanceid;
row_the_Session  child_the_Session%ROWTYPE;
begin
--open child_the_Session;
for row_the_Session in child_the_Session loop
 the_Session_DELETE (acursession,row_the_Session.id,aInstanceID);
end loop;
--close child_the_Session;
end;
declare cursor child_SysRefCache is select SysRefCache.SysRefCacheid ID from SysRefCache where  SysRefCache.InstanceID = ainstanceid;
row_SysRefCache  child_SysRefCache%ROWTYPE;
begin
--open child_SysRefCache;
for row_SysRefCache in child_SysRefCache loop
 SysRefCache_DELETE (acursession,row_SysRefCache.id,aInstanceID);
end loop;
--close child_SysRefCache;
end;
declare cursor child_SysLog is select SysLog.SysLogid ID from SysLog where  SysLog.InstanceID = ainstanceid;
row_SysLog  child_SysLog%ROWTYPE;
begin
--open child_SysLog;
for row_SysLog in child_SysLog loop
 SysLog_DELETE (acursession,row_SysLog.id,aInstanceID);
end loop;
--close child_SysLog;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZSystem_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZSystem'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_the_Session is select the_Session.the_Sessionid ID from the_Session where  the_Session.InstanceID = arowid;
ROW_the_Session  lch_the_Session%ROWTYPE;
begin
--open lch_the_Session;
for row_the_Session in lch_the_Session loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from the_Session where the_Sessionid=row_the_Session.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_the_Session;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_the_Session;
     return;
   end if; 
 end if; 
 the_Session_HCL (acursession,ROW_the_Session.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_the_Session;
   return;
 end if;
 end loop;
--close lch_the_Session;
end;
declare cursor lch_SysRefCache is select SysRefCache.SysRefCacheid ID from SysRefCache where  SysRefCache.InstanceID = arowid;
ROW_SysRefCache  lch_SysRefCache%ROWTYPE;
begin
--open lch_SysRefCache;
for row_SysRefCache in lch_SysRefCache loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SysRefCache where SysRefCacheid=row_SysRefCache.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_SysRefCache;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_SysRefCache;
     return;
   end if; 
 end if; 
 SysRefCache_HCL (acursession,ROW_SysRefCache.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_SysRefCache;
   return;
 end if;
 end loop;
--close lch_SysRefCache;
end;
declare cursor lch_SysLog is select SysLog.SysLogid ID from SysLog where  SysLog.InstanceID = arowid;
ROW_SysLog  lch_SysLog%ROWTYPE;
begin
--open lch_SysLog;
for row_SysLog in lch_SysLog loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from SysLog where SysLogid=row_SysLog.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_SysLog;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_SysLog;
     return;
   end if; 
 end if; 
 SysLog_HCL (acursession,ROW_SysLog.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_SysLog;
   return;
 end if;
 end loop;
--close lch_SysLog;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZSystem_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZSystem'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_the_Session is select the_Session.the_Sessionid id from the_Session where  the_Session.InstanceID = arowid;
row_the_Session  pch_the_Session%ROWTYPE;
begin
--open pch_the_Session;
for row_the_Session in  pch_the_Session loop
 the_Session_SINIT( acursession,row_the_Session.id,assid);
 the_Session_propagate( acursession,row_the_Session.id);
end loop;
--close pch_the_Session;
end;
declare cursor pch_SysRefCache is select SysRefCache.SysRefCacheid id from SysRefCache where  SysRefCache.InstanceID = arowid;
row_SysRefCache  pch_SysRefCache%ROWTYPE;
begin
--open pch_SysRefCache;
for row_SysRefCache in  pch_SysRefCache loop
 SysRefCache_SINIT( acursession,row_SysRefCache.id,assid);
 SysRefCache_propagate( acursession,row_SysRefCache.id);
end loop;
--close pch_SysRefCache;
end;
declare cursor pch_SysLog is select SysLog.SysLogid id from SysLog where  SysLog.InstanceID = arowid;
row_SysLog  pch_SysLog%ROWTYPE;
begin
--open pch_SysLog;
for row_SysLog in  pch_SysLog loop
 SysLog_SINIT( acursession,row_SysLog.id,assid);
 SysLog_propagate( acursession,row_SysLog.id);
end loop;
--close pch_SysLog;
end;
 end if; 
end;


procedure the_Session_BRIEF  (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if athe_Sessionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from the_Session where the_Sessionid=athe_SessionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=the_Session');
    return;
  end if;
  aBRIEF:=func.the_Session_BRIEF_F(athe_Sessionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure the_Session_DELETE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from the_Session where the_Sessionid=athe_SessionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:the_Session',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=the_Session');
      return;
    end if;
  end if;
 --  verify lock  --
 the_Session_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;athe_Sessionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=the_Session');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_the_Session is select  instanceid ID from instance where OwnerPartName ='the_Session' and OwnerRowID=athe_Sessionid;
row_the_Session  chld_the_Session%ROWTYPE;
begin
--open chld_the_Session;
for row_the_Session in chld_the_Session loop
 Kernel.INSTANCE_OWNER (acursession,row_the_Session.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_the_Session.id);
end loop;
--close chld_the_Session;
end ;
  delete from  the_Session 
  where  the_SessionID = athe_SessionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Сессия пользователя*/
procedure the_Session_SAVE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 athe_Sessionid CHAR,
aInstanceID CHAR 
,aApplicationID CHAR := null /* Приложение *//* Приложение */
,aUserRole CHAR/* Текущая роль пользователя *//* Текущая роль пользователя */
,aClosedAt
 DATE := null /* Момент закрытия *//* Момент закрытия */
,aClosed
 NUMBER/* Закрыта *//* Закрыта */
,aUsersid CHAR/* Пользователь *//* Пользователь */
,aLastAccess
 DATE := null /* Последнее подтверждение *//* Последнее подтверждение */
,aStartAt
 DATE/* Момент открытия *//* Момент открытия */
,aLang
 VARCHAR2 := null /* Локализация *//* Локализация */
,aLogin
 VARCHAR2 := null /* Login *//* Login */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from the_Session where the_SessionID=athe_SessionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from the_Session where the_Sessionid=athe_SessionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:the_Session',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=the_Session');
      return;
    end if;
  end if;
 --  verify lock  --
 the_Session_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;athe_Sessionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_Session');
    return;
  end if;
 -- update row  --
 update  the_Session set ChangeStamp=sysdate
,
  ApplicationID=aApplicationID
,
  UserRole=aUserRole
,
  ClosedAt=aClosedAt
,
  Closed=aClosed
,
  Usersid=aUsersid
,
  LastAccess=aLastAccess
,
  StartAt=aStartAt
,
  Lang=aLang
,
  Login=aLogin
  where  the_SessionID = athe_SessionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:the_Session',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=the_Session');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_Session');
    return;
  end if;
 insert into   the_Session
 (  the_SessionID 
,InstanceID
,ApplicationID

,UserRole

,ClosedAt

,Closed

,Usersid

,LastAccess

,StartAt

,Lang

,Login

 ) values ( athe_SessionID 
,aInstanceID
,aApplicationID

,aUserRole

,aClosedAt

,aClosed

,aUsersid

,aLastAccess

,aStartAt

,aLang

,aLogin

 ); 
 the_Session_SINIT( aCURSESSION,athe_Sessionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure the_Session_PARENT /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from the_Session where  the_Sessionid=aRowID;
 end; 

procedure the_Session_ISLOCKED /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from the_Session where the_Sessionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  the_Session_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZSystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure the_Session_LOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 the_Session_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  the_Session_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from the_Session where the_Sessionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=the_Session');
    return;
  end if;
   if  aLockMode =2  
   then   
    update the_Session set LockUserID =auserID ,LockSessionID =null where the_Sessionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update the_Session set LockUserID =null,LockSessionID =aCURSESSION  where the_Sessionid=aRowID;
     return;
   end if;
 end ;

procedure the_Session_HCL /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure the_Session_UNLOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 the_Session_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update the_Session set LockUserID =null  where the_Sessionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update the_Session set LockSessionID =null  where the_Sessionid=aRowID;
     return;
   end if;
 end; 

procedure the_Session_SINIT /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from the_Session where the_Sessionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =the_Session');
    return;
  end if;
if aSecurityStyleID is null then
 the_Session_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update the_Session set securitystyleid =aStyleID where the_Sessionid = aRowID;
else 
 update the_Session set securitystyleid =aSecurityStyleID where the_Sessionid = aRowID;
end if; 
end ; 

procedure the_Session_propagate /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from the_Session where the_Sessionid=aRowid;
end;


procedure SysRefCache_BRIEF  (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aSysRefCacheid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from SysRefCache where SysRefCacheID=aSysRefCacheID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from SysRefCache where SysRefCacheid=aSysRefCacheID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=SysRefCache');
    return;
  end if;
  aBRIEF:=func.SysRefCache_BRIEF_F(aSysRefCacheid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure SysRefCache_DELETE /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SysRefCache where SysRefCacheID=aSysRefCacheID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from SysRefCache where SysRefCacheid=aSysRefCacheID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:SysRefCache',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=SysRefCache');
      return;
    end if;
  end if;
 --  verify lock  --
 SysRefCache_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSysRefCacheid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SysRefCache');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_SysRefCache is select  instanceid ID from instance where OwnerPartName ='SysRefCache' and OwnerRowID=aSysRefCacheid;
row_SysRefCache  chld_SysRefCache%ROWTYPE;
begin
--open chld_SysRefCache;
for row_SysRefCache in chld_SysRefCache loop
 Kernel.INSTANCE_OWNER (acursession,row_SysRefCache.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_SysRefCache.id);
end loop;
--close chld_SysRefCache;
end ;
  delete from  SysRefCache 
  where  SysRefCacheID = aSysRefCacheID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные владельцы*/
procedure SysRefCache_SAVE /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aSysRefCacheid CHAR,
aInstanceID CHAR 
,aCacheType
 NUMBER/* Тип кеширования *//* Тип кеширования */
,aObjectOwnerID CHAR/* Идентификатор владельца *//* Идентификатор владельца */
,aSessionID CHAR/* Сессия *//* Сессия */
,amodulename
 VARCHAR2 := null /* модуль *//* модуль */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SysRefCache where SysRefCacheID=aSysRefCacheID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from SysRefCache where SysRefCacheid=aSysRefCacheID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:SysRefCache',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=SysRefCache');
      return;
    end if;
  end if;
 --  verify lock  --
 SysRefCache_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSysRefCacheid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysRefCache');
    return;
  end if;
 -- update row  --
 update  SysRefCache set ChangeStamp=sysdate
,
  CacheType=aCacheType
,
  ObjectOwnerID=aObjectOwnerID
,
  SessionID=aSessionID
,
  modulename=amodulename
  where  SysRefCacheID = aSysRefCacheID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:SysRefCache',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=SysRefCache');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysRefCache');
    return;
  end if;
 insert into   SysRefCache
 (  SysRefCacheID 
,InstanceID
,CacheType

,ObjectOwnerID

,SessionID

,modulename

 ) values ( aSysRefCacheID 
,aInstanceID
,aCacheType

,aObjectOwnerID

,aSessionID

,amodulename

 ); 
 SysRefCache_SINIT( aCURSESSION,aSysRefCacheid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure SysRefCache_PARENT /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from SysRefCache where  SysRefCacheid=aRowID;
 end; 

procedure SysRefCache_ISLOCKED /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SysRefCache where SysRefCacheid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  SysRefCache_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZSystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure SysRefCache_LOCK /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 SysRefCache_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  SysRefCache_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from SysRefCache where SysRefCacheid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=SysRefCache');
    return;
  end if;
   if  aLockMode =2  
   then   
    update SysRefCache set LockUserID =auserID ,LockSessionID =null where SysRefCacheid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SysRefCache set LockUserID =null,LockSessionID =aCURSESSION  where SysRefCacheid=aRowID;
     return;
   end if;
 end ;

procedure SysRefCache_HCL /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure SysRefCache_UNLOCK /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 SysRefCache_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SysRefCache set LockUserID =null  where SysRefCacheid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SysRefCache set LockSessionID =null  where SysRefCacheid=aRowID;
     return;
   end if;
 end; 

procedure SysRefCache_SINIT /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from SysRefCache where SysRefCacheid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =SysRefCache');
    return;
  end if;
if aSecurityStyleID is null then
 SysRefCache_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update SysRefCache set securitystyleid =aStyleID where SysRefCacheid = aRowID;
else 
 update SysRefCache set securitystyleid =aSecurityStyleID where SysRefCacheid = aRowID;
end if; 
end ; 

procedure SysRefCache_propagate /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from SysRefCache where SysRefCacheid=aRowid;
end;


procedure SysLog_BRIEF  (
 aCURSESSION CHAR,
 aSysLogid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aSysLogid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from SysLog where SysLogid=aSysLogID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=SysLog');
    return;
  end if;
  aBRIEF:=func.SysLog_BRIEF_F(aSysLogid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure SysLog_DELETE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aSysLogid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from SysLog where SysLogid=aSysLogID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:SysLog',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=SysLog');
      return;
    end if;
  end if;
 --  verify lock  --
 SysLog_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSysLogid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=SysLog');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_SysLog is select  instanceid ID from instance where OwnerPartName ='SysLog' and OwnerRowID=aSysLogid;
row_SysLog  chld_SysLog%ROWTYPE;
begin
--open chld_SysLog;
for row_SysLog in chld_SysLog loop
 Kernel.INSTANCE_OWNER (acursession,row_SysLog.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_SysLog.id);
end loop;
--close chld_SysLog;
end ;
  delete from  SysLog 
  where  SysLogID = aSysLogID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Журнал событий*/
procedure SysLog_SAVE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aSysLogid CHAR,
aInstanceID CHAR 
,aTheSession CHAR/* Сессия *//* Сессия */
,athe_Resource
 VARCHAR2/* Ресурс *//* Ресурс */
,aLogStructID
 VARCHAR2/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,aVERB
 VARCHAR2/* Действие *//* Действие */
,aLogInstanceID CHAR := null /* Идентификатор документа *//* Идентификатор документа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from SysLog where SysLogID=aSysLogID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from SysLog where SysLogid=aSysLogID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:SysLog',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=SysLog');
      return;
    end if;
  end if;
 --  verify lock  --
 SysLog_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aSysLogid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysLog');
    return;
  end if;
 -- update row  --
 update  SysLog set ChangeStamp=sysdate
,
  TheSession=aTheSession
,
  the_Resource=athe_Resource
,
  LogStructID=aLogStructID
,
  VERB=aVERB
,
  LogInstanceID=aLogInstanceID
  where  SysLogID = aSysLogID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:SysLog',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=SysLog');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=SysLog');
    return;
  end if;
 insert into   SysLog
 (  SysLogID 
,InstanceID
,TheSession

,the_Resource

,LogStructID

,VERB

,LogInstanceID

 ) values ( aSysLogID 
,aInstanceID
,aTheSession

,athe_Resource

,aLogStructID

,aVERB

,aLogInstanceID

 ); 
 SysLog_SINIT( aCURSESSION,aSysLogid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure SysLog_PARENT /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from SysLog where  SysLogid=aRowID;
 end; 

procedure SysLog_ISLOCKED /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from SysLog where SysLogid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  SysLog_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZSystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure SysLog_LOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 SysLog_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  SysLog_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from SysLog where SysLogid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=SysLog');
    return;
  end if;
   if  aLockMode =2  
   then   
    update SysLog set LockUserID =auserID ,LockSessionID =null where SysLogid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update SysLog set LockUserID =null,LockSessionID =aCURSESSION  where SysLogid=aRowID;
     return;
   end if;
 end ;

procedure SysLog_HCL /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure SysLog_UNLOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 SysLog_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update SysLog set LockUserID =null  where SysLogid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update SysLog set LockSessionID =null  where SysLogid=aRowID;
     return;
   end if;
 end; 

procedure SysLog_SINIT /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from SysLog where SysLogid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =SysLog');
    return;
  end if;
if aSecurityStyleID is null then
 SysLog_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update SysLog set securitystyleid =aStyleID where SysLogid = aRowID;
else 
 update SysLog set securitystyleid =aSecurityStyleID where SysLogid = aRowID;
end if; 
end ; 

procedure SysLog_propagate /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from SysLog where SysLogid=aRowid;
end;
end MTZSystem;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZwp" BlockCode=" create or replace package body MTZwp as

procedure MTZwp_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZwp'
then
declare cursor child_ARMJournal is select ARMJournal.ARMJournalid ID from ARMJournal where  ARMJournal.InstanceID = ainstanceid;
row_ARMJournal  child_ARMJournal%ROWTYPE;
begin
--open child_ARMJournal;
for row_ARMJournal in child_ARMJournal loop
 ARMJournal_DELETE (acursession,row_ARMJournal.id,aInstanceID);
end loop;
--close child_ARMJournal;
end;
declare cursor child_EntryPoints is select EntryPoints.EntryPointsid ID from EntryPoints where  EntryPoints.InstanceID = ainstanceid;
row_EntryPoints  child_EntryPoints%ROWTYPE;
begin
--open child_EntryPoints;
for row_EntryPoints in child_EntryPoints loop
 EntryPoints_DELETE (acursession,row_EntryPoints.id,aInstanceID);
end loop;
--close child_EntryPoints;
end;
declare cursor child_WorkPlace is select WorkPlace.WorkPlaceid ID from WorkPlace where  WorkPlace.InstanceID = ainstanceid;
row_WorkPlace  child_WorkPlace%ROWTYPE;
begin
--open child_WorkPlace;
for row_WorkPlace in child_WorkPlace loop
 WorkPlace_DELETE (acursession,row_WorkPlace.id,aInstanceID);
end loop;
--close child_WorkPlace;
end;
declare cursor child_ARMTypes is select ARMTypes.ARMTypesid ID from ARMTypes where  ARMTypes.InstanceID = ainstanceid;
row_ARMTypes  child_ARMTypes%ROWTYPE;
begin
--open child_ARMTypes;
for row_ARMTypes in child_ARMTypes loop
 ARMTypes_DELETE (acursession,row_ARMTypes.id,aInstanceID);
end loop;
--close child_ARMTypes;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZwp_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZwp'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_ARMJournal is select ARMJournal.ARMJournalid ID from ARMJournal where  ARMJournal.InstanceID = arowid;
ROW_ARMJournal  lch_ARMJournal%ROWTYPE;
begin
--open lch_ARMJournal;
for row_ARMJournal in lch_ARMJournal loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ARMJournal where ARMJournalid=row_ARMJournal.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ARMJournal;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ARMJournal;
     return;
   end if; 
 end if; 
 ARMJournal_HCL (acursession,ROW_ARMJournal.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ARMJournal;
   return;
 end if;
 end loop;
--close lch_ARMJournal;
end;
declare cursor lch_EntryPoints is select EntryPoints.EntryPointsid ID from EntryPoints where  EntryPoints.InstanceID = arowid;
ROW_EntryPoints  lch_EntryPoints%ROWTYPE;
begin
--open lch_EntryPoints;
for row_EntryPoints in lch_EntryPoints loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from EntryPoints where EntryPointsid=row_EntryPoints.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_EntryPoints;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_EntryPoints;
     return;
   end if; 
 end if; 
 EntryPoints_HCL (acursession,ROW_EntryPoints.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_EntryPoints;
   return;
 end if;
 end loop;
--close lch_EntryPoints;
end;
declare cursor lch_WorkPlace is select WorkPlace.WorkPlaceid ID from WorkPlace where  WorkPlace.InstanceID = arowid;
ROW_WorkPlace  lch_WorkPlace%ROWTYPE;
begin
--open lch_WorkPlace;
for row_WorkPlace in lch_WorkPlace loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from WorkPlace where WorkPlaceid=row_WorkPlace.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_WorkPlace;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_WorkPlace;
     return;
   end if; 
 end if; 
 WorkPlace_HCL (acursession,ROW_WorkPlace.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_WorkPlace;
   return;
 end if;
 end loop;
--close lch_WorkPlace;
end;
declare cursor lch_ARMTypes is select ARMTypes.ARMTypesid ID from ARMTypes where  ARMTypes.InstanceID = arowid;
ROW_ARMTypes  lch_ARMTypes%ROWTYPE;
begin
--open lch_ARMTypes;
for row_ARMTypes in lch_ARMTypes loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ARMTypes where ARMTypesid=row_ARMTypes.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ARMTypes;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ARMTypes;
     return;
   end if; 
 end if; 
 ARMTypes_HCL (acursession,ROW_ARMTypes.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ARMTypes;
   return;
 end if;
 end loop;
--close lch_ARMTypes;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZwp_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZwp'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_ARMJournal is select ARMJournal.ARMJournalid id from ARMJournal where  ARMJournal.InstanceID = arowid;
row_ARMJournal  pch_ARMJournal%ROWTYPE;
begin
--open pch_ARMJournal;
for row_ARMJournal in  pch_ARMJournal loop
 ARMJournal_SINIT( acursession,row_ARMJournal.id,assid);
 ARMJournal_propagate( acursession,row_ARMJournal.id);
end loop;
--close pch_ARMJournal;
end;
declare cursor pch_EntryPoints is select EntryPoints.EntryPointsid id from EntryPoints where  EntryPoints.InstanceID = arowid;
row_EntryPoints  pch_EntryPoints%ROWTYPE;
begin
--open pch_EntryPoints;
for row_EntryPoints in  pch_EntryPoints loop
 EntryPoints_SINIT( acursession,row_EntryPoints.id,assid);
 EntryPoints_propagate( acursession,row_EntryPoints.id);
end loop;
--close pch_EntryPoints;
end;
declare cursor pch_WorkPlace is select WorkPlace.WorkPlaceid id from WorkPlace where  WorkPlace.InstanceID = arowid;
row_WorkPlace  pch_WorkPlace%ROWTYPE;
begin
--open pch_WorkPlace;
for row_WorkPlace in  pch_WorkPlace loop
 WorkPlace_SINIT( acursession,row_WorkPlace.id,assid);
 WorkPlace_propagate( acursession,row_WorkPlace.id);
end loop;
--close pch_WorkPlace;
end;
declare cursor pch_ARMTypes is select ARMTypes.ARMTypesid id from ARMTypes where  ARMTypes.InstanceID = arowid;
row_ARMTypes  pch_ARMTypes%ROWTYPE;
begin
--open pch_ARMTypes;
for row_ARMTypes in  pch_ARMTypes loop
 ARMTypes_SINIT( acursession,row_ARMTypes.id,assid);
 ARMTypes_propagate( acursession,row_ARMTypes.id);
end loop;
--close pch_ARMTypes;
end;
 end if; 
end;


procedure ARMJournal_BRIEF  (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aARMJournalid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ARMJournal where ARMJournalid=aARMJournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ARMJournal');
    return;
  end if;
  aBRIEF:=func.ARMJournal_BRIEF_F(aARMJournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ARMJournal_DELETE /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aARMJournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ARMJournal',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ARMJournal');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJournal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJournal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ARMJRNLREP is select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aARMJournalid;
    child_ARMJRNLREP_rec  child_ARMJRNLREP%ROWTYPE;
    begin
    --open child_ARMJRNLREP;
      for child_ARMJRNLREP_rec in child_ARMJRNLREP loop
      ARMJRNLREP_DELETE (acursession,child_ARMJRNLREP_rec.id,aInstanceid);
      end loop;
      --close child_ARMJRNLREP;
    end ;
    declare cursor child_ARMJRNLRUN is select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aARMJournalid;
    child_ARMJRNLRUN_rec  child_ARMJRNLRUN%ROWTYPE;
    begin
    --open child_ARMJRNLRUN;
      for child_ARMJRNLRUN_rec in child_ARMJRNLRUN loop
      ARMJRNLRUN_DELETE (acursession,child_ARMJRNLRUN_rec.id,aInstanceid);
      end loop;
      --close child_ARMJRNLRUN;
    end ;
    declare cursor child_ARMJRNLADD is select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aARMJournalid;
    child_ARMJRNLADD_rec  child_ARMJRNLADD%ROWTYPE;
    begin
    --open child_ARMJRNLADD;
      for child_ARMJRNLADD_rec in child_ARMJRNLADD loop
      ARMJRNLADD_DELETE (acursession,child_ARMJRNLADD_rec.id,aInstanceid);
      end loop;
      --close child_ARMJRNLADD;
    end ;
declare cursor chld_ARMJournal is select  instanceid ID from instance where OwnerPartName ='ARMJournal' and OwnerRowID=aARMJournalid;
row_ARMJournal  chld_ARMJournal%ROWTYPE;
begin
--open chld_ARMJournal;
for row_ARMJournal in chld_ARMJournal loop
 Kernel.INSTANCE_OWNER (acursession,row_ARMJournal.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ARMJournal.id);
end loop;
--close chld_ARMJournal;
end ;
  delete from  ARMJournal 
  where  ARMJournalID = aARMJournalID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поведение журналов*/
procedure ARMJournal_SAVE /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aARMJournalid CHAR,
aInstanceID CHAR 
,aTheJournal CHAR/* Журнал *//* Журнал */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJournal where ARMJournalID=aARMJournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aARMJournalID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ARMJournal',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ARMJournal');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJournal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJournal');
    return;
  end if;
 -- update row  --
 update  ARMJournal set ChangeStamp=sysdate
,
  TheJournal=aTheJournal
  where  ARMJournalID = aARMJournalID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ARMJournal',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ARMJournal');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJournal');
    return;
  end if;
 insert into   ARMJournal
 (  ARMJournalID 
,InstanceID
,TheJournal

 ) values ( aARMJournalID 
,aInstanceID
,aTheJournal

 ); 
 ARMJournal_SINIT( aCURSESSION,aARMJournalid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ARMJournal_PARENT /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ARMJournal where  ARMJournalid=aRowID;
 end; 

procedure ARMJournal_ISLOCKED /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJournal where ARMJournalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ARMJournal_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ARMJournal_LOCK /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ARMJournal_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ARMJournal_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ARMJournal');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ARMJournal set LockUserID =auserID ,LockSessionID =null where ARMJournalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJournal set LockUserID =null,LockSessionID =aCURSESSION  where ARMJournalid=aRowID;
     return;
   end if;
 end ;

procedure ARMJournal_HCL /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ARMJRNLREP is select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aRowid;
row_ARMJRNLREP lch_ARMJRNLREP%ROWTYPE;
begin  
--open lch_ARMJRNLREP;
for row_ARMJRNLREP in lch_ARMJRNLREP
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLREP where ARMJRNLREPid=row_ARMJRNLREP.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ARMJRNLREP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ARMJRNLREP;
     return;
   end if; 
 end if;  
 ARMJRNLREP_HCL (acursession,row_ARMJRNLREP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ARMJRNLREP;
   return;
 end if;
end loop;
--close lch_ARMJRNLREP;
end;
declare cursor lch_ARMJRNLRUN is select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aRowid;
row_ARMJRNLRUN lch_ARMJRNLRUN%ROWTYPE;
begin  
--open lch_ARMJRNLRUN;
for row_ARMJRNLRUN in lch_ARMJRNLRUN
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLRUN where ARMJRNLRUNid=row_ARMJRNLRUN.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ARMJRNLRUN;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ARMJRNLRUN;
     return;
   end if; 
 end if;  
 ARMJRNLRUN_HCL (acursession,row_ARMJRNLRUN.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ARMJRNLRUN;
   return;
 end if;
end loop;
--close lch_ARMJRNLRUN;
end;
declare cursor lch_ARMJRNLADD is select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aRowid;
row_ARMJRNLADD lch_ARMJRNLADD%ROWTYPE;
begin  
--open lch_ARMJRNLADD;
for row_ARMJRNLADD in lch_ARMJRNLADD
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ARMJRNLADD where ARMJRNLADDid=row_ARMJRNLADD.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ARMJRNLADD;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ARMJRNLADD;
     return;
   end if; 
 end if;  
 ARMJRNLADD_HCL (acursession,row_ARMJRNLADD.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ARMJRNLADD;
   return;
 end if;
end loop;
--close lch_ARMJRNLADD;
end;
aIsLocked :=0;
end;

procedure ARMJournal_UNLOCK /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ARMJournal_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJournal set LockUserID =null  where ARMJournalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJournal set LockSessionID =null  where ARMJournalid=aRowID;
     return;
   end if;
 end; 

procedure ARMJournal_SINIT /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ARMJournal');
    return;
  end if;
if aSecurityStyleID is null then
 ARMJournal_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ARMJournal set securitystyleid =aStyleID where ARMJournalid = aRowID;
else 
 update ARMJournal set securitystyleid =aSecurityStyleID where ARMJournalid = aRowID;
end if; 
end ; 

procedure ARMJournal_propagate /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ARMJournal where ARMJournalid=aRowid;
declare cursor pch_ARMJRNLREP  is select ARMJRNLREP.ARMJRNLREPid ID from ARMJRNLREP where  ARMJRNLREP.ParentStructRowID = aRowid;
row_ARMJRNLREP  pch_ARMJRNLREP%ROWTYPE;
begin
--open pch_ARMJRNLREP;
for row_ARMJRNLREP in pch_ARMJRNLREP loop
   ARMJRNLREP_SINIT( acursession,row_ARMJRNLREP.id,assid);
   ARMJRNLREP_propagate( acursession,row_ARMJRNLREP.id);
end loop;
--close pch_ARMJRNLREP;
end;
declare cursor pch_ARMJRNLRUN  is select ARMJRNLRUN.ARMJRNLRUNid ID from ARMJRNLRUN where  ARMJRNLRUN.ParentStructRowID = aRowid;
row_ARMJRNLRUN  pch_ARMJRNLRUN%ROWTYPE;
begin
--open pch_ARMJRNLRUN;
for row_ARMJRNLRUN in pch_ARMJRNLRUN loop
   ARMJRNLRUN_SINIT( acursession,row_ARMJRNLRUN.id,assid);
   ARMJRNLRUN_propagate( acursession,row_ARMJRNLRUN.id);
end loop;
--close pch_ARMJRNLRUN;
end;
declare cursor pch_ARMJRNLADD  is select ARMJRNLADD.ARMJRNLADDid ID from ARMJRNLADD where  ARMJRNLADD.ParentStructRowID = aRowid;
row_ARMJRNLADD  pch_ARMJRNLADD%ROWTYPE;
begin
--open pch_ARMJRNLADD;
for row_ARMJRNLADD in pch_ARMJRNLADD loop
   ARMJRNLADD_SINIT( acursession,row_ARMJRNLADD.id,assid);
   ARMJRNLADD_propagate( acursession,row_ARMJRNLADD.id);
end loop;
--close pch_ARMJRNLADD;
end;
end;


procedure ARMJRNLREP_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aARMJRNLREPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ARMJRNLREP where ARMJRNLREPid=aARMJRNLREPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ARMJRNLREP');
    return;
  end if;
  aBRIEF:=func.ARMJRNLREP_BRIEF_F(aARMJRNLREPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ARMJRNLREP_DELETE /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ARMJRNLREP where ARMJRNLREPid=aARMJRNLREPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ARMJRNLREP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ARMJRNLREP');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLREP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLREPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLREP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ARMJRNLREP is select  instanceid ID from instance where OwnerPartName ='ARMJRNLREP' and OwnerRowID=aARMJRNLREPid;
row_ARMJRNLREP  chld_ARMJRNLREP%ROWTYPE;
begin
--open chld_ARMJRNLREP;
for row_ARMJRNLREP in chld_ARMJRNLREP loop
 Kernel.INSTANCE_OWNER (acursession,row_ARMJRNLREP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ARMJRNLREP.id);
end loop;
--close chld_ARMJRNLREP;
end ;
  delete from  ARMJRNLREP 
  where  ARMJRNLREPID = aARMJRNLREPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отчеты*/
procedure ARMJRNLREP_SAVE /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aARMJRNLREPid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arepname
 VARCHAR2/* Название отчета *//* Название отчета */
,aTheReport CHAR/* Отчет *//* Отчет */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLREP where ARMJRNLREPID=aARMJRNLREPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ARMJRNLREP where ARMJRNLREPid=aARMJRNLREPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ARMJRNLREP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ARMJRNLREP');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLREP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLREPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLREP');
    return;
  end if;
 -- update row  --
 update  ARMJRNLREP set ChangeStamp=sysdate
,
  repname=arepname
,
  TheReport=aTheReport
  where  ARMJRNLREPID = aARMJRNLREPID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ARMJRNLREP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ARMJRNLREP');
      return;
    end if;
 end if;
 ARMJournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLREP');
    return;
  end if;
 insert into   ARMJRNLREP
 (  ARMJRNLREPID 
,ParentStructRowID
,repname

,TheReport

 ) values ( aARMJRNLREPID 
,aParentStructRowID
,arepname

,aTheReport

 ); 
 ARMJRNLREP_SINIT( aCURSESSION,aARMJRNLREPid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ARMJRNLREP_PARENT /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLREP where  ARMJRNLREPid=aRowID;
  aParentTable := 'ARMJournal';
 end; 

procedure ARMJRNLREP_ISLOCKED /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLREP where ARMJRNLREPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ARMJRNLREP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ARMJRNLREP_LOCK /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ARMJRNLREP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ARMJRNLREP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ARMJRNLREP where ARMJRNLREPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ARMJRNLREP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ARMJRNLREP set LockUserID =auserID ,LockSessionID =null where ARMJRNLREPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLREP set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLREPid=aRowID;
     return;
   end if;
 end ;

procedure ARMJRNLREP_HCL /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ARMJRNLREP_UNLOCK /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ARMJRNLREP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLREP set LockUserID =null  where ARMJRNLREPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLREP set LockSessionID =null  where ARMJRNLREPid=aRowID;
     return;
   end if;
 end; 

procedure ARMJRNLREP_SINIT /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ARMJRNLREP where ARMJRNLREPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ARMJRNLREP');
    return;
  end if;
if aSecurityStyleID is null then
 ARMJRNLREP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ARMJRNLREP set securitystyleid =aStyleID where ARMJRNLREPid = aRowID;
else 
 update ARMJRNLREP set securitystyleid =aSecurityStyleID where ARMJRNLREPid = aRowID;
end if; 
end ; 

procedure ARMJRNLREP_propagate /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ARMJRNLREP where ARMJRNLREPid=aRowid;
end;


procedure ARMJRNLRUN_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aARMJRNLRUNid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ARMJRNLRUN where ARMJRNLRUNid=aARMJRNLRUNID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ARMJRNLRUN');
    return;
  end if;
  aBRIEF:=func.ARMJRNLRUN_BRIEF_F(aARMJRNLRUNid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ARMJRNLRUN_DELETE /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ARMJRNLRUN where ARMJRNLRUNid=aARMJRNLRUNID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ARMJRNLRUN',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ARMJRNLRUN');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLRUN_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLRUNid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLRUN');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ARMJRNLRUN is select  instanceid ID from instance where OwnerPartName ='ARMJRNLRUN' and OwnerRowID=aARMJRNLRUNid;
row_ARMJRNLRUN  chld_ARMJRNLRUN%ROWTYPE;
begin
--open chld_ARMJRNLRUN;
for row_ARMJRNLRUN in chld_ARMJRNLRUN loop
 Kernel.INSTANCE_OWNER (acursession,row_ARMJRNLRUN.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ARMJRNLRUN.id);
end loop;
--close chld_ARMJRNLRUN;
end ;
  delete from  ARMJRNLRUN 
  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Действия*/
procedure ARMJRNLRUN_SAVE /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aARMJRNLRUNid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheExtention CHAR/* Расширение *//* Расширение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLRUN where ARMJRNLRUNID=aARMJRNLRUNID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ARMJRNLRUN where ARMJRNLRUNid=aARMJRNLRUNID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ARMJRNLRUN',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ARMJRNLRUN');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLRUN_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLRUNid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLRUN');
    return;
  end if;
 -- update row  --
 update  ARMJRNLRUN set ChangeStamp=sysdate
,
  Name=aName
,
  TheExtention=aTheExtention
  where  ARMJRNLRUNID = aARMJRNLRUNID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ARMJRNLRUN',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ARMJRNLRUN');
      return;
    end if;
 end if;
 ARMJournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLRUN');
    return;
  end if;
 insert into   ARMJRNLRUN
 (  ARMJRNLRUNID 
,ParentStructRowID
,Name

,TheExtention

 ) values ( aARMJRNLRUNID 
,aParentStructRowID
,aName

,aTheExtention

 ); 
 ARMJRNLRUN_SINIT( aCURSESSION,aARMJRNLRUNid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ARMJRNLRUN_PARENT /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLRUN where  ARMJRNLRUNid=aRowID;
  aParentTable := 'ARMJournal';
 end; 

procedure ARMJRNLRUN_ISLOCKED /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLRUN where ARMJRNLRUNid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ARMJRNLRUN_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ARMJRNLRUN_LOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ARMJRNLRUN_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ARMJRNLRUN_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ARMJRNLRUN where ARMJRNLRUNid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ARMJRNLRUN');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ARMJRNLRUN set LockUserID =auserID ,LockSessionID =null where ARMJRNLRUNid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLRUN set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLRUNid=aRowID;
     return;
   end if;
 end ;

procedure ARMJRNLRUN_HCL /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ARMJRNLRUN_UNLOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ARMJRNLRUN_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLRUN set LockUserID =null  where ARMJRNLRUNid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLRUN set LockSessionID =null  where ARMJRNLRUNid=aRowID;
     return;
   end if;
 end; 

procedure ARMJRNLRUN_SINIT /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ARMJRNLRUN where ARMJRNLRUNid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ARMJRNLRUN');
    return;
  end if;
if aSecurityStyleID is null then
 ARMJRNLRUN_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ARMJRNLRUN set securitystyleid =aStyleID where ARMJRNLRUNid = aRowID;
else 
 update ARMJRNLRUN set securitystyleid =aSecurityStyleID where ARMJRNLRUNid = aRowID;
end if; 
end ; 

procedure ARMJRNLRUN_propagate /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ARMJRNLRUN where ARMJRNLRUNid=aRowid;
end;


procedure ARMJRNLADD_BRIEF  (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aARMJRNLADDid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ARMJRNLADD where ARMJRNLADDid=aARMJRNLADDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ARMJRNLADD');
    return;
  end if;
  aBRIEF:=func.ARMJRNLADD_BRIEF_F(aARMJRNLADDid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ARMJRNLADD_DELETE /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ARMJRNLADD where ARMJRNLADDid=aARMJRNLADDID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ARMJRNLADD',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ARMJRNLADD');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLADD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLADDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMJRNLADD');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ARMJRNLADD is select  instanceid ID from instance where OwnerPartName ='ARMJRNLADD' and OwnerRowID=aARMJRNLADDid;
row_ARMJRNLADD  chld_ARMJRNLADD%ROWTYPE;
begin
--open chld_ARMJRNLADD;
for row_ARMJRNLADD in chld_ARMJRNLADD loop
 Kernel.INSTANCE_OWNER (acursession,row_ARMJRNLADD.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ARMJRNLADD.id);
end loop;
--close chld_ARMJRNLADD;
end ;
  delete from  ARMJRNLADD 
  where  ARMJRNLADDID = aARMJRNLADDID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Добавление*/
procedure ARMJRNLADD_SAVE /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aARMJRNLADDid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheExtention CHAR/* Расширение *//* Расширение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMJRNLADD where ARMJRNLADDID=aARMJRNLADDID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ARMJRNLADD where ARMJRNLADDid=aARMJRNLADDID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ARMJRNLADD',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ARMJRNLADD');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMJRNLADD_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMJRNLADDid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLADD');
    return;
  end if;
 -- update row  --
 update  ARMJRNLADD set ChangeStamp=sysdate
,
  Name=aName
,
  TheExtention=aTheExtention
  where  ARMJRNLADDID = aARMJRNLADDID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ARMJournal where ARMJournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ARMJRNLADD',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ARMJRNLADD');
      return;
    end if;
 end if;
 ARMJournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMJRNLADD');
    return;
  end if;
 insert into   ARMJRNLADD
 (  ARMJRNLADDID 
,ParentStructRowID
,Name

,TheExtention

 ) values ( aARMJRNLADDID 
,aParentStructRowID
,aName

,aTheExtention

 ); 
 ARMJRNLADD_SINIT( aCURSESSION,aARMJRNLADDid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ARMJRNLADD_PARENT /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ARMJRNLADD where  ARMJRNLADDid=aRowID;
  aParentTable := 'ARMJournal';
 end; 

procedure ARMJRNLADD_ISLOCKED /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMJRNLADD where ARMJRNLADDid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ARMJRNLADD_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ARMJRNLADD_LOCK /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ARMJRNLADD_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ARMJRNLADD_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ARMJRNLADD where ARMJRNLADDid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ARMJRNLADD');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ARMJRNLADD set LockUserID =auserID ,LockSessionID =null where ARMJRNLADDid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMJRNLADD set LockUserID =null,LockSessionID =aCURSESSION  where ARMJRNLADDid=aRowID;
     return;
   end if;
 end ;

procedure ARMJRNLADD_HCL /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ARMJRNLADD_UNLOCK /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ARMJRNLADD_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMJRNLADD set LockUserID =null  where ARMJRNLADDid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMJRNLADD set LockSessionID =null  where ARMJRNLADDid=aRowID;
     return;
   end if;
 end; 

procedure ARMJRNLADD_SINIT /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ARMJRNLADD where ARMJRNLADDid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ARMJRNLADD');
    return;
  end if;
if aSecurityStyleID is null then
 ARMJRNLADD_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ARMJRNLADD set securitystyleid =aStyleID where ARMJRNLADDid = aRowID;
else 
 update ARMJRNLADD set securitystyleid =aSecurityStyleID where ARMJRNLADDid = aRowID;
end if; 
end ; 

procedure ARMJRNLADD_propagate /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ARMJRNLADD where ARMJRNLADDid=aRowid;
end;


procedure EntryPoints_BRIEF  (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aEntryPointsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from EntryPoints where EntryPointsid=aEntryPointsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=EntryPoints');
    return;
  end if;
  aBRIEF:=func.EntryPoints_BRIEF_F(aEntryPointsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure EntryPoints_DELETE /*Меню*/ (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from EntryPoints where EntryPointsid=aEntryPointsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:EntryPoints',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=EntryPoints');
      return;
    end if;
  end if;
 --  verify lock  --
 EntryPoints_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aEntryPointsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=EntryPoints');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_EPFilterLink is select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aEntryPointsid;
    child_EPFilterLink_rec  child_EPFilterLink%ROWTYPE;
    begin
    --open child_EPFilterLink;
      for child_EPFilterLink_rec in child_EPFilterLink loop
      EPFilterLink_DELETE (acursession,child_EPFilterLink_rec.id,aInstanceid);
      end loop;
      --close child_EPFilterLink;
    end ;
declare cursor chld_EntryPoints is select  instanceid ID from instance where OwnerPartName ='EntryPoints' and OwnerRowID=aEntryPointsid;
row_EntryPoints  chld_EntryPoints%ROWTYPE;
begin
--open chld_EntryPoints;
for row_EntryPoints in chld_EntryPoints loop
 Kernel.INSTANCE_OWNER (acursession,row_EntryPoints.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_EntryPoints.id);
end loop;
--close chld_EntryPoints;
end ;
  delete from  EntryPoints 
  where  EntryPointsID = aEntryPointsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Меню*/
procedure EntryPoints_SAVE /*Меню*/ (
 aCURSESSION CHAR,
 aEntryPointsid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aAsToolbarItem
 NUMBER/* Включить в тулбар *//* Включить в тулбар */
,aActionType
 NUMBER/* Вариант действия *//* Вариант действия */
,aTheFilter CHAR := null /* Фильтр *//* Фильтр */
,aJournal CHAR := null /* Журнал *//* Журнал */
,aReport CHAR := null /* Отчет *//* Отчет */
,aDocument CHAR := null /* Документ *//* Документ */
,aMethod CHAR := null /* Метод *//* Метод */
,aIconFile
 VARCHAR2 := null /* Файл картинки *//* Файл картинки */
,aTheExtention CHAR := null /* Расширение *//* Расширение */
,aARM CHAR := null /* АРМ *//* АРМ */
,aTheComment VARCHAR2 := null /* Примечание *//* Примечание */
,aObjectType CHAR := null /* Тип документа *//* Тип документа */
,aJournalFixedQuery VARCHAR2 := null /* Ограничения к журналу *//* Ограничения к журналу */
,aAllowAdd
 NUMBER/* Разрешено добавление *//* Разрешено добавление */
,aAllowEdit
 NUMBER/* Разрешено редактирование *//* Разрешено редактирование */
,aAllowDel
 NUMBER/* Рарешено удаление *//* Рарешено удаление */
,aAllowFilter
 NUMBER/* Разрешен фильтр *//* Разрешен фильтр */
,aAllowPrint
 NUMBER/* Разрешена печать *//* Разрешена печать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from EntryPoints where EntryPointsID=aEntryPointsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from EntryPoints where EntryPointsid=aEntryPointsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:EntryPoints',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=EntryPoints');
      return;
    end if;
  end if;
 --  verify lock  --
 EntryPoints_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aEntryPointsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EntryPoints');
    return;
  end if;
 -- update row  --
 update  EntryPoints set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  AsToolbarItem=aAsToolbarItem
,
  ActionType=aActionType
,
  TheFilter=aTheFilter
,
  Journal=aJournal
,
  Report=aReport
,
  Document=aDocument
,
  Method=aMethod
,
  IconFile=aIconFile
,
  TheExtention=aTheExtention
,
  ARM=aARM
,
  TheComment=aTheComment
,
  ObjectType=aObjectType
,
  JournalFixedQuery=aJournalFixedQuery
,
  AllowAdd=aAllowAdd
,
  AllowEdit=aAllowEdit
,
  AllowDel=aAllowDel
,
  AllowFilter=aAllowFilter
,
  AllowPrint=aAllowPrint
  where  EntryPointsID = aEntryPointsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:EntryPoints',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=EntryPoints');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EntryPoints');
    return;
  end if;
 insert into   EntryPoints
 (  EntryPointsID 
,ParentRowid
,InstanceID
,sequence

,Name

,Caption

,AsToolbarItem

,ActionType

,TheFilter

,Journal

,Report

,Document

,Method

,IconFile

,TheExtention

,ARM

,TheComment

,ObjectType

,JournalFixedQuery

,AllowAdd

,AllowEdit

,AllowDel

,AllowFilter

,AllowPrint

 ) values ( aEntryPointsID 
,aParentRowid
,aInstanceID
,asequence

,aName

,aCaption

,aAsToolbarItem

,aActionType

,aTheFilter

,aJournal

,aReport

,aDocument

,aMethod

,aIconFile

,aTheExtention

,aARM

,aTheComment

,aObjectType

,aJournalFixedQuery

,aAllowAdd

,aAllowEdit

,aAllowDel

,aAllowFilter

,aAllowPrint

 ); 
 EntryPoints_SINIT( aCURSESSION,aEntryPointsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure EntryPoints_PARENT /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from EntryPoints where  EntryPointsid=aRowID;
 end; 

procedure EntryPoints_ISLOCKED /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from EntryPoints where EntryPointsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  EntryPoints_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure EntryPoints_LOCK /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 EntryPoints_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  EntryPoints_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from EntryPoints where EntryPointsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=EntryPoints');
    return;
  end if;
   if  aLockMode =2  
   then   
    update EntryPoints set LockUserID =auserID ,LockSessionID =null where EntryPointsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update EntryPoints set LockUserID =null,LockSessionID =aCURSESSION  where EntryPointsid=aRowID;
     return;
   end if;
 end ;

procedure EntryPoints_HCL /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_EPFilterLink is select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aRowid;
row_EPFilterLink lch_EPFilterLink%ROWTYPE;
begin  
--open lch_EPFilterLink;
for row_EPFilterLink in lch_EPFilterLink
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from EPFilterLink where EPFilterLinkid=row_EPFilterLink.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_EPFilterLink;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_EPFilterLink;
     return;
   end if; 
 end if;  
 EPFilterLink_HCL (acursession,row_EPFilterLink.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_EPFilterLink;
   return;
 end if;
end loop;
--close lch_EPFilterLink;
end;
aIsLocked :=0;
end;

procedure EntryPoints_UNLOCK /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 EntryPoints_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update EntryPoints set LockUserID =null  where EntryPointsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update EntryPoints set LockSessionID =null  where EntryPointsid=aRowID;
     return;
   end if;
 end; 

procedure EntryPoints_SINIT /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from EntryPoints where EntryPointsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =EntryPoints');
    return;
  end if;
if aSecurityStyleID is null then
 EntryPoints_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update EntryPoints set securitystyleid =aStyleID where EntryPointsid = aRowID;
else 
 update EntryPoints set securitystyleid =aSecurityStyleID where EntryPointsid = aRowID;
end if; 
end ; 

procedure EntryPoints_propagate /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from EntryPoints where EntryPointsid=aRowid;
declare cursor pch_EPFilterLink  is select EPFilterLink.EPFilterLinkid ID from EPFilterLink where  EPFilterLink.ParentStructRowID = aRowid;
row_EPFilterLink  pch_EPFilterLink%ROWTYPE;
begin
--open pch_EPFilterLink;
for row_EPFilterLink in pch_EPFilterLink loop
   EPFilterLink_SINIT( acursession,row_EPFilterLink.id,assid);
   EPFilterLink_propagate( acursession,row_EPFilterLink.id);
end loop;
--close pch_EPFilterLink;
end;
end;


procedure EPFilterLink_BRIEF  (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aEPFilterLinkid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from EPFilterLink where EPFilterLinkid=aEPFilterLinkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=EPFilterLink');
    return;
  end if;
  aBRIEF:=func.EPFilterLink_BRIEF_F(aEPFilterLinkid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure EPFilterLink_DELETE /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from EPFilterLink where EPFilterLinkid=aEPFilterLinkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:EPFilterLink',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=EPFilterLink');
      return;
    end if;
  end if;
 --  verify lock  --
 EPFilterLink_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aEPFilterLinkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=EPFilterLink');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_EPFilterLink is select  instanceid ID from instance where OwnerPartName ='EPFilterLink' and OwnerRowID=aEPFilterLinkid;
row_EPFilterLink  chld_EPFilterLink%ROWTYPE;
begin
--open chld_EPFilterLink;
for row_EPFilterLink in chld_EPFilterLink loop
 Kernel.INSTANCE_OWNER (acursession,row_EPFilterLink.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_EPFilterLink.id);
end loop;
--close chld_EPFilterLink;
end ;
  delete from  EPFilterLink 
  where  EPFilterLinkID = aEPFilterLinkID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Привязка фильтра*/
procedure EPFilterLink_SAVE /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aEPFilterLinkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aRowSource
 VARCHAR2/* Источник *//* Источник */
,aTheExpression VARCHAR2/* Выражение *//* Выражение */
,aFilterField
 VARCHAR2 := null /* Поле фильтра *//* Поле фильтра */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from EPFilterLink where EPFilterLinkID=aEPFilterLinkID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from EPFilterLink where EPFilterLinkid=aEPFilterLinkID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:EPFilterLink',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=EPFilterLink');
      return;
    end if;
  end if;
 --  verify lock  --
 EPFilterLink_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aEPFilterLinkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EPFilterLink');
    return;
  end if;
 -- update row  --
 update  EPFilterLink set ChangeStamp=sysdate
,
  RowSource=aRowSource
,
  TheExpression=aTheExpression
,
  FilterField=aFilterField
  where  EPFilterLinkID = aEPFilterLinkID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from EntryPoints where EntryPointsid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:EPFilterLink',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=EPFilterLink');
      return;
    end if;
 end if;
 EntryPoints_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=EPFilterLink');
    return;
  end if;
 insert into   EPFilterLink
 (  EPFilterLinkID 
,ParentStructRowID
,RowSource

,TheExpression

,FilterField

 ) values ( aEPFilterLinkID 
,aParentStructRowID
,aRowSource

,aTheExpression

,aFilterField

 ); 
 EPFilterLink_SINIT( aCURSESSION,aEPFilterLinkid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure EPFilterLink_PARENT /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from EPFilterLink where  EPFilterLinkid=aRowID;
  aParentTable := 'EntryPoints';
 end; 

procedure EPFilterLink_ISLOCKED /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from EPFilterLink where EPFilterLinkid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  EPFilterLink_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure EPFilterLink_LOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 EPFilterLink_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  EPFilterLink_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from EPFilterLink where EPFilterLinkid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=EPFilterLink');
    return;
  end if;
   if  aLockMode =2  
   then   
    update EPFilterLink set LockUserID =auserID ,LockSessionID =null where EPFilterLinkid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update EPFilterLink set LockUserID =null,LockSessionID =aCURSESSION  where EPFilterLinkid=aRowID;
     return;
   end if;
 end ;

procedure EPFilterLink_HCL /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure EPFilterLink_UNLOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 EPFilterLink_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update EPFilterLink set LockUserID =null  where EPFilterLinkid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update EPFilterLink set LockSessionID =null  where EPFilterLinkid=aRowID;
     return;
   end if;
 end; 

procedure EPFilterLink_SINIT /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from EPFilterLink where EPFilterLinkid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =EPFilterLink');
    return;
  end if;
if aSecurityStyleID is null then
 EPFilterLink_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update EPFilterLink set securitystyleid =aStyleID where EPFilterLinkid = aRowID;
else 
 update EPFilterLink set securitystyleid =aSecurityStyleID where EPFilterLinkid = aRowID;
end if; 
end ; 

procedure EPFilterLink_propagate /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from EPFilterLink where EPFilterLinkid=aRowid;
end;


procedure WorkPlace_BRIEF  (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aWorkPlaceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from WorkPlace where WorkPlaceid=aWorkPlaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=WorkPlace');
    return;
  end if;
  aBRIEF:=func.WorkPlace_BRIEF_F(aWorkPlaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure WorkPlace_DELETE /*Арм*/ (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from WorkPlace where WorkPlaceid=aWorkPlaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:WorkPlace',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=WorkPlace');
      return;
    end if;
  end if;
 --  verify lock  --
 WorkPlace_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aWorkPlaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=WorkPlace');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_WorkPlace is select  instanceid ID from instance where OwnerPartName ='WorkPlace' and OwnerRowID=aWorkPlaceid;
row_WorkPlace  chld_WorkPlace%ROWTYPE;
begin
--open chld_WorkPlace;
for row_WorkPlace in chld_WorkPlace loop
 Kernel.INSTANCE_OWNER (acursession,row_WorkPlace.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_WorkPlace.id);
end loop;
--close chld_WorkPlace;
end ;
  delete from  WorkPlace 
  where  WorkPlaceID = aWorkPlaceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Арм*/
procedure WorkPlace_SAVE /*Арм*/ (
 aCURSESSION CHAR,
 aWorkPlaceid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aTheVersion
 VARCHAR2 := null /* Версия *//* Версия */
,aThePlatform
 NUMBER := null /* Платформа реализации *//* Платформа реализации */
,aTheComment VARCHAR2 := null /* Примечание *//* Примечание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from WorkPlace where WorkPlaceID=aWorkPlaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from WorkPlace where WorkPlaceid=aWorkPlaceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:WorkPlace',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=WorkPlace');
      return;
    end if;
  end if;
 --  verify lock  --
 WorkPlace_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aWorkPlaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=WorkPlace');
    return;
  end if;
 -- update row  --
 update  WorkPlace set ChangeStamp=sysdate
,
  Name=aName
,
  Caption=aCaption
,
  TheVersion=aTheVersion
,
  ThePlatform=aThePlatform
,
  TheComment=aTheComment
  where  WorkPlaceID = aWorkPlaceID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from WorkPlace where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=WorkPlace');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:WorkPlace',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=WorkPlace');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=WorkPlace');
    return;
  end if;
select Count(*) into existsCnt from WorkPlace where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;WorkPlace&gt;');
    return;
 End if;
 insert into   WorkPlace
 (  WorkPlaceID 
,InstanceID
,Name

,Caption

,TheVersion

,ThePlatform

,TheComment

 ) values ( aWorkPlaceID 
,aInstanceID
,aName

,aCaption

,aTheVersion

,aThePlatform

,aTheComment

 ); 
 WorkPlace_SINIT( aCURSESSION,aWorkPlaceid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from WorkPlace where 1=1  
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=WorkPlace');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure WorkPlace_PARENT /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from WorkPlace where  WorkPlaceid=aRowID;
 end; 

procedure WorkPlace_ISLOCKED /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from WorkPlace where WorkPlaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  WorkPlace_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure WorkPlace_LOCK /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 WorkPlace_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  WorkPlace_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from WorkPlace where WorkPlaceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=WorkPlace');
    return;
  end if;
   if  aLockMode =2  
   then   
    update WorkPlace set LockUserID =auserID ,LockSessionID =null where WorkPlaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update WorkPlace set LockUserID =null,LockSessionID =aCURSESSION  where WorkPlaceid=aRowID;
     return;
   end if;
 end ;

procedure WorkPlace_HCL /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure WorkPlace_UNLOCK /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 WorkPlace_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update WorkPlace set LockUserID =null  where WorkPlaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update WorkPlace set LockSessionID =null  where WorkPlaceid=aRowID;
     return;
   end if;
 end; 

procedure WorkPlace_SINIT /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from WorkPlace where WorkPlaceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =WorkPlace');
    return;
  end if;
if aSecurityStyleID is null then
 WorkPlace_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update WorkPlace set securitystyleid =aStyleID where WorkPlaceid = aRowID;
else 
 update WorkPlace set securitystyleid =aSecurityStyleID where WorkPlaceid = aRowID;
end if; 
end ; 

procedure WorkPlace_propagate /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from WorkPlace where WorkPlaceid=aRowid;
end;


procedure ARMTypes_BRIEF  (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aARMTypesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ARMTypes where ARMTypesid=aARMTypesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ARMTypes');
    return;
  end if;
  aBRIEF:=func.ARMTypes_BRIEF_F(aARMTypesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ARMTypes_DELETE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ARMTypes where ARMTypesid=aARMTypesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ARMTypes',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ARMTypes');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMTypes_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMTypesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ARMTypes');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ARMTypes is select  instanceid ID from instance where OwnerPartName ='ARMTypes' and OwnerRowID=aARMTypesid;
row_ARMTypes  chld_ARMTypes%ROWTYPE;
begin
--open chld_ARMTypes;
for row_ARMTypes in chld_ARMTypes loop
 Kernel.INSTANCE_OWNER (acursession,row_ARMTypes.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ARMTypes.id);
end loop;
--close chld_ARMTypes;
end ;
  delete from  ARMTypes 
  where  ARMTypesID = aARMTypesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Список типов*/
procedure ARMTypes_SAVE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aARMTypesid CHAR,
aInstanceID CHAR 
,aTheDocumentType CHAR/* Тип документа *//* Тип документа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ARMTypes where ARMTypesID=aARMTypesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ARMTypes where ARMTypesid=aARMTypesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ARMTypes',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ARMTypes');
      return;
    end if;
  end if;
 --  verify lock  --
 ARMTypes_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aARMTypesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMTypes');
    return;
  end if;
 -- update row  --
 update  ARMTypes set ChangeStamp=sysdate
,
  TheDocumentType=aTheDocumentType
  where  ARMTypesID = aARMTypesID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ARMTypes',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ARMTypes');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ARMTypes');
    return;
  end if;
 insert into   ARMTypes
 (  ARMTypesID 
,InstanceID
,TheDocumentType

 ) values ( aARMTypesID 
,aInstanceID
,aTheDocumentType

 ); 
 ARMTypes_SINIT( aCURSESSION,aARMTypesid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ARMTypes_PARENT /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ARMTypes where  ARMTypesid=aRowID;
 end; 

procedure ARMTypes_ISLOCKED /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ARMTypes where ARMTypesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ARMTypes_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ARMTypes_LOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ARMTypes_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ARMTypes_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ARMTypes where ARMTypesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ARMTypes');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ARMTypes set LockUserID =auserID ,LockSessionID =null where ARMTypesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ARMTypes set LockUserID =null,LockSessionID =aCURSESSION  where ARMTypesid=aRowID;
     return;
   end if;
 end ;

procedure ARMTypes_HCL /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ARMTypes_UNLOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ARMTypes_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ARMTypes set LockUserID =null  where ARMTypesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ARMTypes set LockSessionID =null  where ARMTypesid=aRowID;
     return;
   end if;
 end; 

procedure ARMTypes_SINIT /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ARMTypes where ARMTypesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ARMTypes');
    return;
  end if;
if aSecurityStyleID is null then
 ARMTypes_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ARMTypes set securitystyleid =aStyleID where ARMTypesid = aRowID;
else 
 update ARMTypes set securitystyleid =aSecurityStyleID where ARMTypesid = aRowID;
end if; 
end ; 

procedure ARMTypes_propagate /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ARMTypes where ARMTypesid=aRowid;
end;
end MTZwp;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ROLES" BlockCode=" create or replace package body ROLES as

procedure ROLES_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='ROLES'
then
declare cursor child_ROLES_OPERATIONS is select ROLES_OPERATIONS.ROLES_OPERATIONSid ID from ROLES_OPERATIONS where  ROLES_OPERATIONS.InstanceID = ainstanceid;
row_ROLES_OPERATIONS  child_ROLES_OPERATIONS%ROWTYPE;
begin
--open child_ROLES_OPERATIONS;
for row_ROLES_OPERATIONS in child_ROLES_OPERATIONS loop
 ROLES_OPERATIONS_DELETE (acursession,row_ROLES_OPERATIONS.id,aInstanceID);
end loop;
--close child_ROLES_OPERATIONS;
end;
declare cursor child_ROLES_WP is select ROLES_WP.ROLES_WPid ID from ROLES_WP where  ROLES_WP.InstanceID = ainstanceid;
row_ROLES_WP  child_ROLES_WP%ROWTYPE;
begin
--open child_ROLES_WP;
for row_ROLES_WP in child_ROLES_WP loop
 ROLES_WP_DELETE (acursession,row_ROLES_WP.id,aInstanceID);
end loop;
--close child_ROLES_WP;
end;
declare cursor child_ROLES2_MODULE is select ROLES2_MODULE.ROLES2_MODULEid ID from ROLES2_MODULE where  ROLES2_MODULE.InstanceID = ainstanceid;
row_ROLES2_MODULE  child_ROLES2_MODULE%ROWTYPE;
begin
--open child_ROLES2_MODULE;
for row_ROLES2_MODULE in child_ROLES2_MODULE loop
 ROLES2_MODULE_DELETE (acursession,row_ROLES2_MODULE.id,aInstanceID);
end loop;
--close child_ROLES2_MODULE;
end;
declare cursor child_ROLES_DOC is select ROLES_DOC.ROLES_DOCid ID from ROLES_DOC where  ROLES_DOC.InstanceID = ainstanceid;
row_ROLES_DOC  child_ROLES_DOC%ROWTYPE;
begin
--open child_ROLES_DOC;
for row_ROLES_DOC in child_ROLES_DOC loop
 ROLES_DOC_DELETE (acursession,row_ROLES_DOC.id,aInstanceID);
end loop;
--close child_ROLES_DOC;
end;
declare cursor child_ROLES_REPORTS is select ROLES_REPORTS.ROLES_REPORTSid ID from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = ainstanceid;
row_ROLES_REPORTS  child_ROLES_REPORTS%ROWTYPE;
begin
--open child_ROLES_REPORTS;
for row_ROLES_REPORTS in child_ROLES_REPORTS loop
 ROLES_REPORTS_DELETE (acursession,row_ROLES_REPORTS.id,aInstanceID);
end loop;
--close child_ROLES_REPORTS;
end;
declare cursor child_ROLES_USER is select ROLES_USER.ROLES_USERid ID from ROLES_USER where  ROLES_USER.InstanceID = ainstanceid;
row_ROLES_USER  child_ROLES_USER%ROWTYPE;
begin
--open child_ROLES_USER;
for row_ROLES_USER in child_ROLES_USER loop
 ROLES_USER_DELETE (acursession,row_ROLES_USER.id,aInstanceID);
end loop;
--close child_ROLES_USER;
end;
declare cursor child_ROLES_MAP is select ROLES_MAP.ROLES_MAPid ID from ROLES_MAP where  ROLES_MAP.InstanceID = ainstanceid;
row_ROLES_MAP  child_ROLES_MAP%ROWTYPE;
begin
--open child_ROLES_MAP;
for row_ROLES_MAP in child_ROLES_MAP loop
 ROLES_MAP_DELETE (acursession,row_ROLES_MAP.id,aInstanceID);
end loop;
--close child_ROLES_MAP;
end;
declare cursor child_ROLES_DEF is select ROLES_DEF.ROLES_DEFid ID from ROLES_DEF where  ROLES_DEF.InstanceID = ainstanceid;
row_ROLES_DEF  child_ROLES_DEF%ROWTYPE;
begin
--open child_ROLES_DEF;
for row_ROLES_DEF in child_ROLES_DEF loop
 ROLES_DEF_DELETE (acursession,row_ROLES_DEF.id,aInstanceID);
end loop;
--close child_ROLES_DEF;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure ROLES_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'ROLES'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_ROLES_OPERATIONS is select ROLES_OPERATIONS.ROLES_OPERATIONSid ID from ROLES_OPERATIONS where  ROLES_OPERATIONS.InstanceID = arowid;
ROW_ROLES_OPERATIONS  lch_ROLES_OPERATIONS%ROWTYPE;
begin
--open lch_ROLES_OPERATIONS;
for row_ROLES_OPERATIONS in lch_ROLES_OPERATIONS loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_OPERATIONS where ROLES_OPERATIONSid=row_ROLES_OPERATIONS.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_OPERATIONS;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_OPERATIONS;
     return;
   end if; 
 end if; 
 ROLES_OPERATIONS_HCL (acursession,ROW_ROLES_OPERATIONS.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_OPERATIONS;
   return;
 end if;
 end loop;
--close lch_ROLES_OPERATIONS;
end;
declare cursor lch_ROLES_WP is select ROLES_WP.ROLES_WPid ID from ROLES_WP where  ROLES_WP.InstanceID = arowid;
ROW_ROLES_WP  lch_ROLES_WP%ROWTYPE;
begin
--open lch_ROLES_WP;
for row_ROLES_WP in lch_ROLES_WP loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_WP where ROLES_WPid=row_ROLES_WP.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_WP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_WP;
     return;
   end if; 
 end if; 
 ROLES_WP_HCL (acursession,ROW_ROLES_WP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_WP;
   return;
 end if;
 end loop;
--close lch_ROLES_WP;
end;
declare cursor lch_ROLES2_MODULE is select ROLES2_MODULE.ROLES2_MODULEid ID from ROLES2_MODULE where  ROLES2_MODULE.InstanceID = arowid;
ROW_ROLES2_MODULE  lch_ROLES2_MODULE%ROWTYPE;
begin
--open lch_ROLES2_MODULE;
for row_ROLES2_MODULE in lch_ROLES2_MODULE loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES2_MODULE where ROLES2_MODULEid=row_ROLES2_MODULE.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES2_MODULE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES2_MODULE;
     return;
   end if; 
 end if; 
 ROLES2_MODULE_HCL (acursession,ROW_ROLES2_MODULE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES2_MODULE;
   return;
 end if;
 end loop;
--close lch_ROLES2_MODULE;
end;
declare cursor lch_ROLES_DOC is select ROLES_DOC.ROLES_DOCid ID from ROLES_DOC where  ROLES_DOC.InstanceID = arowid;
ROW_ROLES_DOC  lch_ROLES_DOC%ROWTYPE;
begin
--open lch_ROLES_DOC;
for row_ROLES_DOC in lch_ROLES_DOC loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_DOC where ROLES_DOCid=row_ROLES_DOC.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_DOC;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_DOC;
     return;
   end if; 
 end if; 
 ROLES_DOC_HCL (acursession,ROW_ROLES_DOC.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_DOC;
   return;
 end if;
 end loop;
--close lch_ROLES_DOC;
end;
declare cursor lch_ROLES_REPORTS is select ROLES_REPORTS.ROLES_REPORTSid ID from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = arowid;
ROW_ROLES_REPORTS  lch_ROLES_REPORTS%ROWTYPE;
begin
--open lch_ROLES_REPORTS;
for row_ROLES_REPORTS in lch_ROLES_REPORTS loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_REPORTS where ROLES_REPORTSid=row_ROLES_REPORTS.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_REPORTS;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_REPORTS;
     return;
   end if; 
 end if; 
 ROLES_REPORTS_HCL (acursession,ROW_ROLES_REPORTS.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_REPORTS;
   return;
 end if;
 end loop;
--close lch_ROLES_REPORTS;
end;
declare cursor lch_ROLES_USER is select ROLES_USER.ROLES_USERid ID from ROLES_USER where  ROLES_USER.InstanceID = arowid;
ROW_ROLES_USER  lch_ROLES_USER%ROWTYPE;
begin
--open lch_ROLES_USER;
for row_ROLES_USER in lch_ROLES_USER loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_USER where ROLES_USERid=row_ROLES_USER.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_USER;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_USER;
     return;
   end if; 
 end if; 
 ROLES_USER_HCL (acursession,ROW_ROLES_USER.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_USER;
   return;
 end if;
 end loop;
--close lch_ROLES_USER;
end;
declare cursor lch_ROLES_MAP is select ROLES_MAP.ROLES_MAPid ID from ROLES_MAP where  ROLES_MAP.InstanceID = arowid;
ROW_ROLES_MAP  lch_ROLES_MAP%ROWTYPE;
begin
--open lch_ROLES_MAP;
for row_ROLES_MAP in lch_ROLES_MAP loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_MAP where ROLES_MAPid=row_ROLES_MAP.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_MAP;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_MAP;
     return;
   end if; 
 end if; 
 ROLES_MAP_HCL (acursession,ROW_ROLES_MAP.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_MAP;
   return;
 end if;
 end loop;
--close lch_ROLES_MAP;
end;
declare cursor lch_ROLES_DEF is select ROLES_DEF.ROLES_DEFid ID from ROLES_DEF where  ROLES_DEF.InstanceID = arowid;
ROW_ROLES_DEF  lch_ROLES_DEF%ROWTYPE;
begin
--open lch_ROLES_DEF;
for row_ROLES_DEF in lch_ROLES_DEF loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from ROLES_DEF where ROLES_DEFid=row_ROLES_DEF.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_DEF;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_ROLES_DEF;
     return;
   end if; 
 end if; 
 ROLES_DEF_HCL (acursession,ROW_ROLES_DEF.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_DEF;
   return;
 end if;
 end loop;
--close lch_ROLES_DEF;
end;
 end if;
aIsLocked:=0;
end;
procedure ROLES_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'ROLES'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_ROLES_OPERATIONS is select ROLES_OPERATIONS.ROLES_OPERATIONSid id from ROLES_OPERATIONS where  ROLES_OPERATIONS.InstanceID = arowid;
row_ROLES_OPERATIONS  pch_ROLES_OPERATIONS%ROWTYPE;
begin
--open pch_ROLES_OPERATIONS;
for row_ROLES_OPERATIONS in  pch_ROLES_OPERATIONS loop
 ROLES_OPERATIONS_SINIT( acursession,row_ROLES_OPERATIONS.id,assid);
 ROLES_OPERATIONS_propagate( acursession,row_ROLES_OPERATIONS.id);
end loop;
--close pch_ROLES_OPERATIONS;
end;
declare cursor pch_ROLES_WP is select ROLES_WP.ROLES_WPid id from ROLES_WP where  ROLES_WP.InstanceID = arowid;
row_ROLES_WP  pch_ROLES_WP%ROWTYPE;
begin
--open pch_ROLES_WP;
for row_ROLES_WP in  pch_ROLES_WP loop
 ROLES_WP_SINIT( acursession,row_ROLES_WP.id,assid);
 ROLES_WP_propagate( acursession,row_ROLES_WP.id);
end loop;
--close pch_ROLES_WP;
end;
declare cursor pch_ROLES2_MODULE is select ROLES2_MODULE.ROLES2_MODULEid id from ROLES2_MODULE where  ROLES2_MODULE.InstanceID = arowid;
row_ROLES2_MODULE  pch_ROLES2_MODULE%ROWTYPE;
begin
--open pch_ROLES2_MODULE;
for row_ROLES2_MODULE in  pch_ROLES2_MODULE loop
 ROLES2_MODULE_SINIT( acursession,row_ROLES2_MODULE.id,assid);
 ROLES2_MODULE_propagate( acursession,row_ROLES2_MODULE.id);
end loop;
--close pch_ROLES2_MODULE;
end;
declare cursor pch_ROLES_DOC is select ROLES_DOC.ROLES_DOCid id from ROLES_DOC where  ROLES_DOC.InstanceID = arowid;
row_ROLES_DOC  pch_ROLES_DOC%ROWTYPE;
begin
--open pch_ROLES_DOC;
for row_ROLES_DOC in  pch_ROLES_DOC loop
 ROLES_DOC_SINIT( acursession,row_ROLES_DOC.id,assid);
 ROLES_DOC_propagate( acursession,row_ROLES_DOC.id);
end loop;
--close pch_ROLES_DOC;
end;
declare cursor pch_ROLES_REPORTS is select ROLES_REPORTS.ROLES_REPORTSid id from ROLES_REPORTS where  ROLES_REPORTS.InstanceID = arowid;
row_ROLES_REPORTS  pch_ROLES_REPORTS%ROWTYPE;
begin
--open pch_ROLES_REPORTS;
for row_ROLES_REPORTS in  pch_ROLES_REPORTS loop
 ROLES_REPORTS_SINIT( acursession,row_ROLES_REPORTS.id,assid);
 ROLES_REPORTS_propagate( acursession,row_ROLES_REPORTS.id);
end loop;
--close pch_ROLES_REPORTS;
end;
declare cursor pch_ROLES_USER is select ROLES_USER.ROLES_USERid id from ROLES_USER where  ROLES_USER.InstanceID = arowid;
row_ROLES_USER  pch_ROLES_USER%ROWTYPE;
begin
--open pch_ROLES_USER;
for row_ROLES_USER in  pch_ROLES_USER loop
 ROLES_USER_SINIT( acursession,row_ROLES_USER.id,assid);
 ROLES_USER_propagate( acursession,row_ROLES_USER.id);
end loop;
--close pch_ROLES_USER;
end;
declare cursor pch_ROLES_MAP is select ROLES_MAP.ROLES_MAPid id from ROLES_MAP where  ROLES_MAP.InstanceID = arowid;
row_ROLES_MAP  pch_ROLES_MAP%ROWTYPE;
begin
--open pch_ROLES_MAP;
for row_ROLES_MAP in  pch_ROLES_MAP loop
 ROLES_MAP_SINIT( acursession,row_ROLES_MAP.id,assid);
 ROLES_MAP_propagate( acursession,row_ROLES_MAP.id);
end loop;
--close pch_ROLES_MAP;
end;
declare cursor pch_ROLES_DEF is select ROLES_DEF.ROLES_DEFid id from ROLES_DEF where  ROLES_DEF.InstanceID = arowid;
row_ROLES_DEF  pch_ROLES_DEF%ROWTYPE;
begin
--open pch_ROLES_DEF;
for row_ROLES_DEF in  pch_ROLES_DEF loop
 ROLES_DEF_SINIT( acursession,row_ROLES_DEF.id,assid);
 ROLES_DEF_propagate( acursession,row_ROLES_DEF.id);
end loop;
--close pch_ROLES_DEF;
end;
 end if; 
end;


procedure ROLES_OPERATIONS_BRIEF  (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_OPERATIONSid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_OPERATIONS where ROLES_OPERATIONSID=aROLES_OPERATIONSID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_OPERATIONS where ROLES_OPERATIONSid=aROLES_OPERATIONSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_OPERATIONS');
    return;
  end if;
  aBRIEF:=func.ROLES_OPERATIONS_BRIEF_F(aROLES_OPERATIONSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_OPERATIONS_DELETE /*Именованные операции*/ (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_OPERATIONS where ROLES_OPERATIONSID=aROLES_OPERATIONSID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aROLES_OPERATIONSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_OPERATIONS',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_OPERATIONS');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_OPERATIONS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_OPERATIONSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_OPERATIONS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES_OPERATIONS',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aROLES_OPERATIONSid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_ROLES_OPERATIONS is select  instanceid ID from instance where OwnerPartName ='ROLES_OPERATIONS' and OwnerRowID=aROLES_OPERATIONSid;
row_ROLES_OPERATIONS  chld_ROLES_OPERATIONS%ROWTYPE;
begin
--open chld_ROLES_OPERATIONS;
for row_ROLES_OPERATIONS in chld_ROLES_OPERATIONS loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_OPERATIONS.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_OPERATIONS.id);
end loop;
--close chld_ROLES_OPERATIONS;
end ;
  delete from  ROLES_OPERATIONS 
  where  ROLES_OPERATIONSID = aROLES_OPERATIONSID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные действия*/
procedure ROLES_OPERATIONS_SAVE /*Именованные операции*/ (
 aCURSESSION CHAR,
 aROLES_OPERATIONSid CHAR,
aInstanceID CHAR 
,ainfo
 VARCHAR2/* Описание *//* Описание */
,aAllowAction
 NUMBER/* Разрешено *//* Разрешено */
,aName
 VARCHAR2/* Код *//* Код */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_OPERATIONS where ROLES_OPERATIONSID=aROLES_OPERATIONSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aROLES_OPERATIONSID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_OPERATIONS',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_OPERATIONS');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_OPERATIONS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_OPERATIONSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_OPERATIONS');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES_OPERATIONS',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aROLES_OPERATIONSid,aLogInstanceID=&gt;aInstanceID);
 update  ROLES_OPERATIONS set ChangeStamp=sysdate
,
  info=ainfo
,
  AllowAction=aAllowAction
,
  Name=aName
  where  ROLES_OPERATIONSID = aROLES_OPERATIONSID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_OPERATIONS where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_OPERATIONS');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_OPERATIONS',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_OPERATIONS');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_OPERATIONS');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES_OPERATIONS',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aROLES_OPERATIONSid,aLogInstanceID=&gt;aInstanceID);
 insert into   ROLES_OPERATIONS
 (  ROLES_OPERATIONSID 
,InstanceID
,info

,AllowAction

,Name

 ) values ( aROLES_OPERATIONSID 
,aInstanceID
,ainfo

,aAllowAction

,aName

 ); 
 ROLES_OPERATIONS_SINIT( aCURSESSION,aROLES_OPERATIONSid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_OPERATIONS where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_OPERATIONS');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_OPERATIONS_PARENT /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_OPERATIONS where  ROLES_OPERATIONSid=aRowID;
 end; 

procedure ROLES_OPERATIONS_ISLOCKED /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_OPERATIONS_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_OPERATIONS_LOCK /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_OPERATIONS_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_OPERATIONS_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_OPERATIONS');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_OPERATIONS set LockUserID =auserID ,LockSessionID =null where ROLES_OPERATIONSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_OPERATIONS set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_OPERATIONSid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_OPERATIONS_HCL /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_OPERATIONS_UNLOCK /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_OPERATIONS_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_OPERATIONS set LockUserID =null  where ROLES_OPERATIONSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_OPERATIONS set LockSessionID =null  where ROLES_OPERATIONSid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_OPERATIONS_SINIT /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_OPERATIONS');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_OPERATIONS_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_OPERATIONS set securitystyleid =aStyleID where ROLES_OPERATIONSid = aRowID;
else 
 update ROLES_OPERATIONS set securitystyleid =aSecurityStyleID where ROLES_OPERATIONSid = aRowID;
end if; 
end ; 

procedure ROLES_OPERATIONS_propagate /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_OPERATIONS where ROLES_OPERATIONSid=aRowid;
end;


procedure ROLES_WP_BRIEF  (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_WPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_WP where ROLES_WPid=aROLES_WPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_WP');
    return;
  end if;
  aBRIEF:=func.ROLES_WP_BRIEF_F(aROLES_WPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_WP_DELETE /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_WP where ROLES_WPid=aROLES_WPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_WP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_WP');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_WP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_WPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_WP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ROLES_ACT is select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aROLES_WPid;
    child_ROLES_ACT_rec  child_ROLES_ACT%ROWTYPE;
    begin
    --open child_ROLES_ACT;
      for child_ROLES_ACT_rec in child_ROLES_ACT loop
      ROLES_ACT_DELETE (acursession,child_ROLES_ACT_rec.id,aInstanceid);
      end loop;
      --close child_ROLES_ACT;
    end ;
declare cursor chld_ROLES_WP is select  instanceid ID from instance where OwnerPartName ='ROLES_WP' and OwnerRowID=aROLES_WPid;
row_ROLES_WP  chld_ROLES_WP%ROWTYPE;
begin
--open chld_ROLES_WP;
for row_ROLES_WP in chld_ROLES_WP loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_WP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_WP.id);
end loop;
--close chld_ROLES_WP;
end ;
  delete from  ROLES_WP 
  where  ROLES_WPID = aROLES_WPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные приложения*/
procedure ROLES_WP_SAVE /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aROLES_WPid CHAR,
aInstanceID CHAR 
,aWP CHAR/* Приложение *//* Приложение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_WP where ROLES_WPID=aROLES_WPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_WP where ROLES_WPid=aROLES_WPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_WP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_WP');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_WP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_WPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_WP');
    return;
  end if;
 -- update row  --
 update  ROLES_WP set ChangeStamp=sysdate
,
  WP=aWP
  where  ROLES_WPID = aROLES_WPID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_WP where InstanceID=aInstanceID 
 and WP=aWP;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_WP');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_WP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_WP');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_WP');
    return;
  end if;
 insert into   ROLES_WP
 (  ROLES_WPID 
,InstanceID
,WP

 ) values ( aROLES_WPID 
,aInstanceID
,aWP

 ); 
 ROLES_WP_SINIT( aCURSESSION,aROLES_WPid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_WP where InstanceID=aInstanceID 
 and WP=aWP;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_WP');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_WP_PARENT /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_WP where  ROLES_WPid=aRowID;
 end; 

procedure ROLES_WP_ISLOCKED /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_WP where ROLES_WPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_WP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_WP_LOCK /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_WP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_WP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_WP where ROLES_WPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_WP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_WP set LockUserID =auserID ,LockSessionID =null where ROLES_WPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_WP set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_WPid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_WP_HCL /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ROLES_ACT is select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aRowid;
row_ROLES_ACT lch_ROLES_ACT%ROWTYPE;
begin  
--open lch_ROLES_ACT;
for row_ROLES_ACT in lch_ROLES_ACT
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ROLES_ACT where ROLES_ACTid=row_ROLES_ACT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_ACT;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ROLES_ACT;
     return;
   end if; 
 end if;  
 ROLES_ACT_HCL (acursession,row_ROLES_ACT.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_ACT;
   return;
 end if;
end loop;
--close lch_ROLES_ACT;
end;
aIsLocked :=0;
end;

procedure ROLES_WP_UNLOCK /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_WP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_WP set LockUserID =null  where ROLES_WPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_WP set LockSessionID =null  where ROLES_WPid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_WP_SINIT /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_WP where ROLES_WPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_WP');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_WP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_WP set securitystyleid =aStyleID where ROLES_WPid = aRowID;
else 
 update ROLES_WP set securitystyleid =aSecurityStyleID where ROLES_WPid = aRowID;
end if; 
end ; 

procedure ROLES_WP_propagate /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_WP where ROLES_WPid=aRowid;
declare cursor pch_ROLES_ACT  is select ROLES_ACT.ROLES_ACTid ID from ROLES_ACT where  ROLES_ACT.ParentStructRowID = aRowid;
row_ROLES_ACT  pch_ROLES_ACT%ROWTYPE;
begin
--open pch_ROLES_ACT;
for row_ROLES_ACT in pch_ROLES_ACT loop
   ROLES_ACT_SINIT( acursession,row_ROLES_ACT.id,assid);
   ROLES_ACT_propagate( acursession,row_ROLES_ACT.id);
end loop;
--close pch_ROLES_ACT;
end;
end;


procedure ROLES_ACT_BRIEF  (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_ACTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_ACT where ROLES_ACTid=aROLES_ACTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_ACT');
    return;
  end if;
  aBRIEF:=func.ROLES_ACT_BRIEF_F(aROLES_ACTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_ACT_DELETE /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_ACT where ROLES_ACTid=aROLES_ACTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_ACT',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_ACT');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_ACT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_ACTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_ACT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_ACT is select  instanceid ID from instance where OwnerPartName ='ROLES_ACT' and OwnerRowID=aROLES_ACTid;
row_ROLES_ACT  chld_ROLES_ACT%ROWTYPE;
begin
--open chld_ROLES_ACT;
for row_ROLES_ACT in chld_ROLES_ACT loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_ACT.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_ACT.id);
end loop;
--close chld_ROLES_ACT;
end ;
  delete from  ROLES_ACT 
  where  ROLES_ACTID = aROLES_ACTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные пункты меню*/
procedure ROLES_ACT_SAVE /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aROLES_ACTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aAccesible
 NUMBER := null /* Доступность *//* Доступность */
,aMenuName
 VARCHAR2/* Меню *//* Меню */
,amenuCode
 VARCHAR2/* Код пункта меню *//* Код пункта меню */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_ACT where ROLES_ACTID=aROLES_ACTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_ACT where ROLES_ACTid=aROLES_ACTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_ACT',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_ACT');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_ACT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_ACTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_ACT');
    return;
  end if;
 -- update row  --
 update  ROLES_ACT set ChangeStamp=sysdate
,
  Accesible=aAccesible
,
  MenuName=aMenuName
,
  menuCode=amenuCode
  where  ROLES_ACTID = aROLES_ACTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ROLES_WP where ROLES_WPid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_ACT',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_ACT');
      return;
    end if;
 end if;
 ROLES_WP_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_ACT');
    return;
  end if;
 insert into   ROLES_ACT
 (  ROLES_ACTID 
,ParentStructRowID
,Accesible

,MenuName

,menuCode

 ) values ( aROLES_ACTID 
,aParentStructRowID
,aAccesible

,aMenuName

,amenuCode

 ); 
 ROLES_ACT_SINIT( aCURSESSION,aROLES_ACTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ROLES_ACT_PARENT /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ROLES_ACT where  ROLES_ACTid=aRowID;
  aParentTable := 'ROLES_WP';
 end; 

procedure ROLES_ACT_ISLOCKED /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_ACT where ROLES_ACTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_ACT_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_ACT_LOCK /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_ACT_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_ACT_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_ACT where ROLES_ACTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_ACT');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_ACT set LockUserID =auserID ,LockSessionID =null where ROLES_ACTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_ACT set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_ACTid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_ACT_HCL /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_ACT_UNLOCK /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_ACT_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_ACT set LockUserID =null  where ROLES_ACTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_ACT set LockSessionID =null  where ROLES_ACTid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_ACT_SINIT /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_ACT where ROLES_ACTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_ACT');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_ACT_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_ACT set securitystyleid =aStyleID where ROLES_ACTid = aRowID;
else 
 update ROLES_ACT set securitystyleid =aSecurityStyleID where ROLES_ACTid = aRowID;
end if; 
end ; 

procedure ROLES_ACT_propagate /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_ACT where ROLES_ACTid=aRowid;
end;


procedure ROLES2_MODULE_BRIEF  (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES2_MODULEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES2_MODULE where ROLES2_MODULEID=aROLES2_MODULEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES2_MODULE where ROLES2_MODULEid=aROLES2_MODULEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES2_MODULE');
    return;
  end if;
  aBRIEF:=func.ROLES2_MODULE_BRIEF_F(aROLES2_MODULEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES2_MODULE_DELETE /**/ (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES2_MODULE where ROLES2_MODULEID=aROLES2_MODULEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES2_MODULE where ROLES2_MODULEid=aROLES2_MODULEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES2_MODULE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES2_MODULE');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES2_MODULE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES2_MODULEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES2_MODULE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ROLES2_MODREPORT is select ROLES2_MODREPORT.ROLES2_MODREPORTid ID from ROLES2_MODREPORT where  ROLES2_MODREPORT.ParentStructRowID = aROLES2_MODULEid;
    child_ROLES2_MODREPORT_rec  child_ROLES2_MODREPORT%ROWTYPE;
    begin
    --open child_ROLES2_MODREPORT;
      for child_ROLES2_MODREPORT_rec in child_ROLES2_MODREPORT loop
      ROLES2_MODREPORT_DELETE (acursession,child_ROLES2_MODREPORT_rec.id,aInstanceid);
      end loop;
      --close child_ROLES2_MODREPORT;
    end ;
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODULE',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aROLES2_MODULEid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_ROLES2_MODULE is select  instanceid ID from instance where OwnerPartName ='ROLES2_MODULE' and OwnerRowID=aROLES2_MODULEid;
row_ROLES2_MODULE  chld_ROLES2_MODULE%ROWTYPE;
begin
--open chld_ROLES2_MODULE;
for row_ROLES2_MODULE in chld_ROLES2_MODULE loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES2_MODULE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES2_MODULE.id);
end loop;
--close chld_ROLES2_MODULE;
end ;
  delete from  ROLES2_MODULE 
  where  ROLES2_MODULEID = aROLES2_MODULEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Модули*/
procedure ROLES2_MODULE_SAVE /**/ (
 aCURSESSION CHAR,
 aROLES2_MODULEid CHAR,
aInstanceID CHAR 
,aGroupName
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aModuleAccessible
 NUMBER/* Разрешен *//* Разрешен */
,aCustomizeVisibility
 NUMBER/* Настраивать видимость *//* Настраивать видимость */
,aTheIcon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aname
 VARCHAR2/* Код модуля *//* Код модуля */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
,aAllObjects
 NUMBER/* Вся фирма *//* Вся фирма */
,aColegsObject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,aSubStructObjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES2_MODULE where ROLES2_MODULEID=aROLES2_MODULEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES2_MODULE where ROLES2_MODULEid=aROLES2_MODULEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES2_MODULE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES2_MODULE');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES2_MODULE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES2_MODULEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES2_MODULE');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODULE',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aROLES2_MODULEid,aLogInstanceID=&gt;aInstanceID);
 update  ROLES2_MODULE set ChangeStamp=sysdate
,
  GroupName=aGroupName
,
  Caption=aCaption
,
  Sequence=aSequence
,
  ModuleAccessible=aModuleAccessible
,
  CustomizeVisibility=aCustomizeVisibility
,
  TheIcon=aTheIcon
,
  name=aname
,
  TheComment=aTheComment
,
  AllObjects=aAllObjects
,
  ColegsObject=aColegsObject
,
  SubStructObjects=aSubStructObjects
  where  ROLES2_MODULEID = aROLES2_MODULEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES2_MODULE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES2_MODULE');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES2_MODULE');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODULE',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aROLES2_MODULEid,aLogInstanceID=&gt;aInstanceID);
 insert into   ROLES2_MODULE
 (  ROLES2_MODULEID 
,InstanceID
,GroupName

,Caption

,Sequence

,ModuleAccessible

,CustomizeVisibility

,TheIcon

,name

,TheComment

,AllObjects

,ColegsObject

,SubStructObjects

 ) values ( aROLES2_MODULEID 
,aInstanceID
,aGroupName

,aCaption

,aSequence

,aModuleAccessible

,aCustomizeVisibility

,aTheIcon

,aname

,aTheComment

,aAllObjects

,aColegsObject

,aSubStructObjects

 ); 
 ROLES2_MODULE_SINIT( aCURSESSION,aROLES2_MODULEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ROLES2_MODULE_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES2_MODULE where  ROLES2_MODULEid=aRowID;
 end; 

procedure ROLES2_MODULE_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES2_MODULE where ROLES2_MODULEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES2_MODULE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES2_MODULE_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES2_MODULE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES2_MODULE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES2_MODULE where ROLES2_MODULEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES2_MODULE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES2_MODULE set LockUserID =auserID ,LockSessionID =null where ROLES2_MODULEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES2_MODULE set LockUserID =null,LockSessionID =aCURSESSION  where ROLES2_MODULEid=aRowID;
     return;
   end if;
 end ;

procedure ROLES2_MODULE_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ROLES2_MODREPORT is select ROLES2_MODREPORT.ROLES2_MODREPORTid ID from ROLES2_MODREPORT where  ROLES2_MODREPORT.ParentStructRowID = aRowid;
row_ROLES2_MODREPORT lch_ROLES2_MODREPORT%ROWTYPE;
begin  
--open lch_ROLES2_MODREPORT;
for row_ROLES2_MODREPORT in lch_ROLES2_MODREPORT
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ROLES2_MODREPORT where ROLES2_MODREPORTid=row_ROLES2_MODREPORT.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES2_MODREPORT;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ROLES2_MODREPORT;
     return;
   end if; 
 end if;  
 ROLES2_MODREPORT_HCL (acursession,row_ROLES2_MODREPORT.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES2_MODREPORT;
   return;
 end if;
end loop;
--close lch_ROLES2_MODREPORT;
end;
aIsLocked :=0;
end;

procedure ROLES2_MODULE_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES2_MODULE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES2_MODULE set LockUserID =null  where ROLES2_MODULEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES2_MODULE set LockSessionID =null  where ROLES2_MODULEid=aRowID;
     return;
   end if;
 end; 

procedure ROLES2_MODULE_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES2_MODULE where ROLES2_MODULEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES2_MODULE');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES2_MODULE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES2_MODULE set securitystyleid =aStyleID where ROLES2_MODULEid = aRowID;
else 
 update ROLES2_MODULE set securitystyleid =aSecurityStyleID where ROLES2_MODULEid = aRowID;
end if; 
end ; 

procedure ROLES2_MODULE_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES2_MODULE where ROLES2_MODULEid=aRowid;
declare cursor pch_ROLES2_MODREPORT  is select ROLES2_MODREPORT.ROLES2_MODREPORTid ID from ROLES2_MODREPORT where  ROLES2_MODREPORT.ParentStructRowID = aRowid;
row_ROLES2_MODREPORT  pch_ROLES2_MODREPORT%ROWTYPE;
begin
--open pch_ROLES2_MODREPORT;
for row_ROLES2_MODREPORT in pch_ROLES2_MODREPORT loop
   ROLES2_MODREPORT_SINIT( acursession,row_ROLES2_MODREPORT.id,assid);
   ROLES2_MODREPORT_propagate( acursession,row_ROLES2_MODREPORT.id);
end loop;
--close pch_ROLES2_MODREPORT;
end;
end;


procedure ROLES2_MODREPORT_BRIEF  (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES2_MODREPORTid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES2_MODREPORT where ROLES2_MODREPORTID=aROLES2_MODREPORTID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES2_MODREPORT where ROLES2_MODREPORTid=aROLES2_MODREPORTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES2_MODREPORT');
    return;
  end if;
  aBRIEF:=func.ROLES2_MODREPORT_BRIEF_F(aROLES2_MODREPORTid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES2_MODREPORT_DELETE /**/ (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES2_MODREPORT where ROLES2_MODREPORTID=aROLES2_MODREPORTID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aROLES2_MODREPORTID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES2_MODREPORT',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES2_MODREPORT');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES2_MODREPORT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES2_MODREPORTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES2_MODREPORT');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODREPORT',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aROLES2_MODREPORTid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_ROLES2_MODREPORT is select  instanceid ID from instance where OwnerPartName ='ROLES2_MODREPORT' and OwnerRowID=aROLES2_MODREPORTid;
row_ROLES2_MODREPORT  chld_ROLES2_MODREPORT%ROWTYPE;
begin
--open chld_ROLES2_MODREPORT;
for row_ROLES2_MODREPORT in chld_ROLES2_MODREPORT loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES2_MODREPORT.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES2_MODREPORT.id);
end loop;
--close chld_ROLES2_MODREPORT;
end ;
  delete from  ROLES2_MODREPORT 
  where  ROLES2_MODREPORTID = aROLES2_MODREPORTID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Действия и отчеты*/
procedure ROLES2_MODREPORT_SAVE /**/ (
 aCURSESSION CHAR,
 aROLES2_MODREPORTid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Код *//* Код */
,aAllowAction
 NUMBER/* Разрешен *//* Разрешен */
,aCaption
 VARCHAR2/* Надпись *//* Надпись */
,aSequence
 NUMBER/* № п/п *//* № п/п */
,aTheIcon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aIsReport
 NUMBER/* Это отчет *//* Это отчет */
,aselectType
 NUMBER := null /* Вариант выбора *//* Вариант выбора */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES2_MODREPORT where ROLES2_MODREPORTID=aROLES2_MODREPORTID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aROLES2_MODREPORTID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES2_MODREPORT',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES2_MODREPORT');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES2_MODREPORT_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES2_MODREPORTid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES2_MODREPORT');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODREPORT',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aROLES2_MODREPORTid,aLogInstanceID=&gt;aInstanceID);
 update  ROLES2_MODREPORT set ChangeStamp=sysdate
,
  Name=aName
,
  AllowAction=aAllowAction
,
  Caption=aCaption
,
  Sequence=aSequence
,
  TheIcon=aTheIcon
,
  IsReport=aIsReport
,
  selectType=aselectType
  where  ROLES2_MODREPORTID = aROLES2_MODREPORTID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ROLES2_MODULE where ROLES2_MODULEid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES2_MODREPORT',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES2_MODREPORT');
      return;
    end if;
 end if;
 ROLES2_MODULE_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES2_MODREPORT');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'ROLES2_MODREPORT',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aROLES2_MODREPORTid,aLogInstanceID=&gt;aInstanceID);
 insert into   ROLES2_MODREPORT
 (  ROLES2_MODREPORTID 
,ParentStructRowID
,Name

,AllowAction

,Caption

,Sequence

,TheIcon

,IsReport

,selectType

 ) values ( aROLES2_MODREPORTID 
,aParentStructRowID
,aName

,aAllowAction

,aCaption

,aSequence

,aTheIcon

,aIsReport

,aselectType

 ); 
 ROLES2_MODREPORT_SINIT( aCURSESSION,aROLES2_MODREPORTid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ROLES2_MODREPORT_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ROLES2_MODREPORT where  ROLES2_MODREPORTid=aRowID;
  aParentTable := 'ROLES2_MODULE';
 end; 

procedure ROLES2_MODREPORT_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES2_MODREPORT_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES2_MODREPORT_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES2_MODREPORT_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES2_MODREPORT_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES2_MODREPORT');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES2_MODREPORT set LockUserID =auserID ,LockSessionID =null where ROLES2_MODREPORTid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES2_MODREPORT set LockUserID =null,LockSessionID =aCURSESSION  where ROLES2_MODREPORTid=aRowID;
     return;
   end if;
 end ;

procedure ROLES2_MODREPORT_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES2_MODREPORT_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES2_MODREPORT_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES2_MODREPORT set LockUserID =null  where ROLES2_MODREPORTid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES2_MODREPORT set LockSessionID =null  where ROLES2_MODREPORTid=aRowID;
     return;
   end if;
 end; 

procedure ROLES2_MODREPORT_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES2_MODREPORT');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES2_MODREPORT_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES2_MODREPORT set securitystyleid =aStyleID where ROLES2_MODREPORTid = aRowID;
else 
 update ROLES2_MODREPORT set securitystyleid =aSecurityStyleID where ROLES2_MODREPORTid = aRowID;
end if; 
end ; 

procedure ROLES2_MODREPORT_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES2_MODREPORT where ROLES2_MODREPORTid=aRowid;
end;


procedure ROLES_DOC_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_DOCid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_DOC where ROLES_DOCid=aROLES_DOCID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_DOC');
    return;
  end if;
  aBRIEF:=func.ROLES_DOC_BRIEF_F(aROLES_DOCid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_DOC_DELETE /**/ (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_DOC where ROLES_DOCid=aROLES_DOCID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_DOC',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_DOC');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DOC_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DOCid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DOC');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_ROLES_DOC_STATE is select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aROLES_DOCid;
    child_ROLES_DOC_STATE_rec  child_ROLES_DOC_STATE%ROWTYPE;
    begin
    --open child_ROLES_DOC_STATE;
      for child_ROLES_DOC_STATE_rec in child_ROLES_DOC_STATE loop
      ROLES_DOC_STATE_DELETE (acursession,child_ROLES_DOC_STATE_rec.id,aInstanceid);
      end loop;
      --close child_ROLES_DOC_STATE;
    end ;
declare cursor chld_ROLES_DOC is select  instanceid ID from instance where OwnerPartName ='ROLES_DOC' and OwnerRowID=aROLES_DOCid;
row_ROLES_DOC  chld_ROLES_DOC%ROWTYPE;
begin
--open chld_ROLES_DOC;
for row_ROLES_DOC in chld_ROLES_DOC loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_DOC.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_DOC.id);
end loop;
--close chld_ROLES_DOC;
end ;
  delete from  ROLES_DOC 
  where  ROLES_DOCID = aROLES_DOCID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные документы*/
procedure ROLES_DOC_SAVE /**/ (
 aCURSESSION CHAR,
 aROLES_DOCid CHAR,
aInstanceID CHAR 
,aThe_Document CHAR/* Тип документа *//* Тип документа */
,aThe_Denied
 NUMBER := null /* Запрещен *//* Запрещен */
,aAllowDeleteDoc
 NUMBER/* Разрешено удаление *//* Разрешено удаление */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DOC where ROLES_DOCID=aROLES_DOCID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_DOC where ROLES_DOCid=aROLES_DOCID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_DOC',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_DOC');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DOC_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DOCid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC');
    return;
  end if;
 -- update row  --
 update  ROLES_DOC set ChangeStamp=sysdate
,
  The_Document=aThe_Document
,
  The_Denied=aThe_Denied
,
  AllowDeleteDoc=aAllowDeleteDoc
  where  ROLES_DOCID = aROLES_DOCID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DOC where InstanceID=aInstanceID 
 and The_Document=aThe_Document;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DOC');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_DOC',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_DOC');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC');
    return;
  end if;
 insert into   ROLES_DOC
 (  ROLES_DOCID 
,InstanceID
,The_Document

,The_Denied

,AllowDeleteDoc

 ) values ( aROLES_DOCID 
,aInstanceID
,aThe_Document

,aThe_Denied

,aAllowDeleteDoc

 ); 
 ROLES_DOC_SINIT( aCURSESSION,aROLES_DOCid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_DOC where InstanceID=aInstanceID 
 and The_Document=aThe_Document;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DOC');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_DOC_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_DOC where  ROLES_DOCid=aRowID;
 end; 

procedure ROLES_DOC_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DOC where ROLES_DOCid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_DOC_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_DOC_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_DOC_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_DOC_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_DOC where ROLES_DOCid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_DOC');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_DOC set LockUserID =auserID ,LockSessionID =null where ROLES_DOCid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DOC set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DOCid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_DOC_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_ROLES_DOC_STATE is select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aRowid;
row_ROLES_DOC_STATE lch_ROLES_DOC_STATE%ROWTYPE;
begin  
--open lch_ROLES_DOC_STATE;
for row_ROLES_DOC_STATE in lch_ROLES_DOC_STATE
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from ROLES_DOC_STATE where ROLES_DOC_STATEid=row_ROLES_DOC_STATE.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_ROLES_DOC_STATE;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_ROLES_DOC_STATE;
     return;
   end if; 
 end if;  
 ROLES_DOC_STATE_HCL (acursession,row_ROLES_DOC_STATE.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_ROLES_DOC_STATE;
   return;
 end if;
end loop;
--close lch_ROLES_DOC_STATE;
end;
aIsLocked :=0;
end;

procedure ROLES_DOC_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_DOC_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DOC set LockUserID =null  where ROLES_DOCid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DOC set LockSessionID =null  where ROLES_DOCid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_DOC_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_DOC where ROLES_DOCid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_DOC');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_DOC_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_DOC set securitystyleid =aStyleID where ROLES_DOCid = aRowID;
else 
 update ROLES_DOC set securitystyleid =aSecurityStyleID where ROLES_DOCid = aRowID;
end if; 
end ; 

procedure ROLES_DOC_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_DOC where ROLES_DOCid=aRowid;
declare cursor pch_ROLES_DOC_STATE  is select ROLES_DOC_STATE.ROLES_DOC_STATEid ID from ROLES_DOC_STATE where  ROLES_DOC_STATE.ParentStructRowID = aRowid;
row_ROLES_DOC_STATE  pch_ROLES_DOC_STATE%ROWTYPE;
begin
--open pch_ROLES_DOC_STATE;
for row_ROLES_DOC_STATE in pch_ROLES_DOC_STATE loop
   ROLES_DOC_STATE_SINIT( acursession,row_ROLES_DOC_STATE.id,assid);
   ROLES_DOC_STATE_propagate( acursession,row_ROLES_DOC_STATE.id);
end loop;
--close pch_ROLES_DOC_STATE;
end;
end;


procedure ROLES_DOC_STATE_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_DOC_STATEid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_DOC_STATE where ROLES_DOC_STATEid=aROLES_DOC_STATEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_DOC_STATE');
    return;
  end if;
  aBRIEF:=func.ROLES_DOC_STATE_BRIEF_F(aROLES_DOC_STATEid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_DOC_STATE_DELETE /**/ (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aROLES_DOC_STATEID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_DOC_STATE',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_DOC_STATE');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DOC_STATE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DOC_STATEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_DOC_STATE is select  instanceid ID from instance where OwnerPartName ='ROLES_DOC_STATE' and OwnerRowID=aROLES_DOC_STATEid;
row_ROLES_DOC_STATE  chld_ROLES_DOC_STATE%ROWTYPE;
begin
--open chld_ROLES_DOC_STATE;
for row_ROLES_DOC_STATE in chld_ROLES_DOC_STATE loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_DOC_STATE.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_DOC_STATE.id);
end loop;
--close chld_ROLES_DOC_STATE;
end ;
  delete from  ROLES_DOC_STATE 
  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные состояния*/
procedure ROLES_DOC_STATE_SAVE /**/ (
 aCURSESSION CHAR,
 aROLES_DOC_STATEid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aThe_State CHAR := null /* Состояние *//* Состояние */
,aThe_Mode CHAR := null /* Режим *//* Режим */
,aAllowDelete
 NUMBER/* Можно удалять *//* Можно удалять */
,aStateChangeDisabled
 NUMBER/* Запрещена смена состояния *//* Запрещена смена состояния */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DOC_STATE where ROLES_DOC_STATEID=aROLES_DOC_STATEID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aROLES_DOC_STATEID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_DOC_STATE',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_DOC_STATE');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DOC_STATE_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DOC_STATEid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
 -- update row  --
 update  ROLES_DOC_STATE set ChangeStamp=sysdate
,
  The_State=aThe_State
,
  The_Mode=aThe_Mode
,
  AllowDelete=aAllowDelete
,
  StateChangeDisabled=aStateChangeDisabled
  where  ROLES_DOC_STATEID = aROLES_DOC_STATEID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from ROLES_DOC where ROLES_DOCid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_DOC_STATE',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_DOC_STATE');
      return;
    end if;
 end if;
 ROLES_DOC_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DOC_STATE');
    return;
  end if;
 insert into   ROLES_DOC_STATE
 (  ROLES_DOC_STATEID 
,ParentStructRowID
,The_State

,The_Mode

,AllowDelete

,StateChangeDisabled

 ) values ( aROLES_DOC_STATEID 
,aParentStructRowID
,aThe_State

,aThe_Mode

,aAllowDelete

,aStateChangeDisabled

 ); 
 ROLES_DOC_STATE_SINIT( aCURSESSION,aROLES_DOC_STATEid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ROLES_DOC_STATE_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from ROLES_DOC_STATE where  ROLES_DOC_STATEid=aRowID;
  aParentTable := 'ROLES_DOC';
 end; 

procedure ROLES_DOC_STATE_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_DOC_STATE_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_DOC_STATE_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_DOC_STATE_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_DOC_STATE_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_DOC_STATE');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_DOC_STATE set LockUserID =auserID ,LockSessionID =null where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DOC_STATE set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_DOC_STATE_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_DOC_STATE_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_DOC_STATE_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DOC_STATE set LockUserID =null  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DOC_STATE set LockSessionID =null  where ROLES_DOC_STATEid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_DOC_STATE_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_DOC_STATE');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_DOC_STATE_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_DOC_STATE set securitystyleid =aStyleID where ROLES_DOC_STATEid = aRowID;
else 
 update ROLES_DOC_STATE set securitystyleid =aSecurityStyleID where ROLES_DOC_STATEid = aRowID;
end if; 
end ; 

procedure ROLES_DOC_STATE_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_DOC_STATE where ROLES_DOC_STATEid=aRowid;
end;


procedure ROLES_REPORTS_BRIEF  (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_REPORTSid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_REPORTS where ROLES_REPORTSid=aROLES_REPORTSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_REPORTS');
    return;
  end if;
  aBRIEF:=func.ROLES_REPORTS_BRIEF_F(aROLES_REPORTSid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_REPORTS_DELETE /**/ (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_REPORTS where ROLES_REPORTSid=aROLES_REPORTSID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_REPORTS',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_REPORTS');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_REPORTS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_REPORTSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_REPORTS');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_REPORTS is select  instanceid ID from instance where OwnerPartName ='ROLES_REPORTS' and OwnerRowID=aROLES_REPORTSid;
row_ROLES_REPORTS  chld_ROLES_REPORTS%ROWTYPE;
begin
--open chld_ROLES_REPORTS;
for row_ROLES_REPORTS in chld_ROLES_REPORTS loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_REPORTS.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_REPORTS.id);
end loop;
--close chld_ROLES_REPORTS;
end ;
  delete from  ROLES_REPORTS 
  where  ROLES_REPORTSID = aROLES_REPORTSID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отчёты*/
procedure ROLES_REPORTS_SAVE /**/ (
 aCURSESSION CHAR,
 aROLES_REPORTSid CHAR,
aInstanceID CHAR 
,aThe_Report CHAR/* Отчёт *//* Отчёт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_REPORTS where ROLES_REPORTSID=aROLES_REPORTSID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_REPORTS where ROLES_REPORTSid=aROLES_REPORTSID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_REPORTS',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_REPORTS');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_REPORTS_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_REPORTSid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_REPORTS');
    return;
  end if;
 -- update row  --
 update  ROLES_REPORTS set ChangeStamp=sysdate
,
  The_Report=aThe_Report
  where  ROLES_REPORTSID = aROLES_REPORTSID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_REPORTS',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_REPORTS');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_REPORTS');
    return;
  end if;
 insert into   ROLES_REPORTS
 (  ROLES_REPORTSID 
,InstanceID
,The_Report

 ) values ( aROLES_REPORTSID 
,aInstanceID
,aThe_Report

 ); 
 ROLES_REPORTS_SINIT( aCURSESSION,aROLES_REPORTSid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure ROLES_REPORTS_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_REPORTS where  ROLES_REPORTSid=aRowID;
 end; 

procedure ROLES_REPORTS_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_REPORTS where ROLES_REPORTSid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_REPORTS_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_REPORTS_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_REPORTS_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_REPORTS_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_REPORTS where ROLES_REPORTSid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_REPORTS');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_REPORTS set LockUserID =auserID ,LockSessionID =null where ROLES_REPORTSid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_REPORTS set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_REPORTSid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_REPORTS_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_REPORTS_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_REPORTS_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_REPORTS set LockUserID =null  where ROLES_REPORTSid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_REPORTS set LockSessionID =null  where ROLES_REPORTSid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_REPORTS_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_REPORTS where ROLES_REPORTSid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_REPORTS');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_REPORTS_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_REPORTS set securitystyleid =aStyleID where ROLES_REPORTSid = aRowID;
else 
 update ROLES_REPORTS set securitystyleid =aSecurityStyleID where ROLES_REPORTSid = aRowID;
end if; 
end ; 

procedure ROLES_REPORTS_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_REPORTS where ROLES_REPORTSid=aRowid;
end;


procedure ROLES_USER_BRIEF  (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_USERid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_USER where ROLES_USERid=aROLES_USERID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_USER');
    return;
  end if;
  aBRIEF:=func.ROLES_USER_BRIEF_F(aROLES_USERid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_USER_DELETE /*Пользователи*/ (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_USER where ROLES_USERid=aROLES_USERID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_USER',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_USER');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_USER_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_USERid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_USER');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_USER is select  instanceid ID from instance where OwnerPartName ='ROLES_USER' and OwnerRowID=aROLES_USERid;
row_ROLES_USER  chld_ROLES_USER%ROWTYPE;
begin
--open chld_ROLES_USER;
for row_ROLES_USER in chld_ROLES_USER loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_USER.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_USER.id);
end loop;
--close chld_ROLES_USER;
end ;
  delete from  ROLES_USER 
  where  ROLES_USERID = aROLES_USERID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пользователи*/
procedure ROLES_USER_SAVE /*Пользователи*/ (
 aCURSESSION CHAR,
 aROLES_USERid CHAR,
aInstanceID CHAR 
,aTheUser CHAR/* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_USER where ROLES_USERID=aROLES_USERID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_USER where ROLES_USERid=aROLES_USERID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_USER',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_USER');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_USER_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_USERid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_USER');
    return;
  end if;
 -- update row  --
 update  ROLES_USER set ChangeStamp=sysdate
,
  TheUser=aTheUser
  where  ROLES_USERID = aROLES_USERID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;
 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_USER',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_USER');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_USER');
    return;
  end if;
 insert into   ROLES_USER
 (  ROLES_USERID 
,InstanceID
,TheUser

 ) values ( aROLES_USERID 
,aInstanceID
,aTheUser

 ); 
 ROLES_USER_SINIT( aCURSESSION,aROLES_USERid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;
 select Count(*) into aUniqueRowCount from ROLES_USER where InstanceID=aInstanceID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_USER');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_USER_PARENT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_USER where  ROLES_USERid=aRowID;
 end; 

procedure ROLES_USER_ISLOCKED /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_USER where ROLES_USERid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_USER_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_USER_LOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_USER_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_USER_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_USER where ROLES_USERid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_USER');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_USER set LockUserID =auserID ,LockSessionID =null where ROLES_USERid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_USER set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_USERid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_USER_HCL /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_USER_UNLOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_USER_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_USER set LockUserID =null  where ROLES_USERid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_USER set LockSessionID =null  where ROLES_USERid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_USER_SINIT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_USER where ROLES_USERid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_USER');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_USER_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_USER set securitystyleid =aStyleID where ROLES_USERid = aRowID;
else 
 update ROLES_USER set securitystyleid =aSecurityStyleID where ROLES_USERid = aRowID;
end if; 
end ; 

procedure ROLES_USER_propagate /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_USER where ROLES_USERid=aRowid;
end;


procedure ROLES_MAP_BRIEF  (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_MAPid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_MAP where ROLES_MAPid=aROLES_MAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_MAP');
    return;
  end if;
  aBRIEF:=func.ROLES_MAP_BRIEF_F(aROLES_MAPid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_MAP_DELETE /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_MAP where ROLES_MAPid=aROLES_MAPID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_MAP',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_MAP');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_MAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_MAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_MAP');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_MAP is select  instanceid ID from instance where OwnerPartName ='ROLES_MAP' and OwnerRowID=aROLES_MAPid;
row_ROLES_MAP  chld_ROLES_MAP%ROWTYPE;
begin
--open chld_ROLES_MAP;
for row_ROLES_MAP in chld_ROLES_MAP loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_MAP.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_MAP.id);
end loop;
--close chld_ROLES_MAP;
end ;
  delete from  ROLES_MAP 
  where  ROLES_MAPID = aROLES_MAPID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение на группы*/
procedure ROLES_MAP_SAVE /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aROLES_MAPid CHAR,
aInstanceID CHAR 
,aTheGroup CHAR/* Группа *//* Группа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_MAP where ROLES_MAPID=aROLES_MAPID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_MAP where ROLES_MAPid=aROLES_MAPID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_MAP',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_MAP');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_MAP_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_MAPid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_MAP');
    return;
  end if;
 -- update row  --
 update  ROLES_MAP set ChangeStamp=sysdate
,
  TheGroup=aTheGroup
  where  ROLES_MAPID = aROLES_MAPID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_MAP where InstanceID=aInstanceID 
 and TheGroup=aTheGroup;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_MAP');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_MAP',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_MAP');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_MAP');
    return;
  end if;
 insert into   ROLES_MAP
 (  ROLES_MAPID 
,InstanceID
,TheGroup

 ) values ( aROLES_MAPID 
,aInstanceID
,aTheGroup

 ); 
 ROLES_MAP_SINIT( aCURSESSION,aROLES_MAPid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from ROLES_MAP where InstanceID=aInstanceID 
 and TheGroup=aTheGroup;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_MAP');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_MAP_PARENT /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_MAP where  ROLES_MAPid=aRowID;
 end; 

procedure ROLES_MAP_ISLOCKED /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_MAP where ROLES_MAPid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_MAP_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_MAP_LOCK /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_MAP_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_MAP_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_MAP where ROLES_MAPid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_MAP');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_MAP set LockUserID =auserID ,LockSessionID =null where ROLES_MAPid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_MAP set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_MAPid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_MAP_HCL /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_MAP_UNLOCK /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_MAP_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_MAP set LockUserID =null  where ROLES_MAPid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_MAP set LockSessionID =null  where ROLES_MAPid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_MAP_SINIT /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_MAP where ROLES_MAPid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_MAP');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_MAP_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_MAP set securitystyleid =aStyleID where ROLES_MAPid = aRowID;
else 
 update ROLES_MAP set securitystyleid =aSecurityStyleID where ROLES_MAPid = aRowID;
end if; 
end ; 

procedure ROLES_MAP_propagate /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_MAP where ROLES_MAPid=aRowid;
end;


procedure ROLES_DEF_BRIEF  (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aROLES_DEFid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from ROLES_DEF where ROLES_DEFid=aROLES_DEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=ROLES_DEF');
    return;
  end if;
  aBRIEF:=func.ROLES_DEF_BRIEF_F(aROLES_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure ROLES_DEF_DELETE /*Определение роли*/ (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from ROLES_DEF where ROLES_DEFid=aROLES_DEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:ROLES_DEF',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=ROLES_DEF');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=ROLES_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_ROLES_DEF is select  instanceid ID from instance where OwnerPartName ='ROLES_DEF' and OwnerRowID=aROLES_DEFid;
row_ROLES_DEF  chld_ROLES_DEF%ROWTYPE;
begin
--open chld_ROLES_DEF;
for row_ROLES_DEF in chld_ROLES_DEF loop
 Kernel.INSTANCE_OWNER (acursession,row_ROLES_DEF.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_ROLES_DEF.id);
end loop;
--close chld_ROLES_DEF;
end ;
  delete from  ROLES_DEF 
  where  ROLES_DEFID = aROLES_DEFID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Определение роли*/
procedure ROLES_DEF_SAVE /*Определение роли*/ (
 aCURSESSION CHAR,
 aROLES_DEFid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aAllObjects
 NUMBER/* Вся фирма *//* Вся фирма */
,aColegsObject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,aSubStructObjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from ROLES_DEF where ROLES_DEFID=aROLES_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from ROLES_DEF where ROLES_DEFid=aROLES_DEFID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:ROLES_DEF',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=ROLES_DEF');
      return;
    end if;
  end if;
 --  verify lock  --
 ROLES_DEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aROLES_DEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DEF');
    return;
  end if;
 -- update row  --
 update  ROLES_DEF set ChangeStamp=sysdate
,
  name=aname
,
  AllObjects=aAllObjects
,
  ColegsObject=aColegsObject
,
  SubStructObjects=aSubStructObjects
  where  ROLES_DEFID = aROLES_DEFID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ROLES_DEF where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DEF');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:ROLES_DEF',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=ROLES_DEF');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=ROLES_DEF');
    return;
  end if;
select Count(*) into existsCnt from ROLES_DEF where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;ROLES_DEF&gt;');
    return;
 End if;
 insert into   ROLES_DEF
 (  ROLES_DEFID 
,InstanceID
,name

,AllObjects

,ColegsObject

,SubStructObjects

 ) values ( aROLES_DEFID 
,aInstanceID
,aname

,aAllObjects

,aColegsObject

,aSubStructObjects

 ); 
 ROLES_DEF_SINIT( aCURSESSION,aROLES_DEFid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from ROLES_DEF where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=ROLES_DEF');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure ROLES_DEF_PARENT /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from ROLES_DEF where  ROLES_DEFid=aRowID;
 end; 

procedure ROLES_DEF_ISLOCKED /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from ROLES_DEF where ROLES_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  ROLES_DEF_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin ROLES.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure ROLES_DEF_LOCK /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 ROLES_DEF_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  ROLES_DEF_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from ROLES_DEF where ROLES_DEFid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=ROLES_DEF');
    return;
  end if;
   if  aLockMode =2  
   then   
    update ROLES_DEF set LockUserID =auserID ,LockSessionID =null where ROLES_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update ROLES_DEF set LockUserID =null,LockSessionID =aCURSESSION  where ROLES_DEFid=aRowID;
     return;
   end if;
 end ;

procedure ROLES_DEF_HCL /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure ROLES_DEF_UNLOCK /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 ROLES_DEF_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update ROLES_DEF set LockUserID =null  where ROLES_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update ROLES_DEF set LockSessionID =null  where ROLES_DEFid=aRowID;
     return;
   end if;
 end; 

procedure ROLES_DEF_SINIT /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from ROLES_DEF where ROLES_DEFid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =ROLES_DEF');
    return;
  end if;
if aSecurityStyleID is null then
 ROLES_DEF_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update ROLES_DEF set securitystyleid =aStyleID where ROLES_DEFid = aRowID;
else 
 update ROLES_DEF set securitystyleid =aSecurityStyleID where ROLES_DEFid = aRowID;
end if; 
end ; 

procedure ROLES_DEF_propagate /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from ROLES_DEF where ROLES_DEFid=aRowid;
end;
end ROLES;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totask" BlockCode=" create or replace package body totask as

procedure totask_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='totask'
then
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure totask_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'totask'
 then
 aIsLocked :=0;
end;
procedure totask_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'totask'
 then
   assid:= 'do nothing';
 end if;
end;
end totask;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZUsers" BlockCode=" create or replace package body MTZUsers as

procedure MTZUsers_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZUsers'
then
declare cursor child_Users is select Users.Usersid ID from Users where  Users.InstanceID = ainstanceid;
row_Users  child_Users%ROWTYPE;
begin
--open child_Users;
for row_Users in child_Users loop
 Users_DELETE (acursession,row_Users.id,aInstanceID);
end loop;
--close child_Users;
end;
declare cursor child_Groups is select Groups.Groupsid ID from Groups where  Groups.InstanceID = ainstanceid;
row_Groups  child_Groups%ROWTYPE;
begin
--open child_Groups;
for row_Groups in child_Groups loop
 Groups_DELETE (acursession,row_Groups.id,aInstanceID);
end loop;
--close child_Groups;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZUsers_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZUsers'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_Users is select Users.Usersid ID from Users where  Users.InstanceID = arowid;
ROW_Users  lch_Users%ROWTYPE;
begin
--open lch_Users;
for row_Users in lch_Users loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Users where Usersid=row_Users.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Users;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Users;
     return;
   end if; 
 end if; 
 Users_HCL (acursession,ROW_Users.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Users;
   return;
 end if;
 end loop;
--close lch_Users;
end;
declare cursor lch_Groups is select Groups.Groupsid ID from Groups where  Groups.InstanceID = arowid;
ROW_Groups  lch_Groups%ROWTYPE;
begin
--open lch_Groups;
for row_Groups in lch_Groups loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Groups where Groupsid=row_Groups.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Groups;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Groups;
     return;
   end if; 
 end if; 
 Groups_HCL (acursession,ROW_Groups.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Groups;
   return;
 end if;
 end loop;
--close lch_Groups;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZUsers_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZUsers'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_Users is select Users.Usersid id from Users where  Users.InstanceID = arowid;
row_Users  pch_Users%ROWTYPE;
begin
--open pch_Users;
for row_Users in  pch_Users loop
 Users_SINIT( acursession,row_Users.id,assid);
 Users_propagate( acursession,row_Users.id);
end loop;
--close pch_Users;
end;
declare cursor pch_Groups is select Groups.Groupsid id from Groups where  Groups.InstanceID = arowid;
row_Groups  pch_Groups%ROWTYPE;
begin
--open pch_Groups;
for row_Groups in  pch_Groups loop
 Groups_SINIT( acursession,row_Groups.id,assid);
 Groups_propagate( acursession,row_Groups.id);
end loop;
--close pch_Groups;
end;
 end if; 
end;


procedure Users_BRIEF  (
 aCURSESSION CHAR,
 aUsersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aUsersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Users where Usersid=aUsersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Users');
    return;
  end if;
  aBRIEF:=func.Users_BRIEF_F(aUsersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Users_DELETE /*Пользователи*/ (
 aCURSESSION CHAR,
 aUsersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Users where Usersid=aUsersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Users',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Users');
      return;
    end if;
  end if;
 --  verify lock  --
 Users_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aUsersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Users');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Users is select  instanceid ID from instance where OwnerPartName ='Users' and OwnerRowID=aUsersid;
row_Users  chld_Users%ROWTYPE;
begin
--open chld_Users;
for row_Users in chld_Users loop
 Kernel.INSTANCE_OWNER (acursession,row_Users.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Users.id);
end loop;
--close chld_Users;
end ;
  delete from  Users 
  where  UsersID = aUsersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пользователи*/
procedure Users_SAVE /*Пользователи*/ (
 aCURSESSION CHAR,
 aUsersid CHAR,
aInstanceID CHAR 
,aFamily
 VARCHAR2/* Фамилия *//* Фамилия */
,aName
 VARCHAR2/* Имя *//* Имя */
,aSurName
 VARCHAR2/* Отчество *//* Отчество */
,aLogin
 VARCHAR2/* Имя для входа *//* Имя для входа */
,aPassword VARCHAR2 := null /* Пароль *//* Пароль */
,aDomaiName
 VARCHAR2 := null /* Доменное имя *//* Доменное имя */
,aEMail VARCHAR2 := null /* e-mail *//* e-mail */
,aPhone
 VARCHAR2 := null /* Телефон *//* Телефон */
,aLocalPhone
 VARCHAR2 := null /* Местный телефон *//* Местный телефон */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Users where UsersID=aUsersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Users where Usersid=aUsersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Users',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Users');
      return;
    end if;
  end if;
 --  verify lock  --
 Users_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aUsersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Users');
    return;
  end if;
 -- update row  --
 update  Users set ChangeStamp=sysdate
,
  Family=aFamily
,
  Name=aName
,
  SurName=aSurName
,
  Login=aLogin
,
  Password=aPassword
,
  DomaiName=aDomaiName
,
  EMail=aEMail
,
  Phone=aPhone
,
  LocalPhone=aLocalPhone
  where  UsersID = aUsersID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Users where InstanceID=aInstanceID 
 and Login=aLogin;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Users');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Users',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Users');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Users');
    return;
  end if;
 insert into   Users
 (  UsersID 
,InstanceID
,Family

,Name

,SurName

,Login

,Password

,DomaiName

,EMail

,Phone

,LocalPhone

 ) values ( aUsersID 
,aInstanceID
,aFamily

,aName

,aSurName

,aLogin

,aPassword

,aDomaiName

,aEMail

,aPhone

,aLocalPhone

 ); 
 Users_SINIT( aCURSESSION,aUsersid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Users where InstanceID=aInstanceID 
 and Login=aLogin;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Users');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure Users_PARENT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Users where  Usersid=aRowID;
 end; 

procedure Users_ISLOCKED /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Users where Usersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Users_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZUsers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Users_LOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Users_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Users_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Users where Usersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Users');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Users set LockUserID =auserID ,LockSessionID =null where Usersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Users set LockUserID =null,LockSessionID =aCURSESSION  where Usersid=aRowID;
     return;
   end if;
 end ;

procedure Users_HCL /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Users_UNLOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Users_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Users set LockUserID =null  where Usersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Users set LockSessionID =null  where Usersid=aRowID;
     return;
   end if;
 end; 

procedure Users_SINIT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Users where Usersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Users');
    return;
  end if;
if aSecurityStyleID is null then
 Users_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Users set securitystyleid =aStyleID where Usersid = aRowID;
else 
 update Users set securitystyleid =aSecurityStyleID where Usersid = aRowID;
end if; 
end ; 

procedure Users_propagate /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Users where Usersid=aRowid;
end;


procedure Groups_BRIEF  (
 aCURSESSION CHAR,
 aGroupsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGroupsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Groups where Groupsid=aGroupsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Groups');
    return;
  end if;
  aBRIEF:=func.Groups_BRIEF_F(aGroupsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Groups_DELETE /*Группы*/ (
 aCURSESSION CHAR,
 aGroupsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Groups where Groupsid=aGroupsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Groups',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Groups');
      return;
    end if;
  end if;
 --  verify lock  --
 Groups_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGroupsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Groups');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_GroupUser is select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aGroupsid;
    child_GroupUser_rec  child_GroupUser%ROWTYPE;
    begin
    --open child_GroupUser;
      for child_GroupUser_rec in child_GroupUser loop
      GroupUser_DELETE (acursession,child_GroupUser_rec.id,aInstanceid);
      end loop;
      --close child_GroupUser;
    end ;
declare cursor chld_Groups is select  instanceid ID from instance where OwnerPartName ='Groups' and OwnerRowID=aGroupsid;
row_Groups  chld_Groups%ROWTYPE;
begin
--open chld_Groups;
for row_Groups in chld_Groups loop
 Kernel.INSTANCE_OWNER (acursession,row_Groups.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Groups.id);
end loop;
--close chld_Groups;
end ;
  delete from  Groups 
  where  GroupsID = aGroupsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Группы*/
procedure Groups_SAVE /*Группы*/ (
 aCURSESSION CHAR,
 aGroupsid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aADGroup
 VARCHAR2 := null /* Группа AD *//* Группа AD */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Groups where GroupsID=aGroupsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Groups where Groupsid=aGroupsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Groups',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Groups');
      return;
    end if;
  end if;
 --  verify lock  --
 Groups_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGroupsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Groups');
    return;
  end if;
 -- update row  --
 update  Groups set ChangeStamp=sysdate
,
  Name=aName
,
  ADGroup=aADGroup
  where  GroupsID = aGroupsID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Groups where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Groups');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Groups',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Groups');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Groups');
    return;
  end if;
 insert into   Groups
 (  GroupsID 
,InstanceID
,Name

,ADGroup

 ) values ( aGroupsID 
,aInstanceID
,aName

,aADGroup

 ); 
 Groups_SINIT( aCURSESSION,aGroupsid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Groups where InstanceID=aInstanceID 
 and Name=aName;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Groups');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure Groups_PARENT /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Groups where  Groupsid=aRowID;
 end; 

procedure Groups_ISLOCKED /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Groups where Groupsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Groups_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZUsers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Groups_LOCK /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Groups_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Groups_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Groups where Groupsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Groups');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Groups set LockUserID =auserID ,LockSessionID =null where Groupsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Groups set LockUserID =null,LockSessionID =aCURSESSION  where Groupsid=aRowID;
     return;
   end if;
 end ;

procedure Groups_HCL /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_GroupUser is select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aRowid;
row_GroupUser lch_GroupUser%ROWTYPE;
begin  
--open lch_GroupUser;
for row_GroupUser in lch_GroupUser
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from GroupUser where GroupUserid=row_GroupUser.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_GroupUser;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_GroupUser;
     return;
   end if; 
 end if;  
 GroupUser_HCL (acursession,row_GroupUser.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_GroupUser;
   return;
 end if;
end loop;
--close lch_GroupUser;
end;
aIsLocked :=0;
end;

procedure Groups_UNLOCK /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Groups_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Groups set LockUserID =null  where Groupsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Groups set LockSessionID =null  where Groupsid=aRowID;
     return;
   end if;
 end; 

procedure Groups_SINIT /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Groups where Groupsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Groups');
    return;
  end if;
if aSecurityStyleID is null then
 Groups_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Groups set securitystyleid =aStyleID where Groupsid = aRowID;
else 
 update Groups set securitystyleid =aSecurityStyleID where Groupsid = aRowID;
end if; 
end ; 

procedure Groups_propagate /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Groups where Groupsid=aRowid;
declare cursor pch_GroupUser  is select GroupUser.GroupUserid ID from GroupUser where  GroupUser.ParentStructRowID = aRowid;
row_GroupUser  pch_GroupUser%ROWTYPE;
begin
--open pch_GroupUser;
for row_GroupUser in pch_GroupUser loop
   GroupUser_SINIT( acursession,row_GroupUser.id,assid);
   GroupUser_propagate( acursession,row_GroupUser.id);
end loop;
--close pch_GroupUser;
end;
end;


procedure GroupUser_BRIEF  (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aGroupUserid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from GroupUser where GroupUserid=aGroupUserID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=GroupUser');
    return;
  end if;
  aBRIEF:=func.GroupUser_BRIEF_F(aGroupUserid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure GroupUser_DELETE /*Состав группы*/ (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from GroupUser where GroupUserid=aGroupUserID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:GroupUser',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=GroupUser');
      return;
    end if;
  end if;
 --  verify lock  --
 GroupUser_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGroupUserid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=GroupUser');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_GroupUser is select  instanceid ID from instance where OwnerPartName ='GroupUser' and OwnerRowID=aGroupUserid;
row_GroupUser  chld_GroupUser%ROWTYPE;
begin
--open chld_GroupUser;
for row_GroupUser in chld_GroupUser loop
 Kernel.INSTANCE_OWNER (acursession,row_GroupUser.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_GroupUser.id);
end loop;
--close chld_GroupUser;
end ;
  delete from  GroupUser 
  where  GroupUserID = aGroupUserID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состав группы*/
procedure GroupUser_SAVE /*Состав группы*/ (
 aCURSESSION CHAR,
 aGroupUserid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aTheUser CHAR/* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from GroupUser where GroupUserID=aGroupUserID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from GroupUser where GroupUserid=aGroupUserID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:GroupUser',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=GroupUser');
      return;
    end if;
  end if;
 --  verify lock  --
 GroupUser_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aGroupUserid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GroupUser');
    return;
  end if;
 -- update row  --
 update  GroupUser set ChangeStamp=sysdate
,
  TheUser=aTheUser
  where  GroupUserID = aGroupUserID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from GroupUser where ParentStructRowID=aParentStructRowID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=GroupUser');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from Groups where Groupsid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:GroupUser',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=GroupUser');
      return;
    end if;
 end if;
 Groups_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=GroupUser');
    return;
  end if;
 insert into   GroupUser
 (  GroupUserID 
,ParentStructRowID
,TheUser

 ) values ( aGroupUserID 
,aParentStructRowID
,aTheUser

 ); 
 GroupUser_SINIT( aCURSESSION,aGroupUserid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from GroupUser where ParentStructRowID=aParentStructRowID 
 and TheUser=aTheUser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=GroupUser');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure GroupUser_PARENT /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from GroupUser where  GroupUserid=aRowID;
  aParentTable := 'Groups';
 end; 

procedure GroupUser_ISLOCKED /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from GroupUser where GroupUserid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  GroupUser_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZUsers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure GroupUser_LOCK /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 GroupUser_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  GroupUser_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from GroupUser where GroupUserid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=GroupUser');
    return;
  end if;
   if  aLockMode =2  
   then   
    update GroupUser set LockUserID =auserID ,LockSessionID =null where GroupUserid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update GroupUser set LockUserID =null,LockSessionID =aCURSESSION  where GroupUserid=aRowID;
     return;
   end if;
 end ;

procedure GroupUser_HCL /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure GroupUser_UNLOCK /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 GroupUser_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update GroupUser set LockUserID =null  where GroupUserid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update GroupUser set LockSessionID =null  where GroupUserid=aRowID;
     return;
   end if;
 end; 

procedure GroupUser_SINIT /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from GroupUser where GroupUserid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =GroupUser');
    return;
  end if;
if aSecurityStyleID is null then
 GroupUser_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update GroupUser set securitystyleid =aStyleID where GroupUserid = aRowID;
else 
 update GroupUser set securitystyleid =aSecurityStyleID where GroupUserid = aRowID;
end if; 
end ; 

procedure GroupUser_propagate /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from GroupUser where GroupUserid=aRowid;
end;
end MTZUsers;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tooper" BlockCode=" create or replace package body tooper as

procedure tooper_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tooper'
then
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tooper_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tooper'
 then
 aIsLocked :=0;
end;
procedure tooper_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tooper'
 then
   assid:= 'do nothing';
 end if;
end;
end tooper;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--STDNumerator" BlockCode=" create or replace package body STDNumerator as

procedure STDNumerator_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='STDNumerator'
then
declare cursor child_Num_zones is select Num_zones.Num_zonesid ID from Num_zones where  Num_zones.InstanceID = ainstanceid;
row_Num_zones  child_Num_zones%ROWTYPE;
begin
--open child_Num_zones;
for row_Num_zones in child_Num_zones loop
 Num_zones_DELETE (acursession,row_Num_zones.id,aInstanceID);
end loop;
--close child_Num_zones;
end;
declare cursor child_Num_head is select Num_head.Num_headid ID from Num_head where  Num_head.InstanceID = ainstanceid;
row_Num_head  child_Num_head%ROWTYPE;
begin
--open child_Num_head;
for row_Num_head in child_Num_head loop
 Num_head_DELETE (acursession,row_Num_head.id,aInstanceID);
end loop;
--close child_Num_head;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure STDNumerator_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'STDNumerator'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_Num_zones is select Num_zones.Num_zonesid ID from Num_zones where  Num_zones.InstanceID = arowid;
ROW_Num_zones  lch_Num_zones%ROWTYPE;
begin
--open lch_Num_zones;
for row_Num_zones in lch_Num_zones loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Num_zones where Num_zonesid=row_Num_zones.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Num_zones;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Num_zones;
     return;
   end if; 
 end if; 
 Num_zones_HCL (acursession,ROW_Num_zones.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Num_zones;
   return;
 end if;
 end loop;
--close lch_Num_zones;
end;
declare cursor lch_Num_head is select Num_head.Num_headid ID from Num_head where  Num_head.InstanceID = arowid;
ROW_Num_head  lch_Num_head%ROWTYPE;
begin
--open lch_Num_head;
for row_Num_head in lch_Num_head loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Num_head where Num_headid=row_Num_head.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Num_head;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Num_head;
     return;
   end if; 
 end if; 
 Num_head_HCL (acursession,ROW_Num_head.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Num_head;
   return;
 end if;
 end loop;
--close lch_Num_head;
end;
 end if;
aIsLocked:=0;
end;
procedure STDNumerator_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'STDNumerator'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_Num_zones is select Num_zones.Num_zonesid id from Num_zones where  Num_zones.InstanceID = arowid;
row_Num_zones  pch_Num_zones%ROWTYPE;
begin
--open pch_Num_zones;
for row_Num_zones in  pch_Num_zones loop
 Num_zones_SINIT( acursession,row_Num_zones.id,assid);
 Num_zones_propagate( acursession,row_Num_zones.id);
end loop;
--close pch_Num_zones;
end;
declare cursor pch_Num_head is select Num_head.Num_headid id from Num_head where  Num_head.InstanceID = arowid;
row_Num_head  pch_Num_head%ROWTYPE;
begin
--open pch_Num_head;
for row_Num_head in  pch_Num_head loop
 Num_head_SINIT( acursession,row_Num_head.id,assid);
 Num_head_propagate( acursession,row_Num_head.id);
end loop;
--close pch_Num_head;
end;
 end if; 
end;


procedure Num_zones_BRIEF  (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aNum_zonesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Num_zones where Num_zonesid=aNum_zonesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Num_zones');
    return;
  end if;
  aBRIEF:=func.Num_zones_BRIEF_F(aNum_zonesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Num_zones_DELETE /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Num_zones where Num_zonesid=aNum_zonesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Num_zones',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Num_zones');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_zones_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_zonesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_zones');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_Num_Values is select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aNum_zonesid;
    child_Num_Values_rec  child_Num_Values%ROWTYPE;
    begin
    --open child_Num_Values;
      for child_Num_Values_rec in child_Num_Values loop
      Num_Values_DELETE (acursession,child_Num_Values_rec.id,aInstanceid);
      end loop;
      --close child_Num_Values;
    end ;
declare cursor chld_Num_zones is select  instanceid ID from instance where OwnerPartName ='Num_zones' and OwnerRowID=aNum_zonesid;
row_Num_zones  chld_Num_zones%ROWTYPE;
begin
--open chld_Num_zones;
for row_Num_zones in chld_Num_zones loop
 Kernel.INSTANCE_OWNER (acursession,row_Num_zones.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Num_zones.id);
end loop;
--close chld_Num_zones;
end ;
  delete from  Num_zones 
  where  Num_zonesID = aNum_zonesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Зоны*/
procedure Num_zones_SAVE /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aNum_zonesid CHAR,
aInstanceID CHAR 
,aZoneMask
 VARCHAR2/* Маска зоны *//* Маска зоны */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_zones where Num_zonesID=aNum_zonesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Num_zones where Num_zonesid=aNum_zonesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Num_zones',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Num_zones');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_zones_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_zonesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_zones');
    return;
  end if;
 -- update row  --
 update  Num_zones set ChangeStamp=sysdate
,
  ZoneMask=aZoneMask
  where  Num_zonesID = aNum_zonesID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Num_zones where InstanceID=aInstanceID 
 and ZoneMask=aZoneMask;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_zones');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Num_zones',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Num_zones');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_zones');
    return;
  end if;
 insert into   Num_zones
 (  Num_zonesID 
,InstanceID
,ZoneMask

 ) values ( aNum_zonesID 
,aInstanceID
,aZoneMask

 ); 
 Num_zones_SINIT( aCURSESSION,aNum_zonesid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from Num_zones where InstanceID=aInstanceID 
 and ZoneMask=aZoneMask;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_zones');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure Num_zones_PARENT /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Num_zones where  Num_zonesid=aRowID;
 end; 

procedure Num_zones_ISLOCKED /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_zones where Num_zonesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Num_zones_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDNumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Num_zones_LOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Num_zones_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Num_zones_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Num_zones where Num_zonesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Num_zones');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Num_zones set LockUserID =auserID ,LockSessionID =null where Num_zonesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_zones set LockUserID =null,LockSessionID =aCURSESSION  where Num_zonesid=aRowID;
     return;
   end if;
 end ;

procedure Num_zones_HCL /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_Num_Values is select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aRowid;
row_Num_Values lch_Num_Values%ROWTYPE;
begin  
--open lch_Num_Values;
for row_Num_Values in lch_Num_Values
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from Num_Values where Num_Valuesid=row_Num_Values.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Num_Values;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_Num_Values;
     return;
   end if; 
 end if;  
 Num_Values_HCL (acursession,row_Num_Values.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Num_Values;
   return;
 end if;
end loop;
--close lch_Num_Values;
end;
aIsLocked :=0;
end;

procedure Num_zones_UNLOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Num_zones_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_zones set LockUserID =null  where Num_zonesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_zones set LockSessionID =null  where Num_zonesid=aRowID;
     return;
   end if;
 end; 

procedure Num_zones_SINIT /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Num_zones where Num_zonesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Num_zones');
    return;
  end if;
if aSecurityStyleID is null then
 Num_zones_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Num_zones set securitystyleid =aStyleID where Num_zonesid = aRowID;
else 
 update Num_zones set securitystyleid =aSecurityStyleID where Num_zonesid = aRowID;
end if; 
end ; 

procedure Num_zones_propagate /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Num_zones where Num_zonesid=aRowid;
declare cursor pch_Num_Values  is select Num_Values.Num_Valuesid ID from Num_Values where  Num_Values.ParentStructRowID = aRowid;
row_Num_Values  pch_Num_Values%ROWTYPE;
begin
--open pch_Num_Values;
for row_Num_Values in pch_Num_Values loop
   Num_Values_SINIT( acursession,row_Num_Values.id,assid);
   Num_Values_propagate( acursession,row_Num_Values.id);
end loop;
--close pch_Num_Values;
end;
end;


procedure Num_Values_BRIEF  (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aNum_Valuesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Num_Values where Num_Valuesid=aNum_ValuesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Num_Values');
    return;
  end if;
  aBRIEF:=func.Num_Values_BRIEF_F(aNum_Valuesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Num_Values_DELETE /*уникальные номера*/ (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Num_Values where Num_Valuesid=aNum_ValuesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Num_Values',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Num_Values');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_Values_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_Valuesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_Values');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Num_Values is select  instanceid ID from instance where OwnerPartName ='Num_Values' and OwnerRowID=aNum_Valuesid;
row_Num_Values  chld_Num_Values%ROWTYPE;
begin
--open chld_Num_Values;
for row_Num_Values in chld_Num_Values loop
 Kernel.INSTANCE_OWNER (acursession,row_Num_Values.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Num_Values.id);
end loop;
--close chld_Num_Values;
end ;
  delete from  Num_Values 
  where  Num_ValuesID = aNum_ValuesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Номера*/
procedure Num_Values_SAVE /*уникальные номера*/ (
 aCURSESSION CHAR,
 aNum_Valuesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_Value
 NUMBER/* Значение *//* Значение */
,aOwnerPartName
 VARCHAR2 := null /* Раздел *//* Раздел */
,aOwnerRowID CHAR := null /* Идентификатор строки *//* Идентификатор строки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_Values where Num_ValuesID=aNum_ValuesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Num_Values where Num_Valuesid=aNum_ValuesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Num_Values',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Num_Values');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_Values_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_Valuesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_Values');
    return;
  end if;
 -- update row  --
 update  Num_Values set ChangeStamp=sysdate
,
  the_Value=athe_Value
,
  OwnerPartName=aOwnerPartName
,
  OwnerRowID=aOwnerRowID
  where  Num_ValuesID = aNum_ValuesID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Num_Values where ParentStructRowID=aParentStructRowID 
 and the_Value=athe_Value;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_Values');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from Num_zones where Num_zonesid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Num_Values',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Num_Values');
      return;
    end if;
 end if;
 Num_zones_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_Values');
    return;
  end if;
 insert into   Num_Values
 (  Num_ValuesID 
,ParentStructRowID
,the_Value

,OwnerPartName

,OwnerRowID

 ) values ( aNum_ValuesID 
,aParentStructRowID
,athe_Value

,aOwnerPartName

,aOwnerRowID

 ); 
 Num_Values_SINIT( aCURSESSION,aNum_Valuesid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from Num_Values where ParentStructRowID=aParentStructRowID 
 and the_Value=athe_Value;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=Num_Values');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure Num_Values_PARENT /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from Num_Values where  Num_Valuesid=aRowID;
  aParentTable := 'Num_zones';
 end; 

procedure Num_Values_ISLOCKED /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_Values where Num_Valuesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Num_Values_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDNumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Num_Values_LOCK /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Num_Values_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Num_Values_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Num_Values where Num_Valuesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Num_Values');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Num_Values set LockUserID =auserID ,LockSessionID =null where Num_Valuesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_Values set LockUserID =null,LockSessionID =aCURSESSION  where Num_Valuesid=aRowID;
     return;
   end if;
 end ;

procedure Num_Values_HCL /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Num_Values_UNLOCK /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Num_Values_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_Values set LockUserID =null  where Num_Valuesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_Values set LockSessionID =null  where Num_Valuesid=aRowID;
     return;
   end if;
 end; 

procedure Num_Values_SINIT /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Num_Values where Num_Valuesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Num_Values');
    return;
  end if;
if aSecurityStyleID is null then
 Num_Values_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Num_Values set securitystyleid =aStyleID where Num_Valuesid = aRowID;
else 
 update Num_Values set securitystyleid =aSecurityStyleID where Num_Valuesid = aRowID;
end if; 
end ; 

procedure Num_Values_propagate /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Num_Values where Num_Valuesid=aRowid;
end;


procedure Num_head_BRIEF  (
 aCURSESSION CHAR,
 aNum_headid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aNum_headid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Num_head where Num_headid=aNum_headID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Num_head');
    return;
  end if;
  aBRIEF:=func.Num_head_BRIEF_F(aNum_headid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Num_head_DELETE /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aNum_headid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Num_head where Num_headid=aNum_headID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Num_head',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Num_head');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_head_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_headid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Num_head');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Num_head is select  instanceid ID from instance where OwnerPartName ='Num_head' and OwnerRowID=aNum_headid;
row_Num_head  chld_Num_head%ROWTYPE;
begin
--open chld_Num_head;
for row_Num_head in chld_Num_head loop
 Kernel.INSTANCE_OWNER (acursession,row_Num_head.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Num_head.id);
end loop;
--close chld_Num_head;
end ;
  delete from  Num_head 
  where  Num_headID = aNum_headID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure Num_head_SAVE /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aNum_headid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aShema
 NUMBER/* Схема нумерации *//* Схема нумерации */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Num_head where Num_headID=aNum_headID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Num_head where Num_headid=aNum_headID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Num_head',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Num_head');
      return;
    end if;
  end if;
 --  verify lock  --
 Num_head_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aNum_headid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_head');
    return;
  end if;
 -- update row  --
 update  Num_head set ChangeStamp=sysdate
,
  Name=aName
,
  Shema=aShema
  where  Num_headID = aNum_headID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Num_head',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Num_head');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Num_head');
    return;
  end if;
select Count(*) into existsCnt from Num_head where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Num_head&gt;');
    return;
 End if;
 insert into   Num_head
 (  Num_headID 
,InstanceID
,Name

,Shema

 ) values ( aNum_headID 
,aInstanceID
,aName

,aShema

 ); 
 Num_head_SINIT( aCURSESSION,aNum_headid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure Num_head_PARENT /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Num_head where  Num_headid=aRowID;
 end; 

procedure Num_head_ISLOCKED /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Num_head where Num_headid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Num_head_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin STDNumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Num_head_LOCK /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Num_head_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Num_head_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Num_head where Num_headid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Num_head');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Num_head set LockUserID =auserID ,LockSessionID =null where Num_headid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Num_head set LockUserID =null,LockSessionID =aCURSESSION  where Num_headid=aRowID;
     return;
   end if;
 end ;

procedure Num_head_HCL /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Num_head_UNLOCK /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Num_head_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Num_head set LockUserID =null  where Num_headid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Num_head set LockSessionID =null  where Num_headid=aRowID;
     return;
   end if;
 end; 

procedure Num_head_SINIT /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Num_head where Num_headid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Num_head');
    return;
  end if;
if aSecurityStyleID is null then
 Num_head_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Num_head set securitystyleid =aStyleID where Num_headid = aRowID;
else 
 update Num_head set securitystyleid =aSecurityStyleID where Num_headid = aRowID;
end if; 
end ; 

procedure Num_head_propagate /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Num_head where Num_headid=aRowid;
end;
end STDNumerator;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZExt" BlockCode=" create or replace package body MTZExt as

procedure MTZExt_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZExt'
then
declare cursor child_MTZExt_def is select MTZExt_def.MTZExt_defid ID from MTZExt_def where  MTZExt_def.InstanceID = ainstanceid;
row_MTZExt_def  child_MTZExt_def%ROWTYPE;
begin
--open child_MTZExt_def;
for row_MTZExt_def in child_MTZExt_def loop
 MTZExt_def_DELETE (acursession,row_MTZExt_def.id,aInstanceID);
end loop;
--close child_MTZExt_def;
end;
declare cursor child_MTZExtRel is select MTZExtRel.MTZExtRelid ID from MTZExtRel where  MTZExtRel.InstanceID = ainstanceid;
row_MTZExtRel  child_MTZExtRel%ROWTYPE;
begin
--open child_MTZExtRel;
for row_MTZExtRel in child_MTZExtRel loop
 MTZExtRel_DELETE (acursession,row_MTZExtRel.id,aInstanceID);
end loop;
--close child_MTZExtRel;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZExt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZExt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_MTZExt_def is select MTZExt_def.MTZExt_defid ID from MTZExt_def where  MTZExt_def.InstanceID = arowid;
ROW_MTZExt_def  lch_MTZExt_def%ROWTYPE;
begin
--open lch_MTZExt_def;
for row_MTZExt_def in lch_MTZExt_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZExt_def where MTZExt_defid=row_MTZExt_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_MTZExt_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_MTZExt_def;
     return;
   end if; 
 end if; 
 MTZExt_def_HCL (acursession,ROW_MTZExt_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_MTZExt_def;
   return;
 end if;
 end loop;
--close lch_MTZExt_def;
end;
declare cursor lch_MTZExtRel is select MTZExtRel.MTZExtRelid ID from MTZExtRel where  MTZExtRel.InstanceID = arowid;
ROW_MTZExtRel  lch_MTZExtRel%ROWTYPE;
begin
--open lch_MTZExtRel;
for row_MTZExtRel in lch_MTZExtRel loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZExtRel where MTZExtRelid=row_MTZExtRel.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_MTZExtRel;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_MTZExtRel;
     return;
   end if; 
 end if; 
 MTZExtRel_HCL (acursession,ROW_MTZExtRel.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_MTZExtRel;
   return;
 end if;
 end loop;
--close lch_MTZExtRel;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZExt_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZExt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_MTZExt_def is select MTZExt_def.MTZExt_defid id from MTZExt_def where  MTZExt_def.InstanceID = arowid;
row_MTZExt_def  pch_MTZExt_def%ROWTYPE;
begin
--open pch_MTZExt_def;
for row_MTZExt_def in  pch_MTZExt_def loop
 MTZExt_def_SINIT( acursession,row_MTZExt_def.id,assid);
 MTZExt_def_propagate( acursession,row_MTZExt_def.id);
end loop;
--close pch_MTZExt_def;
end;
declare cursor pch_MTZExtRel is select MTZExtRel.MTZExtRelid id from MTZExtRel where  MTZExtRel.InstanceID = arowid;
row_MTZExtRel  pch_MTZExtRel%ROWTYPE;
begin
--open pch_MTZExtRel;
for row_MTZExtRel in  pch_MTZExtRel loop
 MTZExtRel_SINIT( acursession,row_MTZExtRel.id,assid);
 MTZExtRel_propagate( acursession,row_MTZExtRel.id);
end loop;
--close pch_MTZExtRel;
end;
 end if; 
end;


procedure MTZExt_def_BRIEF  (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aMTZExt_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from MTZExt_def where MTZExt_defid=aMTZExt_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=MTZExt_def');
    return;
  end if;
  aBRIEF:=func.MTZExt_def_BRIEF_F(aMTZExt_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure MTZExt_def_DELETE /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from MTZExt_def where MTZExt_defid=aMTZExt_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:MTZExt_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=MTZExt_def');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZExt_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZExt_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZExt_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_MTZExt_def is select  instanceid ID from instance where OwnerPartName ='MTZExt_def' and OwnerRowID=aMTZExt_defid;
row_MTZExt_def  chld_MTZExt_def%ROWTYPE;
begin
--open chld_MTZExt_def;
for row_MTZExt_def in chld_MTZExt_def loop
 Kernel.INSTANCE_OWNER (acursession,row_MTZExt_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_MTZExt_def.id);
end loop;
--close chld_MTZExt_def;
end ;
  delete from  MTZExt_def 
  where  MTZExt_defID = aMTZExt_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure MTZExt_def_SAVE /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aMTZExt_defid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aExtType
 NUMBER/* Тип расширения *//* Тип расширения */
,aTheDescription VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZExt_def where MTZExt_defID=aMTZExt_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from MTZExt_def where MTZExt_defid=aMTZExt_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:MTZExt_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=MTZExt_def');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZExt_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZExt_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExt_def');
    return;
  end if;
 -- update row  --
 update  MTZExt_def set ChangeStamp=sysdate
,
  Name=aName
,
  ExtType=aExtType
,
  TheDescription=aTheDescription
  where  MTZExt_defID = aMTZExt_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:MTZExt_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=MTZExt_def');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExt_def');
    return;
  end if;
select Count(*) into existsCnt from MTZExt_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;MTZExt_def&gt;');
    return;
 End if;
 insert into   MTZExt_def
 (  MTZExt_defID 
,InstanceID
,Name

,ExtType

,TheDescription

 ) values ( aMTZExt_defID 
,aInstanceID
,aName

,aExtType

,aTheDescription

 ); 
 MTZExt_def_SINIT( aCURSESSION,aMTZExt_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure MTZExt_def_PARENT /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from MTZExt_def where  MTZExt_defid=aRowID;
 end; 

procedure MTZExt_def_ISLOCKED /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZExt_def where MTZExt_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  MTZExt_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZExt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure MTZExt_def_LOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 MTZExt_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  MTZExt_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from MTZExt_def where MTZExt_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=MTZExt_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update MTZExt_def set LockUserID =auserID ,LockSessionID =null where MTZExt_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZExt_def set LockUserID =null,LockSessionID =aCURSESSION  where MTZExt_defid=aRowID;
     return;
   end if;
 end ;

procedure MTZExt_def_HCL /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure MTZExt_def_UNLOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 MTZExt_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZExt_def set LockUserID =null  where MTZExt_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZExt_def set LockSessionID =null  where MTZExt_defid=aRowID;
     return;
   end if;
 end; 

procedure MTZExt_def_SINIT /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from MTZExt_def where MTZExt_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =MTZExt_def');
    return;
  end if;
if aSecurityStyleID is null then
 MTZExt_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update MTZExt_def set securitystyleid =aStyleID where MTZExt_defid = aRowID;
else 
 update MTZExt_def set securitystyleid =aSecurityStyleID where MTZExt_defid = aRowID;
end if; 
end ; 

procedure MTZExt_def_propagate /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from MTZExt_def where MTZExt_defid=aRowid;
end;


procedure MTZExtRel_BRIEF  (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aMTZExtRelid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from MTZExtRel where MTZExtRelid=aMTZExtRelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=MTZExtRel');
    return;
  end if;
  aBRIEF:=func.MTZExtRel_BRIEF_F(aMTZExtRelid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure MTZExtRel_DELETE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from MTZExtRel where MTZExtRelid=aMTZExtRelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:MTZExtRel',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=MTZExtRel');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZExtRel_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZExtRelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZExtRel');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_MTZExtRel is select  instanceid ID from instance where OwnerPartName ='MTZExtRel' and OwnerRowID=aMTZExtRelid;
row_MTZExtRel  chld_MTZExtRel%ROWTYPE;
begin
--open chld_MTZExtRel;
for row_MTZExtRel in chld_MTZExtRel loop
 Kernel.INSTANCE_OWNER (acursession,row_MTZExtRel.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_MTZExtRel.id);
end loop;
--close chld_MTZExtRel;
end ;
  delete from  MTZExtRel 
  where  MTZExtRelID = aMTZExtRelID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Реализации расширения*/
procedure MTZExtRel_SAVE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aMTZExtRelid CHAR,
aInstanceID CHAR 
,aThePlatform
 NUMBER/* Реализация *//* Реализация */
,aTheClassName
 VARCHAR2/* Название класса *//* Название класса */
,aTheLibraryName
 VARCHAR2 := null /* Название библиотеки *//* Название библиотеки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZExtRel where MTZExtRelID=aMTZExtRelID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from MTZExtRel where MTZExtRelid=aMTZExtRelID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:MTZExtRel',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=MTZExtRel');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZExtRel_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZExtRelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExtRel');
    return;
  end if;
 -- update row  --
 update  MTZExtRel set ChangeStamp=sysdate
,
  ThePlatform=aThePlatform
,
  TheClassName=aTheClassName
,
  TheLibraryName=aTheLibraryName
  where  MTZExtRelID = aMTZExtRelID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:MTZExtRel',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=MTZExtRel');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZExtRel');
    return;
  end if;
 insert into   MTZExtRel
 (  MTZExtRelID 
,InstanceID
,ThePlatform

,TheClassName

,TheLibraryName

 ) values ( aMTZExtRelID 
,aInstanceID
,aThePlatform

,aTheClassName

,aTheLibraryName

 ); 
 MTZExtRel_SINIT( aCURSESSION,aMTZExtRelid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure MTZExtRel_PARENT /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from MTZExtRel where  MTZExtRelid=aRowID;
 end; 

procedure MTZExtRel_ISLOCKED /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZExtRel where MTZExtRelid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  MTZExtRel_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZExt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure MTZExtRel_LOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 MTZExtRel_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  MTZExtRel_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from MTZExtRel where MTZExtRelid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=MTZExtRel');
    return;
  end if;
   if  aLockMode =2  
   then   
    update MTZExtRel set LockUserID =auserID ,LockSessionID =null where MTZExtRelid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZExtRel set LockUserID =null,LockSessionID =aCURSESSION  where MTZExtRelid=aRowID;
     return;
   end if;
 end ;

procedure MTZExtRel_HCL /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure MTZExtRel_UNLOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 MTZExtRel_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZExtRel set LockUserID =null  where MTZExtRelid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZExtRel set LockSessionID =null  where MTZExtRelid=aRowID;
     return;
   end if;
 end; 

procedure MTZExtRel_SINIT /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from MTZExtRel where MTZExtRelid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =MTZExtRel');
    return;
  end if;
if aSecurityStyleID is null then
 MTZExtRel_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update MTZExtRel set securitystyleid =aStyleID where MTZExtRelid = aRowID;
else 
 update MTZExtRel set securitystyleid =aSecurityStyleID where MTZExtRelid = aRowID;
end if; 
end ; 

procedure MTZExtRel_propagate /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from MTZExtRel where MTZExtRelid=aRowid;
end;
end MTZExt;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toact" BlockCode=" create or replace package body toact as

procedure toact_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='toact'
then
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure toact_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'toact'
 then
 aIsLocked :=0;
end;
procedure toact_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'toact'
 then
   assid:= 'do nothing';
 end if;
end;
end toact;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZ2JOB" BlockCode=" create or replace package body MTZ2JOB as

procedure MTZ2JOB_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZ2JOB'
then
declare cursor child_MTZ2JOB_DEF is select MTZ2JOB_DEF.MTZ2JOB_DEFid ID from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = ainstanceid;
row_MTZ2JOB_DEF  child_MTZ2JOB_DEF%ROWTYPE;
begin
--open child_MTZ2JOB_DEF;
for row_MTZ2JOB_DEF in child_MTZ2JOB_DEF loop
 MTZ2JOB_DEF_DELETE (acursession,row_MTZ2JOB_DEF.id,aInstanceID);
end loop;
--close child_MTZ2JOB_DEF;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZ2JOB_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZ2JOB'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_MTZ2JOB_DEF is select MTZ2JOB_DEF.MTZ2JOB_DEFid ID from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = arowid;
ROW_MTZ2JOB_DEF  lch_MTZ2JOB_DEF%ROWTYPE;
begin
--open lch_MTZ2JOB_DEF;
for row_MTZ2JOB_DEF in lch_MTZ2JOB_DEF loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from MTZ2JOB_DEF where MTZ2JOB_DEFid=row_MTZ2JOB_DEF.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_MTZ2JOB_DEF;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_MTZ2JOB_DEF;
     return;
   end if; 
 end if; 
 MTZ2JOB_DEF_HCL (acursession,ROW_MTZ2JOB_DEF.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_MTZ2JOB_DEF;
   return;
 end if;
 end loop;
--close lch_MTZ2JOB_DEF;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZ2JOB_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZ2JOB'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_MTZ2JOB_DEF is select MTZ2JOB_DEF.MTZ2JOB_DEFid id from MTZ2JOB_DEF where  MTZ2JOB_DEF.InstanceID = arowid;
row_MTZ2JOB_DEF  pch_MTZ2JOB_DEF%ROWTYPE;
begin
--open pch_MTZ2JOB_DEF;
for row_MTZ2JOB_DEF in  pch_MTZ2JOB_DEF loop
 MTZ2JOB_DEF_SINIT( acursession,row_MTZ2JOB_DEF.id,assid);
 MTZ2JOB_DEF_propagate( acursession,row_MTZ2JOB_DEF.id);
end loop;
--close pch_MTZ2JOB_DEF;
end;
 end if; 
end;


procedure MTZ2JOB_DEF_BRIEF  (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aMTZ2JOB_DEFid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from MTZ2JOB_DEF where MTZ2JOB_DEFid=aMTZ2JOB_DEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=MTZ2JOB_DEF');
    return;
  end if;
  aBRIEF:=func.MTZ2JOB_DEF_BRIEF_F(aMTZ2JOB_DEFid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure MTZ2JOB_DEF_DELETE /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aMTZ2JOB_DEFID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:MTZ2JOB_DEF',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=MTZ2JOB_DEF');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZ2JOB_DEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZ2JOB_DEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_MTZ2JOB_DEF is select  instanceid ID from instance where OwnerPartName ='MTZ2JOB_DEF' and OwnerRowID=aMTZ2JOB_DEFid;
row_MTZ2JOB_DEF  chld_MTZ2JOB_DEF%ROWTYPE;
begin
--open chld_MTZ2JOB_DEF;
for row_MTZ2JOB_DEF in chld_MTZ2JOB_DEF loop
 Kernel.INSTANCE_OWNER (acursession,row_MTZ2JOB_DEF.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_MTZ2JOB_DEF.id);
end loop;
--close chld_MTZ2JOB_DEF;
end ;
  delete from  MTZ2JOB_DEF 
  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отложенное событие*/
procedure MTZ2JOB_DEF_SAVE /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aMTZ2JOB_DEFid CHAR,
aInstanceID CHAR 
,aEventDate
 DATE/* Отложено до *//* Отложено до */
,aEvenType
 VARCHAR2/* Тип события *//* Тип события */
,aThruObject CHAR/* Объект - причина события *//* Объект - причина события */
,aThruState CHAR := null /* Состояние - причина *//* Состояние - причина */
,aNextState CHAR := null /* Состояние после обработки *//* Состояние после обработки */
,aProcessDate
 DATE := null /* Момент обработки *//* Момент обработки */
,aProcessed
 NUMBER/* Обработан *//* Обработан */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from MTZ2JOB_DEF where MTZ2JOB_DEFID=aMTZ2JOB_DEFID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aMTZ2JOB_DEFID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:MTZ2JOB_DEF',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=MTZ2JOB_DEF');
      return;
    end if;
  end if;
 --  verify lock  --
 MTZ2JOB_DEF_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aMTZ2JOB_DEFid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
 -- update row  --
 update  MTZ2JOB_DEF set ChangeStamp=sysdate
,
  EventDate=aEventDate
,
  EvenType=aEvenType
,
  ThruObject=aThruObject
,
  ThruState=aThruState
,
  NextState=aNextState
,
  ProcessDate=aProcessDate
,
  Processed=aProcessed
  where  MTZ2JOB_DEFID = aMTZ2JOB_DEFID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:MTZ2JOB_DEF',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=MTZ2JOB_DEF');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=MTZ2JOB_DEF');
    return;
  end if;
 insert into   MTZ2JOB_DEF
 (  MTZ2JOB_DEFID 
,InstanceID
,EventDate

,EvenType

,ThruObject

,ThruState

,NextState

,ProcessDate

,Processed

 ) values ( aMTZ2JOB_DEFID 
,aInstanceID
,aEventDate

,aEvenType

,aThruObject

,aThruState

,aNextState

,aProcessDate

,aProcessed

 ); 
 MTZ2JOB_DEF_SINIT( aCURSESSION,aMTZ2JOB_DEFid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure MTZ2JOB_DEF_PARENT /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from MTZ2JOB_DEF where  MTZ2JOB_DEFid=aRowID;
 end; 

procedure MTZ2JOB_DEF_ISLOCKED /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  MTZ2JOB_DEF_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZ2JOB.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure MTZ2JOB_DEF_LOCK /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 MTZ2JOB_DEF_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  MTZ2JOB_DEF_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=MTZ2JOB_DEF');
    return;
  end if;
   if  aLockMode =2  
   then   
    update MTZ2JOB_DEF set LockUserID =auserID ,LockSessionID =null where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update MTZ2JOB_DEF set LockUserID =null,LockSessionID =aCURSESSION  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
 end ;

procedure MTZ2JOB_DEF_HCL /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure MTZ2JOB_DEF_UNLOCK /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 MTZ2JOB_DEF_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update MTZ2JOB_DEF set LockUserID =null  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update MTZ2JOB_DEF set LockSessionID =null  where MTZ2JOB_DEFid=aRowID;
     return;
   end if;
 end; 

procedure MTZ2JOB_DEF_SINIT /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =MTZ2JOB_DEF');
    return;
  end if;
if aSecurityStyleID is null then
 MTZ2JOB_DEF_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update MTZ2JOB_DEF set securitystyleid =aStyleID where MTZ2JOB_DEFid = aRowID;
else 
 update MTZ2JOB_DEF set securitystyleid =aSecurityStyleID where MTZ2JOB_DEFid = aRowID;
end if; 
end ; 

procedure MTZ2JOB_DEF_propagate /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from MTZ2JOB_DEF where MTZ2JOB_DEFid=aRowid;
end;
end MTZ2JOB;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZFltr" BlockCode=" create or replace package body MTZFltr as

procedure MTZFltr_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZFltr'
then
declare cursor child_FilterFieldGroup is select FilterFieldGroup.FilterFieldGroupid ID from FilterFieldGroup where  FilterFieldGroup.InstanceID = ainstanceid;
row_FilterFieldGroup  child_FilterFieldGroup%ROWTYPE;
begin
--open child_FilterFieldGroup;
for row_FilterFieldGroup in child_FilterFieldGroup loop
 FilterFieldGroup_DELETE (acursession,row_FilterFieldGroup.id,aInstanceID);
end loop;
--close child_FilterFieldGroup;
end;
declare cursor child_Filters is select Filters.Filtersid ID from Filters where  Filters.InstanceID = ainstanceid;
row_Filters  child_Filters%ROWTYPE;
begin
--open child_Filters;
for row_Filters in child_Filters loop
 Filters_DELETE (acursession,row_Filters.id,aInstanceID);
end loop;
--close child_Filters;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZFltr_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZFltr'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_FilterFieldGroup is select FilterFieldGroup.FilterFieldGroupid ID from FilterFieldGroup where  FilterFieldGroup.InstanceID = arowid;
ROW_FilterFieldGroup  lch_FilterFieldGroup%ROWTYPE;
begin
--open lch_FilterFieldGroup;
for row_FilterFieldGroup in lch_FilterFieldGroup loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from FilterFieldGroup where FilterFieldGroupid=row_FilterFieldGroup.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FilterFieldGroup;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_FilterFieldGroup;
     return;
   end if; 
 end if; 
 FilterFieldGroup_HCL (acursession,ROW_FilterFieldGroup.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FilterFieldGroup;
   return;
 end if;
 end loop;
--close lch_FilterFieldGroup;
end;
declare cursor lch_Filters is select Filters.Filtersid ID from Filters where  Filters.InstanceID = arowid;
ROW_Filters  lch_Filters%ROWTYPE;
begin
--open lch_Filters;
for row_Filters in lch_Filters loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Filters where Filtersid=row_Filters.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Filters;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Filters;
     return;
   end if; 
 end if; 
 Filters_HCL (acursession,ROW_Filters.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Filters;
   return;
 end if;
 end loop;
--close lch_Filters;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZFltr_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZFltr'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_FilterFieldGroup is select FilterFieldGroup.FilterFieldGroupid id from FilterFieldGroup where  FilterFieldGroup.InstanceID = arowid;
row_FilterFieldGroup  pch_FilterFieldGroup%ROWTYPE;
begin
--open pch_FilterFieldGroup;
for row_FilterFieldGroup in  pch_FilterFieldGroup loop
 FilterFieldGroup_SINIT( acursession,row_FilterFieldGroup.id,assid);
 FilterFieldGroup_propagate( acursession,row_FilterFieldGroup.id);
end loop;
--close pch_FilterFieldGroup;
end;
declare cursor pch_Filters is select Filters.Filtersid id from Filters where  Filters.InstanceID = arowid;
row_Filters  pch_Filters%ROWTYPE;
begin
--open pch_Filters;
for row_Filters in  pch_Filters loop
 Filters_SINIT( acursession,row_Filters.id,assid);
 Filters_propagate( acursession,row_Filters.id);
end loop;
--close pch_Filters;
end;
 end if; 
end;


procedure FilterFieldGroup_BRIEF  (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFilterFieldGroupid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FilterFieldGroup where FilterFieldGroupid=aFilterFieldGroupID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FilterFieldGroup');
    return;
  end if;
  aBRIEF:=func.FilterFieldGroup_BRIEF_F(aFilterFieldGroupid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FilterFieldGroup_DELETE /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FilterFieldGroup where FilterFieldGroupid=aFilterFieldGroupID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FilterFieldGroup',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FilterFieldGroup');
      return;
    end if;
  end if;
 --  verify lock  --
 FilterFieldGroup_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFilterFieldGroupid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FilterFieldGroup');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_FileterField is select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aFilterFieldGroupid;
    child_FileterField_rec  child_FileterField%ROWTYPE;
    begin
    --open child_FileterField;
      for child_FileterField_rec in child_FileterField loop
      FileterField_DELETE (acursession,child_FileterField_rec.id,aInstanceid);
      end loop;
      --close child_FileterField;
    end ;
declare cursor chld_FilterFieldGroup is select  instanceid ID from instance where OwnerPartName ='FilterFieldGroup' and OwnerRowID=aFilterFieldGroupid;
row_FilterFieldGroup  chld_FilterFieldGroup%ROWTYPE;
begin
--open chld_FilterFieldGroup;
for row_FilterFieldGroup in chld_FilterFieldGroup loop
 Kernel.INSTANCE_OWNER (acursession,row_FilterFieldGroup.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FilterFieldGroup.id);
end loop;
--close chld_FilterFieldGroup;
end ;
  delete from  FilterFieldGroup 
  where  FilterFieldGroupID = aFilterFieldGroupID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Группа полей фильтра*/
procedure FilterFieldGroup_SAVE /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aFilterFieldGroupid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aAllowIgnore
 NUMBER/* Можно отключать *//* Можно отключать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FilterFieldGroup where FilterFieldGroupID=aFilterFieldGroupID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FilterFieldGroup where FilterFieldGroupid=aFilterFieldGroupID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FilterFieldGroup',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FilterFieldGroup');
      return;
    end if;
  end if;
 --  verify lock  --
 FilterFieldGroup_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFilterFieldGroupid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FilterFieldGroup');
    return;
  end if;
 -- update row  --
 update  FilterFieldGroup set ChangeStamp=sysdate
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  AllowIgnore=aAllowIgnore
  where  FilterFieldGroupID = aFilterFieldGroupID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FilterFieldGroup',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FilterFieldGroup');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FilterFieldGroup');
    return;
  end if;
 insert into   FilterFieldGroup
 (  FilterFieldGroupID 
,InstanceID
,sequence

,Name

,Caption

,AllowIgnore

 ) values ( aFilterFieldGroupID 
,aInstanceID
,asequence

,aName

,aCaption

,aAllowIgnore

 ); 
 FilterFieldGroup_SINIT( aCURSESSION,aFilterFieldGroupid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FilterFieldGroup_PARENT /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from FilterFieldGroup where  FilterFieldGroupid=aRowID;
 end; 

procedure FilterFieldGroup_ISLOCKED /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FilterFieldGroup where FilterFieldGroupid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FilterFieldGroup_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZFltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FilterFieldGroup_LOCK /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FilterFieldGroup_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FilterFieldGroup_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FilterFieldGroup where FilterFieldGroupid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FilterFieldGroup');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FilterFieldGroup set LockUserID =auserID ,LockSessionID =null where FilterFieldGroupid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FilterFieldGroup set LockUserID =null,LockSessionID =aCURSESSION  where FilterFieldGroupid=aRowID;
     return;
   end if;
 end ;

procedure FilterFieldGroup_HCL /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_FileterField is select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aRowid;
row_FileterField lch_FileterField%ROWTYPE;
begin  
--open lch_FileterField;
for row_FileterField in lch_FileterField
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from FileterField where FileterFieldid=row_FileterField.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_FileterField;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_FileterField;
     return;
   end if; 
 end if;  
 FileterField_HCL (acursession,row_FileterField.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_FileterField;
   return;
 end if;
end loop;
--close lch_FileterField;
end;
aIsLocked :=0;
end;

procedure FilterFieldGroup_UNLOCK /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FilterFieldGroup_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FilterFieldGroup set LockUserID =null  where FilterFieldGroupid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FilterFieldGroup set LockSessionID =null  where FilterFieldGroupid=aRowID;
     return;
   end if;
 end; 

procedure FilterFieldGroup_SINIT /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FilterFieldGroup where FilterFieldGroupid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FilterFieldGroup');
    return;
  end if;
if aSecurityStyleID is null then
 FilterFieldGroup_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FilterFieldGroup set securitystyleid =aStyleID where FilterFieldGroupid = aRowID;
else 
 update FilterFieldGroup set securitystyleid =aSecurityStyleID where FilterFieldGroupid = aRowID;
end if; 
end ; 

procedure FilterFieldGroup_propagate /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FilterFieldGroup where FilterFieldGroupid=aRowid;
declare cursor pch_FileterField  is select FileterField.FileterFieldid ID from FileterField where  FileterField.ParentStructRowID = aRowid;
row_FileterField  pch_FileterField%ROWTYPE;
begin
--open pch_FileterField;
for row_FileterField in pch_FileterField loop
   FileterField_SINIT( acursession,row_FileterField.id,assid);
   FileterField_propagate( acursession,row_FileterField.id);
end loop;
--close pch_FileterField;
end;
end;


procedure FileterField_BRIEF  (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFileterFieldid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from FileterField where FileterFieldid=aFileterFieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=FileterField');
    return;
  end if;
  aBRIEF:=func.FileterField_BRIEF_F(aFileterFieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure FileterField_DELETE /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from FileterField where FileterFieldid=aFileterFieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:FileterField',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=FileterField');
      return;
    end if;
  end if;
 --  verify lock  --
 FileterField_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFileterFieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=FileterField');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_FileterField is select  instanceid ID from instance where OwnerPartName ='FileterField' and OwnerRowID=aFileterFieldid;
row_FileterField  chld_FileterField%ROWTYPE;
begin
--open chld_FileterField;
for row_FileterField in chld_FileterField loop
 Kernel.INSTANCE_OWNER (acursession,row_FileterField.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_FileterField.id);
end loop;
--close chld_FileterField;
end ;
  delete from  FileterField 
  where  FileterFieldID = aFileterFieldID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поле фильтра*/
procedure FileterField_SAVE /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aFileterFieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aFieldSize
 NUMBER := null /* Размер *//* Размер */
,aRefType
 NUMBER := null /* Тип ссылки *//* Тип ссылки */
,aRefToType CHAR := null /* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,aRefToPart CHAR := null /* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,aValueArray
 NUMBER/* Массив значений *//* Массив значений */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from FileterField where FileterFieldID=aFileterFieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from FileterField where FileterFieldid=aFileterFieldID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:FileterField',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=FileterField');
      return;
    end if;
  end if;
 --  verify lock  --
 FileterField_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFileterFieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FileterField');
    return;
  end if;
 -- update row  --
 update  FileterField set ChangeStamp=sysdate
,
  sequence=asequence
,
  Name=aName
,
  Caption=aCaption
,
  FieldType=aFieldType
,
  FieldSize=aFieldSize
,
  RefType=aRefType
,
  RefToType=aRefToType
,
  RefToPart=aRefToPart
,
  ValueArray=aValueArray
  where  FileterFieldID = aFileterFieldID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from FilterFieldGroup where FilterFieldGroupid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:FileterField',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=FileterField');
      return;
    end if;
 end if;
 FilterFieldGroup_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=FileterField');
    return;
  end if;
 insert into   FileterField
 (  FileterFieldID 
,ParentStructRowID
,sequence

,Name

,Caption

,FieldType

,FieldSize

,RefType

,RefToType

,RefToPart

,ValueArray

 ) values ( aFileterFieldID 
,aParentStructRowID
,asequence

,aName

,aCaption

,aFieldType

,aFieldSize

,aRefType

,aRefToType

,aRefToPart

,aValueArray

 ); 
 FileterField_SINIT( aCURSESSION,aFileterFieldid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure FileterField_PARENT /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from FileterField where  FileterFieldid=aRowID;
  aParentTable := 'FilterFieldGroup';
 end; 

procedure FileterField_ISLOCKED /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from FileterField where FileterFieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  FileterField_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZFltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure FileterField_LOCK /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 FileterField_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  FileterField_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from FileterField where FileterFieldid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=FileterField');
    return;
  end if;
   if  aLockMode =2  
   then   
    update FileterField set LockUserID =auserID ,LockSessionID =null where FileterFieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update FileterField set LockUserID =null,LockSessionID =aCURSESSION  where FileterFieldid=aRowID;
     return;
   end if;
 end ;

procedure FileterField_HCL /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure FileterField_UNLOCK /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 FileterField_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update FileterField set LockUserID =null  where FileterFieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update FileterField set LockSessionID =null  where FileterFieldid=aRowID;
     return;
   end if;
 end; 

procedure FileterField_SINIT /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from FileterField where FileterFieldid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =FileterField');
    return;
  end if;
if aSecurityStyleID is null then
 FileterField_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update FileterField set securitystyleid =aStyleID where FileterFieldid = aRowID;
else 
 update FileterField set securitystyleid =aSecurityStyleID where FileterFieldid = aRowID;
end if; 
end ; 

procedure FileterField_propagate /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from FileterField where FileterFieldid=aRowid;
end;


procedure Filters_BRIEF  (
 aCURSESSION CHAR,
 aFiltersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aFiltersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Filters where Filtersid=aFiltersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Filters');
    return;
  end if;
  aBRIEF:=func.Filters_BRIEF_F(aFiltersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Filters_DELETE /*Фильтр*/ (
 aCURSESSION CHAR,
 aFiltersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Filters where Filtersid=aFiltersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Filters',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Filters');
      return;
    end if;
  end if;
 --  verify lock  --
 Filters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFiltersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Filters');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Filters is select  instanceid ID from instance where OwnerPartName ='Filters' and OwnerRowID=aFiltersid;
row_Filters  chld_Filters%ROWTYPE;
begin
--open chld_Filters;
for row_Filters in chld_Filters loop
 Kernel.INSTANCE_OWNER (acursession,row_Filters.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Filters.id);
end loop;
--close chld_Filters;
end ;
  delete from  Filters 
  where  FiltersID = aFiltersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Фильтр*/
procedure Filters_SAVE /*Фильтр*/ (
 aCURSESSION CHAR,
 aFiltersid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aTheCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Filters where FiltersID=aFiltersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Filters where Filtersid=aFiltersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Filters',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Filters');
      return;
    end if;
  end if;
 --  verify lock  --
 Filters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aFiltersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Filters');
    return;
  end if;
 -- update row  --
 update  Filters set ChangeStamp=sysdate
,
  Name=aName
,
  TheCaption=aTheCaption
,
  TheComment=aTheComment
  where  FiltersID = aFiltersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Filters',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Filters');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Filters');
    return;
  end if;
select Count(*) into existsCnt from Filters where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Filters&gt;');
    return;
 End if;
 insert into   Filters
 (  FiltersID 
,InstanceID
,Name

,TheCaption

,TheComment

 ) values ( aFiltersID 
,aInstanceID
,aName

,aTheCaption

,aTheComment

 ); 
 Filters_SINIT( aCURSESSION,aFiltersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure Filters_PARENT /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Filters where  Filtersid=aRowID;
 end; 

procedure Filters_ISLOCKED /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Filters where Filtersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Filters_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZFltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Filters_LOCK /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Filters_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Filters_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Filters where Filtersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Filters');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Filters set LockUserID =auserID ,LockSessionID =null where Filtersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Filters set LockUserID =null,LockSessionID =aCURSESSION  where Filtersid=aRowID;
     return;
   end if;
 end ;

procedure Filters_HCL /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Filters_UNLOCK /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Filters_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Filters set LockUserID =null  where Filtersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Filters set LockSessionID =null  where Filtersid=aRowID;
     return;
   end if;
 end; 

procedure Filters_SINIT /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Filters where Filtersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Filters');
    return;
  end if;
if aSecurityStyleID is null then
 Filters_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Filters set securitystyleid =aStyleID where Filtersid = aRowID;
else 
 update Filters set securitystyleid =aSecurityStyleID where Filtersid = aRowID;
end if; 
end ; 

procedure Filters_propagate /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Filters where Filtersid=aRowid;
end;
end MTZFltr;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--MTZRprt" BlockCode=" create or replace package body MTZRprt as

procedure MTZRprt_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='MTZRprt'
then
declare cursor child_RPTStruct is select RPTStruct.RPTStructid ID from RPTStruct where  RPTStruct.InstanceID = ainstanceid;
row_RPTStruct  child_RPTStruct%ROWTYPE;
begin
--open child_RPTStruct;
for row_RPTStruct in child_RPTStruct loop
 RPTStruct_DELETE (acursession,row_RPTStruct.id,aInstanceID);
end loop;
--close child_RPTStruct;
end;
declare cursor child_RPTFormula is select RPTFormula.RPTFormulaid ID from RPTFormula where  RPTFormula.InstanceID = ainstanceid;
row_RPTFormula  child_RPTFormula%ROWTYPE;
begin
--open child_RPTFormula;
for row_RPTFormula in child_RPTFormula loop
 RPTFormula_DELETE (acursession,row_RPTFormula.id,aInstanceID);
end loop;
--close child_RPTFormula;
end;
declare cursor child_Reports is select Reports.Reportsid ID from Reports where  Reports.InstanceID = ainstanceid;
row_Reports  child_Reports%ROWTYPE;
begin
--open child_Reports;
for row_Reports in child_Reports loop
 Reports_DELETE (acursession,row_Reports.id,aInstanceID);
end loop;
--close child_Reports;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure MTZRprt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'MTZRprt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_RPTStruct is select RPTStruct.RPTStructid ID from RPTStruct where  RPTStruct.InstanceID = arowid;
ROW_RPTStruct  lch_RPTStruct%ROWTYPE;
begin
--open lch_RPTStruct;
for row_RPTStruct in lch_RPTStruct loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from RPTStruct where RPTStructid=row_RPTStruct.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_RPTStruct;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_RPTStruct;
     return;
   end if; 
 end if; 
 RPTStruct_HCL (acursession,ROW_RPTStruct.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_RPTStruct;
   return;
 end if;
 end loop;
--close lch_RPTStruct;
end;
declare cursor lch_RPTFormula is select RPTFormula.RPTFormulaid ID from RPTFormula where  RPTFormula.InstanceID = arowid;
ROW_RPTFormula  lch_RPTFormula%ROWTYPE;
begin
--open lch_RPTFormula;
for row_RPTFormula in lch_RPTFormula loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from RPTFormula where RPTFormulaid=row_RPTFormula.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_RPTFormula;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_RPTFormula;
     return;
   end if; 
 end if; 
 RPTFormula_HCL (acursession,ROW_RPTFormula.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_RPTFormula;
   return;
 end if;
 end loop;
--close lch_RPTFormula;
end;
declare cursor lch_Reports is select Reports.Reportsid ID from Reports where  Reports.InstanceID = arowid;
ROW_Reports  lch_Reports%ROWTYPE;
begin
--open lch_Reports;
for row_Reports in lch_Reports loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from Reports where Reportsid=row_Reports.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_Reports;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_Reports;
     return;
   end if; 
 end if; 
 Reports_HCL (acursession,ROW_Reports.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_Reports;
   return;
 end if;
 end loop;
--close lch_Reports;
end;
 end if;
aIsLocked:=0;
end;
procedure MTZRprt_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'MTZRprt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_RPTStruct is select RPTStruct.RPTStructid id from RPTStruct where  RPTStruct.InstanceID = arowid;
row_RPTStruct  pch_RPTStruct%ROWTYPE;
begin
--open pch_RPTStruct;
for row_RPTStruct in  pch_RPTStruct loop
 RPTStruct_SINIT( acursession,row_RPTStruct.id,assid);
 RPTStruct_propagate( acursession,row_RPTStruct.id);
end loop;
--close pch_RPTStruct;
end;
declare cursor pch_RPTFormula is select RPTFormula.RPTFormulaid id from RPTFormula where  RPTFormula.InstanceID = arowid;
row_RPTFormula  pch_RPTFormula%ROWTYPE;
begin
--open pch_RPTFormula;
for row_RPTFormula in  pch_RPTFormula loop
 RPTFormula_SINIT( acursession,row_RPTFormula.id,assid);
 RPTFormula_propagate( acursession,row_RPTFormula.id);
end loop;
--close pch_RPTFormula;
end;
declare cursor pch_Reports is select Reports.Reportsid id from Reports where  Reports.InstanceID = arowid;
row_Reports  pch_Reports%ROWTYPE;
begin
--open pch_Reports;
for row_Reports in  pch_Reports loop
 Reports_SINIT( acursession,row_Reports.id,assid);
 Reports_propagate( acursession,row_Reports.id);
end loop;
--close pch_Reports;
end;
 end if; 
end;


procedure RPTStruct_BRIEF  (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aRPTStructid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from RPTStruct where RPTStructid=aRPTStructID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=RPTStruct');
    return;
  end if;
  aBRIEF:=func.RPTStruct_BRIEF_F(aRPTStructid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure RPTStruct_DELETE /*Секции*/ (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from RPTStruct where RPTStructid=aRPTStructID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:RPTStruct',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=RPTStruct');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTStruct_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTStructid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTStruct');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_RPTFields is select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRPTStructid;
    child_RPTFields_rec  child_RPTFields%ROWTYPE;
    begin
    --open child_RPTFields;
      for child_RPTFields_rec in child_RPTFields loop
      RPTFields_DELETE (acursession,child_RPTFields_rec.id,aInstanceid);
      end loop;
      --close child_RPTFields;
    end ;
declare cursor chld_RPTStruct is select  instanceid ID from instance where OwnerPartName ='RPTStruct' and OwnerRowID=aRPTStructid;
row_RPTStruct  chld_RPTStruct%ROWTYPE;
begin
--open chld_RPTStruct;
for row_RPTStruct in chld_RPTStruct loop
 Kernel.INSTANCE_OWNER (acursession,row_RPTStruct.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_RPTStruct.id);
end loop;
--close chld_RPTStruct;
end ;
  delete from  RPTStruct 
  where  RPTStructID = aRPTStructID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Секции*/
procedure RPTStruct_SAVE /*Секции*/ (
 aCURSESSION CHAR,
 aRPTStructid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aName
 VARCHAR2/* Название *//* Название */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTStruct where RPTStructID=aRPTStructID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from RPTStruct where RPTStructid=aRPTStructID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:RPTStruct',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=RPTStruct');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTStruct_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTStructid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTStruct');
    return;
  end if;
 -- update row  --
 update  RPTStruct set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  Name=aName
,
  Caption=aCaption
  where  RPTStructID = aRPTStructID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:RPTStruct',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=RPTStruct');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTStruct');
    return;
  end if;
 insert into   RPTStruct
 (  RPTStructID 
,ParentRowid
,InstanceID
,Name

,Caption

 ) values ( aRPTStructID 
,aParentRowid
,aInstanceID
,aName

,aCaption

 ); 
 RPTStruct_SINIT( aCURSESSION,aRPTStructid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure RPTStruct_PARENT /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from RPTStruct where  RPTStructid=aRowID;
 end; 

procedure RPTStruct_ISLOCKED /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTStruct where RPTStructid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  RPTStruct_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZRprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure RPTStruct_LOCK /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 RPTStruct_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  RPTStruct_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from RPTStruct where RPTStructid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=RPTStruct');
    return;
  end if;
   if  aLockMode =2  
   then   
    update RPTStruct set LockUserID =auserID ,LockSessionID =null where RPTStructid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTStruct set LockUserID =null,LockSessionID =aCURSESSION  where RPTStructid=aRowID;
     return;
   end if;
 end ;

procedure RPTStruct_HCL /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_RPTFields is select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRowid;
row_RPTFields lch_RPTFields%ROWTYPE;
begin  
--open lch_RPTFields;
for row_RPTFields in lch_RPTFields
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from RPTFields where RPTFieldsid=row_RPTFields.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_RPTFields;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_RPTFields;
     return;
   end if; 
 end if;  
 RPTFields_HCL (acursession,row_RPTFields.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_RPTFields;
   return;
 end if;
end loop;
--close lch_RPTFields;
end;
aIsLocked :=0;
end;

procedure RPTStruct_UNLOCK /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 RPTStruct_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTStruct set LockUserID =null  where RPTStructid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTStruct set LockSessionID =null  where RPTStructid=aRowID;
     return;
   end if;
 end; 

procedure RPTStruct_SINIT /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from RPTStruct where RPTStructid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =RPTStruct');
    return;
  end if;
if aSecurityStyleID is null then
 RPTStruct_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update RPTStruct set securitystyleid =aStyleID where RPTStructid = aRowID;
else 
 update RPTStruct set securitystyleid =aSecurityStyleID where RPTStructid = aRowID;
end if; 
end ; 

procedure RPTStruct_propagate /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from RPTStruct where RPTStructid=aRowid;
declare cursor pch_RPTFields  is select RPTFields.RPTFieldsid ID from RPTFields where  RPTFields.ParentStructRowID = aRowid;
row_RPTFields  pch_RPTFields%ROWTYPE;
begin
--open pch_RPTFields;
for row_RPTFields in pch_RPTFields loop
   RPTFields_SINIT( acursession,row_RPTFields.id,assid);
   RPTFields_propagate( acursession,row_RPTFields.id);
end loop;
--close pch_RPTFields;
end;
end;


procedure RPTFields_BRIEF  (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aRPTFieldsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from RPTFields where RPTFieldsid=aRPTFieldsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=RPTFields');
    return;
  end if;
  aBRIEF:=func.RPTFields_BRIEF_F(aRPTFieldsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure RPTFields_DELETE /*Поля секции*/ (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from RPTFields where RPTFieldsid=aRPTFieldsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:RPTFields',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=RPTFields');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTFields_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTFieldsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTFields');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_RPTFields is select  instanceid ID from instance where OwnerPartName ='RPTFields' and OwnerRowID=aRPTFieldsid;
row_RPTFields  chld_RPTFields%ROWTYPE;
begin
--open chld_RPTFields;
for row_RPTFields in chld_RPTFields loop
 Kernel.INSTANCE_OWNER (acursession,row_RPTFields.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_RPTFields.id);
end loop;
--close chld_RPTFields;
end ;
  delete from  RPTFields 
  where  RPTFieldsID = aRPTFieldsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поля секции*/
procedure RPTFields_SAVE /*Поля секции*/ (
 aCURSESSION CHAR,
 aRPTFieldsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aFieldType CHAR/* Тип поля *//* Тип поля */
,aFieldSize
 NUMBER := null /* Размер *//* Размер */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTFields where RPTFieldsID=aRPTFieldsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from RPTFields where RPTFieldsid=aRPTFieldsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:RPTFields',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=RPTFields');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTFields_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTFieldsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFields');
    return;
  end if;
 -- update row  --
 update  RPTFields set ChangeStamp=sysdate
,
  Name=aName
,
  FieldType=aFieldType
,
  FieldSize=aFieldSize
,
  Caption=aCaption
  where  RPTFieldsID = aRPTFieldsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from RPTStruct where RPTStructid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:RPTFields',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=RPTFields');
      return;
    end if;
 end if;
 RPTStruct_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFields');
    return;
  end if;
 insert into   RPTFields
 (  RPTFieldsID 
,ParentStructRowID
,Name

,FieldType

,FieldSize

,Caption

 ) values ( aRPTFieldsID 
,aParentStructRowID
,aName

,aFieldType

,aFieldSize

,aCaption

 ); 
 RPTFields_SINIT( aCURSESSION,aRPTFieldsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure RPTFields_PARENT /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from RPTFields where  RPTFieldsid=aRowID;
  aParentTable := 'RPTStruct';
 end; 

procedure RPTFields_ISLOCKED /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTFields where RPTFieldsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  RPTFields_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZRprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure RPTFields_LOCK /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 RPTFields_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  RPTFields_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from RPTFields where RPTFieldsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=RPTFields');
    return;
  end if;
   if  aLockMode =2  
   then   
    update RPTFields set LockUserID =auserID ,LockSessionID =null where RPTFieldsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTFields set LockUserID =null,LockSessionID =aCURSESSION  where RPTFieldsid=aRowID;
     return;
   end if;
 end ;

procedure RPTFields_HCL /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure RPTFields_UNLOCK /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 RPTFields_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTFields set LockUserID =null  where RPTFieldsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTFields set LockSessionID =null  where RPTFieldsid=aRowID;
     return;
   end if;
 end; 

procedure RPTFields_SINIT /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from RPTFields where RPTFieldsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =RPTFields');
    return;
  end if;
if aSecurityStyleID is null then
 RPTFields_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update RPTFields set securitystyleid =aStyleID where RPTFieldsid = aRowID;
else 
 update RPTFields set securitystyleid =aSecurityStyleID where RPTFieldsid = aRowID;
end if; 
end ; 

procedure RPTFields_propagate /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from RPTFields where RPTFieldsid=aRowid;
end;


procedure RPTFormula_BRIEF  (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aRPTFormulaid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from RPTFormula where RPTFormulaid=aRPTFormulaID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=RPTFormula');
    return;
  end if;
  aBRIEF:=func.RPTFormula_BRIEF_F(aRPTFormulaid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure RPTFormula_DELETE /*Формулы*/ (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from RPTFormula where RPTFormulaid=aRPTFormulaID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:RPTFormula',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=RPTFormula');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTFormula_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTFormulaid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=RPTFormula');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_RPTFormula is select  instanceid ID from instance where OwnerPartName ='RPTFormula' and OwnerRowID=aRPTFormulaid;
row_RPTFormula  chld_RPTFormula%ROWTYPE;
begin
--open chld_RPTFormula;
for row_RPTFormula in chld_RPTFormula loop
 Kernel.INSTANCE_OWNER (acursession,row_RPTFormula.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_RPTFormula.id);
end loop;
--close chld_RPTFormula;
end ;
  delete from  RPTFormula 
  where  RPTFormulaID = aRPTFormulaID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Формулы*/
procedure RPTFormula_SAVE /*Формулы*/ (
 aCURSESSION CHAR,
 aRPTFormulaid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aCode VARCHAR2 := null /* Выражение *//* Выражение */
,aPlatform CHAR := null /* Платформа *//* Платформа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from RPTFormula where RPTFormulaID=aRPTFormulaID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from RPTFormula where RPTFormulaid=aRPTFormulaID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:RPTFormula',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=RPTFormula');
      return;
    end if;
  end if;
 --  verify lock  --
 RPTFormula_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aRPTFormulaid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFormula');
    return;
  end if;
 -- update row  --
 update  RPTFormula set ChangeStamp=sysdate
,
  Name=aName
,
  Code=aCode
,
  Platform=aPlatform
  where  RPTFormulaID = aRPTFormulaID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:RPTFormula',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=RPTFormula');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=RPTFormula');
    return;
  end if;
 insert into   RPTFormula
 (  RPTFormulaID 
,InstanceID
,Name

,Code

,Platform

 ) values ( aRPTFormulaID 
,aInstanceID
,aName

,aCode

,aPlatform

 ); 
 RPTFormula_SINIT( aCURSESSION,aRPTFormulaid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure RPTFormula_PARENT /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from RPTFormula where  RPTFormulaid=aRowID;
 end; 

procedure RPTFormula_ISLOCKED /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from RPTFormula where RPTFormulaid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  RPTFormula_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZRprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure RPTFormula_LOCK /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 RPTFormula_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  RPTFormula_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from RPTFormula where RPTFormulaid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=RPTFormula');
    return;
  end if;
   if  aLockMode =2  
   then   
    update RPTFormula set LockUserID =auserID ,LockSessionID =null where RPTFormulaid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update RPTFormula set LockUserID =null,LockSessionID =aCURSESSION  where RPTFormulaid=aRowID;
     return;
   end if;
 end ;

procedure RPTFormula_HCL /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure RPTFormula_UNLOCK /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 RPTFormula_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update RPTFormula set LockUserID =null  where RPTFormulaid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update RPTFormula set LockSessionID =null  where RPTFormulaid=aRowID;
     return;
   end if;
 end; 

procedure RPTFormula_SINIT /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from RPTFormula where RPTFormulaid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =RPTFormula');
    return;
  end if;
if aSecurityStyleID is null then
 RPTFormula_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update RPTFormula set securitystyleid =aStyleID where RPTFormulaid = aRowID;
else 
 update RPTFormula set securitystyleid =aSecurityStyleID where RPTFormulaid = aRowID;
end if; 
end ; 

procedure RPTFormula_propagate /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from RPTFormula where RPTFormulaid=aRowid;
end;


procedure Reports_BRIEF  (
 aCURSESSION CHAR,
 aReportsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aReportsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from Reports where Reportsid=aReportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=Reports');
    return;
  end if;
  aBRIEF:=func.Reports_BRIEF_F(aReportsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure Reports_DELETE /*Описание*/ (
 aCURSESSION CHAR,
 aReportsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from Reports where Reportsid=aReportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:Reports',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=Reports');
      return;
    end if;
  end if;
 --  verify lock  --
 Reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aReportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=Reports');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_Reports is select  instanceid ID from instance where OwnerPartName ='Reports' and OwnerRowID=aReportsid;
row_Reports  chld_Reports%ROWTYPE;
begin
--open chld_Reports;
for row_Reports in chld_Reports loop
 Kernel.INSTANCE_OWNER (acursession,row_Reports.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_Reports.id);
end loop;
--close chld_Reports;
end ;
  delete from  Reports 
  where  ReportsID = aReportsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure Reports_SAVE /*Описание*/ (
 aCURSESSION CHAR,
 aReportsid CHAR,
aInstanceID CHAR 
,aName
 VARCHAR2/* Название *//* Название */
,aReportFile VARCHAR2 := null /* Файл отчета */
,aReportFile_EXT varchar2 /* Файл отчета */
,aCaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aPrepareMethod CHAR := null /* Метод для формирования *//* Метод для формирования */
,aReportType
 NUMBER/* Тип отчета *//* Тип отчета */
,aTheReportExt CHAR := null /* Расширение для создания отчета *//* Расширение для создания отчета */
,aReportView
 VARCHAR2 := null /* Базовый запрос *//* Базовый запрос */
,aTheComment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype='MTZSYSTEM';
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from Reports where ReportsID=aReportsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from Reports where Reportsid=aReportsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:Reports',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=Reports');
      return;
    end if;
  end if;
 --  verify lock  --
 Reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aReportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Reports');
    return;
  end if;
 -- update row  --
 update  Reports set ChangeStamp=sysdate
,
  Name=aName
,
  ReportFile=aReportFile
,ReportFile_EXT=
aReportFile_EXT 
,
  Caption=aCaption
,
  PrepareMethod=aPrepareMethod
,
  ReportType=aReportType
,
  TheReportExt=aTheReportExt
,
  ReportView=aReportView
,
  TheComment=aTheComment
  where  ReportsID = aReportsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:Reports',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=Reports');
      return;
    end if;
 end if;
 MTZ.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=Reports');
    return;
  end if;
select Count(*) into existsCnt from Reports where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;Reports&gt;');
    return;
 End if;
 insert into   Reports
 (  ReportsID 
,InstanceID
,Name

,ReportFile

,ReportFile_EXT
,Caption

,PrepareMethod

,ReportType

,TheReportExt

,ReportView

,TheComment

 ) values ( aReportsID 
,aInstanceID
,aName

,aReportFile

,aReportFile_EXT
,aCaption

,aPrepareMethod

,aReportType

,aTheReportExt

,aReportView

,aTheComment

 ); 
 Reports_SINIT( aCURSESSION,aReportsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure Reports_PARENT /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from Reports where  Reportsid=aRowID;
 end; 

procedure Reports_ISLOCKED /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from Reports where Reportsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  Reports_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin MTZRprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure Reports_LOCK /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 Reports_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  Reports_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from Reports where Reportsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=Reports');
    return;
  end if;
   if  aLockMode =2  
   then   
    update Reports set LockUserID =auserID ,LockSessionID =null where Reportsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update Reports set LockUserID =null,LockSessionID =aCURSESSION  where Reportsid=aRowID;
     return;
   end if;
 end ;

procedure Reports_HCL /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure Reports_UNLOCK /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 Reports_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update Reports set LockUserID =null  where Reportsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update Reports set LockSessionID =null  where Reportsid=aRowID;
     return;
   end if;
 end; 

procedure Reports_SINIT /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from Reports where Reportsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =Reports');
    return;
  end if;
if aSecurityStyleID is null then
 Reports_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update Reports set securitystyleid =aStyleID where Reportsid = aRowID;
else 
 update Reports set securitystyleid =aSecurityStyleID where Reportsid = aRowID;
end if; 
end ; 

procedure Reports_propagate /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from Reports where Reportsid=aRowid;
end;
end MTZRprt;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Init" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

create or replace procedure InitBase as 
aid CHAR(38);
ainstid CHAR(38);
auid CHAR(38);
aSESSION CHAR(38);
acid CHAR(38);
asecid CHAR(38);
ahid CHAR(38);
atmpstr varchar2(255);
begin
ainstid := 'ee28f9e4-afe3-44e9-8fef-411e81913423';
auid := '38def86a-191e-49a8-963b-63e0c94f4f99'; 
asecid := '993daafd-589e-480d-97ff-1f9ab0568800'; --user security instance 
ahid := '27f56741-4140-4c9c-909b-446eca089409'; -- helper id
delete from users;
delete from typelist;
delete from sysoptions;
delete from instance;
insert into instance(InstanceID,OBJTYPE,Name) values(ainstid, 'MTZSYSTEM','Системная информация');
insert into instance(InstanceID,OBJTYPE,Name) values(asecid, 'MTZUsers', 'Пользователи и группы');
insert into users(usersid,instanceid,login,password,name) values('76cf54c1-4bf0-4f1e-ae49-035c433782d7',asecid,'supervisor','bami','Администратор');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZMetaModel', 'MTZMetaModel_DELETE', 'MTZMetaModel_HCL', 'MTZMetaModel_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZJrnl', 'MTZJrnl_DELETE', 'MTZJrnl_HCL', 'MTZJrnl_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tod', 'tod_DELETE', 'tod_HCL', 'tod_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'STDInfoStore', 'STDInfoStore_DELETE', 'STDInfoStore_HCL', 'STDInfoStore_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZSystem', 'MTZSystem_DELETE', 'MTZSystem_HCL', 'MTZSystem_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZwp', 'MTZwp_DELETE', 'MTZwp_HCL', 'MTZwp_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'ROLES', 'ROLES_DELETE', 'ROLES_HCL', 'ROLES_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'totask', 'totask_DELETE', 'totask_HCL', 'totask_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZUsers', 'MTZUsers_DELETE', 'MTZUsers_HCL', 'MTZUsers_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tooper', 'tooper_DELETE', 'tooper_HCL', 'tooper_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'STDNumerator', 'STDNumerator_DELETE', 'STDNumerator_HCL', 'STDNumerator_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZExt', 'MTZExt_DELETE', 'MTZExt_HCL', 'MTZExt_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'toact', 'toact_DELETE', 'toact_HCL', 'toact_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZ2JOB', 'MTZ2JOB_DELETE', 'MTZ2JOB_HCL', 'MTZ2JOB_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZFltr', 'MTZFltr_DELETE', 'MTZFltr_HCL', 'MTZFltr_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'MTZRprt', 'MTZRprt_DELETE', 'MTZRprt_HCL', 'MTZRprt_propagate');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'a9d13db7-f13b-4c78-8790-d263d5a970ed', aName=&gt;'GENPACKAGE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d81baef1-b6a2-4441-a861-a9f66293163d', aName=&gt;'GENERATOR_TARGET', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'69c879e6-5803-4f66-b9b0-ae4347c53ce1', aName=&gt;'GENERATOR_TARGET', aValue=&gt;'GENPACKAGE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'def245da-30ae-4a76-b58d-32c8d11b60d7', aName=&gt;'GENREFERENCE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'2d00c138-719a-47de-b7a0-69689e240659', aName=&gt;'GENREFERENCE', aValue=&gt;'GENERATOR_TARGET', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ece9f87c-b4f5-44dd-b5e3-159089332d53', aName=&gt;'GENMANUALCODE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'23b0c317-14da-473d-b1ad-99efc84cd196', aName=&gt;'GENMANUALCODE', aValue=&gt;'GENERATOR_TARGET', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'a7e7647c-4b0b-4952-acfe-251f6d2b1604', aName=&gt;'GENCONTROLS', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'ff8de6ad-1024-4884-9ef3-d0c7a32ead1b', aName=&gt;'GENCONTROLS', aValue=&gt;'GENERATOR_TARGET', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'5426f592-e8d2-44c1-8cef-f6fecc621fda', aName=&gt;'GENPACKAGE', aValue=&gt;'AUTOGENPACKAGE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3a47de37-b043-4277-a9b3-6d7ae228b78d', aName=&gt;'GENERATOR_TARGET', aValue=&gt;'AUTOGENERATOR_TARGET', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'8a630815-287f-4ebb-8574-2398f019013d', aName=&gt;'GENREFERENCE', aValue=&gt;'AUTOGENREFERENCE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'63df4844-e5fd-4f87-9476-fe864fce7848', aName=&gt;'GENMANUALCODE', aValue=&gt;'AUTOGENMANUALCODE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'bfb66cb3-20a0-439a-a5da-d78c5e6d123d', aName=&gt;'GENCONTROLS', aValue=&gt;'AUTOGENCONTROLS', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'878da760-09be-40a7-b2cb-cb14224edf20', aName=&gt;'LocalizeInfo', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7f65d271-5e3a-4be8-92d2-d26c56e35f94', aName=&gt;'LocalizeInfo', aValue=&gt;'AUTOLocalizeInfo', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'5db0073f-4a8d-478c-9df2-4acf5f17d89a', aName=&gt;'FIELDTYPE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'0bc965e3-9af9-4dd6-ae61-0419d2816cd8', aName=&gt;'ENUMITEM', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'64bc9ddd-a6eb-44b1-8196-f4756b5e64ad', aName=&gt;'ENUMITEM', aValue=&gt;'FIELDTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'c22b384b-3a33-4b0d-9875-6e073676323f', aName=&gt;'FIELDTYPEMAP', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'03651b0f-a732-419a-b858-87cf253946ed', aName=&gt;'FIELDTYPEMAP', aValue=&gt;'FIELDTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'4751f190-6b1d-48e2-8b7f-b50adc81dbd3', aName=&gt;'FIELDTYPE', aValue=&gt;'AUTOFIELDTYPE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'2737248f-3e88-4602-990d-a345b3145bd0', aName=&gt;'ENUMITEM', aValue=&gt;'AUTOENUMITEM', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'2f8f5b56-77f4-45c3-9c5c-991677bf009c', aName=&gt;'FIELDTYPEMAP', aValue=&gt;'AUTOFIELDTYPEMAP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'a68bfc42-ba0b-4e9f-b43c-c22f6a887134', aName=&gt;'SHAREDMETHOD', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'521a778c-1d02-411a-8af5-8971def082a7', aName=&gt;'SCRIPT', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'cff65a38-fcca-4f0b-a660-33d4a6388405', aName=&gt;'SCRIPT', aValue=&gt;'SHAREDMETHOD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ccb0fd7f-fb1d-4c6a-99c7-1a8565abf123', aName=&gt;'PARAMETERS', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'b9a1b232-bb94-462c-a984-dfd0c9c19fae', aName=&gt;'PARAMETERS', aValue=&gt;'SCRIPT', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'48e60a2a-0d9c-4807-90a5-7093e6975c04', aName=&gt;'SHAREDMETHOD', aValue=&gt;'AUTOSHAREDMETHOD', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'bcef53f0-9bea-49fe-82c5-aec66abfe6a2', aName=&gt;'SCRIPT', aValue=&gt;'AUTOSCRIPT', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1fa48bcd-3fbc-4760-9156-9fbb1678babf', aName=&gt;'PARAMETERS', aValue=&gt;'AUTOPARAMETERS', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f581813e-cd46-4c2f-9827-cb5e6b76c7ca', aName=&gt;'OBJECTTYPE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'4fabfe2f-72a8-469f-ac56-d48b4a1522cc', aName=&gt;'OBJSTATUS', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d023571a-a8e7-4b20-a590-6c358a4bcfb1', aName=&gt;'OBJSTATUS', aValue=&gt;'OBJECTTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'15c360e1-62b0-40b0-8af9-2888713fb658', aName=&gt;'NEXTSTATE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'11b239c9-da07-4438-9bfd-7b47cc9e6d66', aName=&gt;'NEXTSTATE', aValue=&gt;'OBJSTATUS', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'faccc759-7c6a-4a3a-a5b2-c9ce835e1c0a', aName=&gt;'OBJECTMODE', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'18fff991-ebb3-4b80-8514-53146d46f1d6', aName=&gt;'OBJECTMODE', aValue=&gt;'OBJECTTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f436fd5f-8c76-4c7f-9a94-50536a58e3a4', aName=&gt;'STRUCTRESTRICTION', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'4fcfbe5b-a3c5-4799-86b5-cfdd78580a9a', aName=&gt;'STRUCTRESTRICTION', aValue=&gt;'OBJECTMODE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'93c1b60f-1731-40f3-b88e-9f138e0ddde8', aName=&gt;'METHODRESTRICTION', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'bfb11f0e-a953-48fb-9c18-60acaa0a43ea', aName=&gt;'METHODRESTRICTION', aValue=&gt;'OBJECTMODE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'12c3c0dc-294d-405f-9e19-9c4f59729084', aName=&gt;'FIELDRESTRICTION', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1c3cab54-dd31-4c54-ba2f-6ff5e3439a42', aName=&gt;'FIELDRESTRICTION', aValue=&gt;'OBJECTMODE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'a49b593b-11c2-4acf-87cf-9c1141ca4fd8', aName=&gt;'TYPEMENU', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'28093c41-690e-4755-b538-654b7806899d', aName=&gt;'TYPEMENU', aValue=&gt;'OBJECTTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f456edef-d69c-40eb-8902-c49b68855731', aName=&gt;'INSTANCEVALIDATOR', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'de53e14c-deb4-4ea0-8589-01ac3fc4016f', aName=&gt;'INSTANCEVALIDATOR', aValue=&gt;'OBJECTTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'bd4cad32-72d4-40a6-b8bf-e163e2dbd948', aName=&gt;'PART', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3bdeb3ad-05e8-4dc1-8bed-8aeaecbf3360', aName=&gt;'PART', aValue=&gt;'OBJECTTYPE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'84c2925d-b29f-4479-8778-9a32ab18ce55', aName=&gt;'PARTMENU', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'4561bd06-62d6-42f6-87d6-42045dd04bc3', aName=&gt;'PARTMENU', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f80cdf54-74d5-4178-bd81-16ed99eb01cc', aName=&gt;'PARTPARAMMAP', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'03bb5cbb-b464-45ad-a371-48cd9dc8db8c', aName=&gt;'PARTPARAMMAP', aValue=&gt;'PARTMENU', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'9a50c6fe-1548-4de7-9ed8-ddc673b6c22c', aName=&gt;'PARTVIEW', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7158eda6-983d-4c44-810f-215384920d5e', aName=&gt;'PARTVIEW', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'2b9a3aed-3b2c-4c48-8c15-954fd5996112', aName=&gt;'ViewColumn', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3097d9ed-29b8-4cc9-b414-62312d302a8e', aName=&gt;'ViewColumn', aValue=&gt;'PARTVIEW', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'1b0bac13-ff9e-45b2-a7ee-e09c695157b2', aName=&gt;'PARTVIEW_LNK', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6d11a5b8-8103-4e6d-b9ab-e3d47cb362c5', aName=&gt;'PARTVIEW_LNK', aValue=&gt;'PARTVIEW', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ff882c2f-13df-4b54-a96d-1ccb78f75a04', aName=&gt;'VALIDATOR', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c906f847-6565-4078-bb5d-5e2679c670ee', aName=&gt;'VALIDATOR', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'4e2d1673-a72a-4729-9688-a21b075ead28', aName=&gt;'UNIQUECONSTRAINT', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'285bcc5d-dad1-472a-8aa6-faf06c684063', aName=&gt;'UNIQUECONSTRAINT', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'1dca18b0-78d0-4af1-a8cc-e53846afba59', aName=&gt;'CONSTRAINTFIELD', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'203f5750-0e5d-4e2e-b74b-30c866a75e1f', aName=&gt;'CONSTRAINTFIELD', aValue=&gt;'UNIQUECONSTRAINT', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'c63426e6-121c-41ab-b771-67ad3bc6d535', aName=&gt;'ExtenderInterface', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c8acc0a9-ebbf-4d3c-90bd-8b2aff66af1e', aName=&gt;'ExtenderInterface', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'c3ba4b0f-9dd3-40b3-80a3-b2e3846c70d5', aName=&gt;'FIELD', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'44642d93-5c69-4a02-bc7b-cadfc586d4b8', aName=&gt;'FIELD', aValue=&gt;'PART', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d86634db-ab9f-4789-876d-9fbcef1e274e', aName=&gt;'FldExtenders', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'a343b47e-d7e5-4217-a73c-2ffa67bb0879', aName=&gt;'FldExtenders', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ff000879-3651-4c4c-8f43-ca89812bb074', aName=&gt;'FIELDSRCDEF', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d24e7acd-dcf9-45b0-bda9-157b5638cb56', aName=&gt;'FIELDSRCDEF', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b6173f3e-82d2-4e54-b7ac-d1d07d7ae9b6', aName=&gt;'DINAMICFILTERSCRIPT', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'10a530ec-7bfd-48d9-a5b7-0e93ac164d45', aName=&gt;'DINAMICFILTERSCRIPT', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'34ae8b58-5bb7-44e3-a6c5-735223814596', aName=&gt;'FIELDEXPRESSION', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f95f1793-10a2-4c09-8384-ffe09844b2e5', aName=&gt;'FIELDEXPRESSION', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'0754f72e-fe37-4d2d-bfef-7a760821751e', aName=&gt;'FIELDVALIDATOR', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'91e1fb7f-24a2-4587-9ff3-a6f306b104fe', aName=&gt;'FIELDVALIDATOR', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f094185d-07e6-4433-927c-e8161d4c42c5', aName=&gt;'FIELDMENU', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'78de4f4b-992f-472b-96ca-2cc506b8736d', aName=&gt;'FIELDMENU', aValue=&gt;'FIELD', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'9dc705c9-3630-4121-aa63-e5c2abba055b', aName=&gt;'FIELDPARAMMAP', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'be04baae-fdaa-4101-acfb-203c213487a6', aName=&gt;'FIELDPARAMMAP', aValue=&gt;'FIELDMENU', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e34bc24d-e567-4776-a46c-f597ba854a43', aName=&gt;'OBJECTTYPE', aValue=&gt;'AUTOOBJECTTYPE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c4acc1ee-088a-4bbc-b31f-daeab956fd45', aName=&gt;'OBJSTATUS', aValue=&gt;'AUTOOBJSTATUS', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1db30afb-201b-46ac-b989-65639140295e', aName=&gt;'NEXTSTATE', aValue=&gt;'AUTONEXTSTATE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'073ec315-0a87-4fb7-9842-ce60ee5b34f5', aName=&gt;'OBJECTMODE', aValue=&gt;'AUTOOBJECTMODE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'a7a75dce-6eaf-4464-bb5f-65e9d604c8a4', aName=&gt;'STRUCTRESTRICTION', aValue=&gt;'AUTOSTRUCTRESTRICTION', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'ef96f476-604e-4b0b-b5f9-aec7ebfaf5d5', aName=&gt;'METHODRESTRICTION', aValue=&gt;'AUTOMETHODRESTRICTION', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6298a72b-243b-433e-9851-20430408cc60', aName=&gt;'FIELDRESTRICTION', aValue=&gt;'AUTOFIELDRESTRICTION', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'48cec391-5707-4a4a-a567-3db25e66a9fe', aName=&gt;'TYPEMENU', aValue=&gt;'AUTOTYPEMENU', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7c3060dd-0785-4329-801e-0fe211da8744', aName=&gt;'INSTANCEVALIDATOR', aValue=&gt;'AUTOINSTANCEVALIDATOR', aOptionType=&gt;'DEFVIEW');


MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'4f8b2f6c-1be5-4aaa-9d61-5cd444bd2453', aName=&gt;'PARTMENU', aValue=&gt;'AUTOPARTMENU', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f7c0caa7-e6f6-4a1a-a5d0-20dec6d849e0', aName=&gt;'PARTPARAMMAP', aValue=&gt;'AUTOPARTPARAMMAP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'5ec07ec3-7e3d-42e6-a488-ee26af3feaba', aName=&gt;'PARTVIEW', aValue=&gt;'AUTOPARTVIEW', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'30e939d1-f2c6-4f22-911d-3bf182749ba2', aName=&gt;'ViewColumn', aValue=&gt;'AUTOViewColumn', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3024745e-9cb6-400a-8645-ca1a7aa188bc', aName=&gt;'PARTVIEW_LNK', aValue=&gt;'AUTOPARTVIEW_LNK', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'dfd78e23-86d9-4155-861a-47547eee75c1', aName=&gt;'VALIDATOR', aValue=&gt;'AUTOVALIDATOR', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'b26f45fd-af87-4c2d-a495-5e67b6af0539', aName=&gt;'UNIQUECONSTRAINT', aValue=&gt;'AUTOUNIQUECONSTRAINT', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'93436f0f-74f5-4bfd-a0b5-726fa9c38785', aName=&gt;'CONSTRAINTFIELD', aValue=&gt;'AUTOCONSTRAINTFIELD', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1aa6b319-2047-4c06-a794-7ac792b7f351', aName=&gt;'ExtenderInterface', aValue=&gt;'AUTOExtenderInterface', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'403870fe-c67b-4b80-a41b-9fa2d90ec81a', aName=&gt;'FIELD', aValue=&gt;'AUTOFIELD', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1628a775-a12f-4bc2-a777-d4688fa7d6bc', aName=&gt;'FldExtenders', aValue=&gt;'AUTOFldExtenders', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'37fbf961-d6d1-4012-b458-4dc7c27ee021', aName=&gt;'FIELDSRCDEF', aValue=&gt;'AUTOFIELDSRCDEF', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'66014338-36cd-485c-a8b9-01c2220e51e4', aName=&gt;'DINAMICFILTERSCRIPT', aValue=&gt;'AUTODINAMICFILTERSCRIPT', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'ec4cdb72-fb5f-48d8-b98d-d28e9200633e', aName=&gt;'FIELDEXPRESSION', aValue=&gt;'AUTOFIELDEXPRESSION', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c02baf6f-6238-414d-b527-5a7387772bdc', aName=&gt;'FIELDVALIDATOR', aValue=&gt;'AUTOFIELDVALIDATOR', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'54a54e33-31d3-46e1-bc4e-9ae9b60b6661', aName=&gt;'FIELDMENU', aValue=&gt;'AUTOFIELDMENU', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'a55e875a-6c71-4d07-afb9-3580ec643380', aName=&gt;'FIELDPARAMMAP', aValue=&gt;'AUTOFIELDPARAMMAP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'2c3bba40-47ca-4377-84ec-d17262021159', aName=&gt;'MTZAPP', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'620bafac-5825-4b38-8697-57374889b729', aName=&gt;'ParentPackage', aValue=&gt;'MTZMetaModel', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'45543174-af32-48c8-8bd9-3d59ba0d04cd', aName=&gt;'ParentPackage', aValue=&gt;'MTZAPP', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'fb62e1a3-7b4f-4a3c-9aca-cc1f92bdf540', aName=&gt;'MTZAPP', aValue=&gt;'AUTOMTZAPP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f6be89bd-0d15-455c-ad1b-708f0f942f39', aName=&gt;'ParentPackage', aValue=&gt;'AUTOParentPackage', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'7c845ce4-6b84-4664-ab30-1472bd5ff0f7', aName=&gt;'JournalColumn', aValue=&gt;'MTZJrnl', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'fbb263a6-43e7-45d5-a484-76d05f2b8c99', aName=&gt;'JColumnSource', aValue=&gt;'MTZJrnl', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'180dbcce-2730-42ff-b058-49271d147789', aName=&gt;'JColumnSource', aValue=&gt;'JournalColumn', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'bd57a1f5-a8c6-410e-8e41-bae7cb35d007', aName=&gt;'JournalColumn', aValue=&gt;'AUTOJournalColumn', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'92778e38-054c-465f-bed7-237654942da9', aName=&gt;'JColumnSource', aValue=&gt;'AUTOJColumnSource', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'4be6cfcb-ce9a-497f-8ce7-7ca155584d08', aName=&gt;'JournalSrc', aValue=&gt;'MTZJrnl', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'55ae0d69-6bb4-4f56-86b4-3e6833b0379f', aName=&gt;'JournalSrc', aValue=&gt;'AUTOJournalSrc', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ab57a1df-91b6-4f49-9312-ff7c70eb8297', aName=&gt;'Journal', aValue=&gt;'MTZJrnl', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'32ba14df-0464-4d77-88ac-5c6055a35c99', aName=&gt;'Journal', aValue=&gt;'AUTOJournal', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'bca85603-5c48-4d16-be3f-b29f25654149', aName=&gt;'tod_bug', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');


MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d5133bc3-07a6-4a33-892d-5b5584648a2b', aName=&gt;'tod_st', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');


MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d3a9465e-0b96-4b53-9a81-a55dd5219a41', aName=&gt;'Folder', aValue=&gt;'STDInfoStore', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'16d22d31-cd6b-4482-aeb5-8d82f3d57c6d', aName=&gt;'Shortcut', aValue=&gt;'STDInfoStore', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'36863cd4-5018-4c38-8932-00cda55ec264', aName=&gt;'Shortcut', aValue=&gt;'Folder', aOptionType=&gt;'PARENT');


MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6a9d8f8e-8f0a-4d5c-abee-4f3a653d33ad', aName=&gt;'Shortcut', aValue=&gt;'AUTOShortcut', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'997e508b-a0cf-4daf-b004-df3922113bba', aName=&gt;'InfoStoreDef', aValue=&gt;'STDInfoStore', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'b39c5a67-e3df-4ade-8fce-a3fa569677c8', aName=&gt;'InfoStoreDef', aValue=&gt;'AUTOInfoStoreDef', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b2fc3435-1965-420c-a428-2929308447ac', aName=&gt;'the_Session', aValue=&gt;'MTZSystem', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d2b45e08-4d04-4285-970a-123d3ac6c9d6', aName=&gt;'the_Session', aValue=&gt;'AUTOthe_Session', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'c2913043-21d1-472a-ad50-02d5fc03afe7', aName=&gt;'SysRefCache', aValue=&gt;'MTZSystem', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'4fc37f53-3d12-4d75-9e20-2efad88bd726', aName=&gt;'SysRefCache', aValue=&gt;'AUTOSysRefCache', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d848f6d2-2959-43ce-8f64-7155ae119a05', aName=&gt;'SysLog', aValue=&gt;'MTZSystem', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'0e1b575e-2c5f-43e6-a601-eea8ae0bdb84', aName=&gt;'SysLog', aValue=&gt;'AUTOSysLog', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'194db352-47c6-46b4-9605-42ea3807ee16', aName=&gt;'ARMJournal', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'fe4b2823-20f3-4af3-beb9-b1290971c284', aName=&gt;'ARMJRNLREP', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f3dcf7bb-b9d8-421e-9399-5e77bff2678a', aName=&gt;'ARMJRNLREP', aValue=&gt;'ARMJournal', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'118bfa22-6d43-4e12-b596-f7117ec035e5', aName=&gt;'ARMJRNLRUN', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'8b8391e4-837c-4a3d-9547-838d115d13aa', aName=&gt;'ARMJRNLRUN', aValue=&gt;'ARMJournal', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'2f39b9c7-3510-4682-89da-749056aa2688', aName=&gt;'ARMJRNLADD', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6d00c414-7c25-4cf7-9208-c2d0d601cf23', aName=&gt;'ARMJRNLADD', aValue=&gt;'ARMJournal', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7bd62cdb-f734-4f2c-a2a6-72a30cde9d47', aName=&gt;'ARMJournal', aValue=&gt;'AUTOARMJournal', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'80199746-6c06-4674-847c-6828f00652ec', aName=&gt;'ARMJRNLREP', aValue=&gt;'AUTOARMJRNLREP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'fa1808f4-6f2e-40b5-bfd0-bad6a1520c84', aName=&gt;'ARMJRNLRUN', aValue=&gt;'AUTOARMJRNLRUN', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6fc80045-40f9-40aa-a95e-f6227c63d3ee', aName=&gt;'ARMJRNLADD', aValue=&gt;'AUTOARMJRNLADD', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'0adf47a1-6f9f-4e86-983f-20046c09a8de', aName=&gt;'EntryPoints', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'230baa26-a354-4a3c-b07d-fbf422ad4f16', aName=&gt;'EPFilterLink', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6e717f09-9bc8-46ee-a656-6581a8b3b353', aName=&gt;'EPFilterLink', aValue=&gt;'EntryPoints', aOptionType=&gt;'PARENT');


MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d17b23aa-ff06-4cd6-bf68-523814df248c', aName=&gt;'EPFilterLink', aValue=&gt;'AUTOEPFilterLink', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'4bec1f9b-89fc-41d8-88cb-a953fa4e706c', aName=&gt;'WorkPlace', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'0a1581d2-8c2d-4e9b-81e5-cf432e28f4aa', aName=&gt;'WorkPlace', aValue=&gt;'AUTOWorkPlace', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b84fa687-1ae4-4cc6-8157-1d259fe9d894', aName=&gt;'ARMTypes', aValue=&gt;'MTZwp', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7e1f6af9-eee2-41e0-9d88-7e973c0f447a', aName=&gt;'ARMTypes', aValue=&gt;'AUTOARMTypes', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'21a2a80c-899e-4381-9bb2-7e1ed9d84fd8', aName=&gt;'ROLES_OPERATIONS', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'624da2e9-8044-441e-a8f9-8809f166b40b', aName=&gt;'ROLES_OPERATIONS', aValue=&gt;'AUTOROLES_OPERATIONS', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'cb908a72-ef66-43ef-88ea-0bae1ff6c714', aName=&gt;'ROLES_WP', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f41b31ce-f68c-4a02-afc1-9b41ecc7dbe1', aName=&gt;'ROLES_ACT', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'90fe0d2f-69e9-43ab-9b57-022d6b3e1369', aName=&gt;'ROLES_ACT', aValue=&gt;'ROLES_WP', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'dd9beb01-73eb-4df7-9b6f-e53eb5e8e3b4', aName=&gt;'ROLES_WP', aValue=&gt;'AUTOROLES_WP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c6762489-98f1-4312-a443-d21c473a0575', aName=&gt;'ROLES_ACT', aValue=&gt;'AUTOROLES_ACT', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'8099f953-df66-48b7-a621-66198141bba9', aName=&gt;'ROLES2_MODULE', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'3a22ce1f-42ec-4ddc-9e33-24a46364651d', aName=&gt;'ROLES2_MODREPORT', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'92ed1eca-16ba-4fd6-b1ff-e02b6cbbea32', aName=&gt;'ROLES2_MODREPORT', aValue=&gt;'ROLES2_MODULE', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'570109a6-9d0e-4976-8edf-dde17cd90afd', aName=&gt;'ROLES2_MODULE', aValue=&gt;'AUTOROLES2_MODULE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'17af67e2-0ce0-48bf-a230-9c5ce7cc5bf1', aName=&gt;'ROLES2_MODREPORT', aValue=&gt;'AUTOROLES2_MODREPORT', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'12c13b65-eae9-4f61-a8a2-e66f75822260', aName=&gt;'ROLES_DOC', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'d4e9ca69-304e-493d-97d1-83feb49bae68', aName=&gt;'ROLES_DOC_STATE', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'427c5afd-4294-40f6-a9e9-2fc4b2b7b84f', aName=&gt;'ROLES_DOC_STATE', aValue=&gt;'ROLES_DOC', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'59f58786-00b0-4933-8a5a-b0b19fc525df', aName=&gt;'ROLES_DOC', aValue=&gt;'AUTOROLES_DOC', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e8d2a965-c8f8-4f7e-810f-b4f6a7d17b8f', aName=&gt;'ROLES_DOC_STATE', aValue=&gt;'AUTOROLES_DOC_STATE', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'676b1dbf-6b24-4841-a24d-e5c5b8196392', aName=&gt;'ROLES_REPORTS', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'059d4e45-4d0a-4458-9b04-5124fa9fa0ae', aName=&gt;'ROLES_REPORTS', aValue=&gt;'AUTOROLES_REPORTS', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'bc2f1bc0-0065-4f1e-bc47-430471273162', aName=&gt;'ROLES_USER', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'391a3bd9-c18e-4c22-906b-bf2c7942f878', aName=&gt;'ROLES_USER', aValue=&gt;'AUTOROLES_USER', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b02fb5ae-3561-4373-a894-7b95da6cab17', aName=&gt;'ROLES_MAP', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3812e086-765b-48e3-b6af-fb6abe49606e', aName=&gt;'ROLES_MAP', aValue=&gt;'AUTOROLES_MAP', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'2a48158e-8fc4-4b23-a771-ac50081cab15', aName=&gt;'ROLES_DEF', aValue=&gt;'ROLES', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'29699060-3902-4b05-9ff2-9b46def8e20e', aName=&gt;'ROLES_DEF', aValue=&gt;'AUTOROLES_DEF', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b813870d-7d14-44c1-a423-7021580b7927', aName=&gt;'Users', aValue=&gt;'MTZUsers', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'8d8a1043-79f0-42bd-8206-44cad39c4b6e', aName=&gt;'Users', aValue=&gt;'AUTOUsers', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'837223ee-b845-4ace-8b5f-91171ac54113', aName=&gt;'Groups', aValue=&gt;'MTZUsers', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'6646062b-f137-4bbb-b687-43cd0aa269bc', aName=&gt;'GroupUser', aValue=&gt;'MTZUsers', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'2c2cbb19-fe63-4fd5-b063-c72a374cb948', aName=&gt;'GroupUser', aValue=&gt;'Groups', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'5a0212c9-2d5c-43d9-a89b-38733fd2767d', aName=&gt;'Groups', aValue=&gt;'AUTOGroups', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e1b16a7a-8e64-4df6-9376-b17cfa9f1fd9', aName=&gt;'GroupUser', aValue=&gt;'AUTOGroupUser', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'ff6d2a9d-2bc7-4409-a249-86a512cfba7a', aName=&gt;'Num_zones', aValue=&gt;'STDNumerator', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'e75ae0f3-aba1-45fc-936a-ab4c66d7b9b0', aName=&gt;'Num_Values', aValue=&gt;'STDNumerator', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e035d06e-d06a-4de3-b5fd-e2bebf878c0a', aName=&gt;'Num_Values', aValue=&gt;'Num_zones', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'9c136f5f-b507-4e71-9df0-f461ad10106c', aName=&gt;'Num_zones', aValue=&gt;'AUTONum_zones', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'a73165f9-9c5c-4083-8c98-5db7ccc3096e', aName=&gt;'Num_Values', aValue=&gt;'AUTONum_Values', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'a7864253-a03f-416f-8605-e1fafd21df50', aName=&gt;'Num_head', aValue=&gt;'STDNumerator', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'544d77c6-484c-4e55-9ddd-7462cbcaddc2', aName=&gt;'Num_head', aValue=&gt;'AUTONum_head', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'446693cd-a19c-4dd8-8eec-618d08363868', aName=&gt;'MTZExt_def', aValue=&gt;'MTZExt', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'9d311dc7-0791-4c4e-b13f-6c26ecc9a605', aName=&gt;'MTZExt_def', aValue=&gt;'AUTOMTZExt_def', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'b832cbc5-39ea-4b38-9e81-61afa71196ec', aName=&gt;'MTZExtRel', aValue=&gt;'MTZExt', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'8be77482-d5c2-4b71-b32e-5279e431ea06', aName=&gt;'MTZExtRel', aValue=&gt;'AUTOMTZExtRel', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'1ce5d5cf-0131-4021-8b8d-1ee4dd33d20a', aName=&gt;'MTZ2JOB_DEF', aValue=&gt;'MTZ2JOB', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c39890d7-1971-4c51-a82b-68e272d757b3', aName=&gt;'MTZ2JOB_DEF', aValue=&gt;'AUTOMTZ2JOB_DEF', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'1ce557be-079f-45f3-b396-15cfeadf301b', aName=&gt;'FilterFieldGroup', aValue=&gt;'MTZFltr', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'983b20b6-6434-4210-a6cd-7f295015d8e6', aName=&gt;'FileterField', aValue=&gt;'MTZFltr', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d1a118c8-8ba1-45f2-9bc7-c4c3c4bf1a1e', aName=&gt;'FileterField', aValue=&gt;'FilterFieldGroup', aOptionType=&gt;'PARENT');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1a679aba-25c4-4d43-977d-d3b66afbfaba', aName=&gt;'FilterFieldGroup', aValue=&gt;'AUTOFilterFieldGroup', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'ed5ddf5d-3468-49fd-9a9f-6bc231a24a42', aName=&gt;'FileterField', aValue=&gt;'AUTOFileterField', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'f2b0f140-0a02-4af3-8f28-f58618c97903', aName=&gt;'Filters', aValue=&gt;'MTZFltr', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'52431265-ecfd-4aef-9448-61a1bfcc8785', aName=&gt;'Filters', aValue=&gt;'AUTOFilters', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'59bcf26d-e936-43be-99d2-43661adea40c', aName=&gt;'RPTStruct', aValue=&gt;'MTZRprt', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'0a85b079-9344-4fbd-9e0c-b39b73d3491c', aName=&gt;'RPTFields', aValue=&gt;'MTZRprt', aOptionType=&gt;'STRUCT_TYPE');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7f6e5609-1c3c-48e9-b918-1b73cbe83ddd', aName=&gt;'RPTFields', aValue=&gt;'RPTStruct', aOptionType=&gt;'PARENT');


MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'74f86fd3-293c-4fec-9067-56efa66b3b54', aName=&gt;'RPTFields', aValue=&gt;'AUTORPTFields', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'cb37665a-7455-4c13-9eb1-6ca15db04d22', aName=&gt;'RPTFormula', aValue=&gt;'MTZRprt', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'b4d571d2-7cc7-4be7-8178-2a8b747a329e', aName=&gt;'RPTFormula', aValue=&gt;'AUTORPTFormula', aOptionType=&gt;'DEFVIEW');

MTZ.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'fb4b9f13-86f2-48b4-acb0-4a07dd045342', aName=&gt;'Reports', aValue=&gt;'MTZRprt', aOptionType=&gt;'STRUCT_TYPE');

MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c44a43f2-e5a7-47aa-bf8f-30c74f0d284c', aName=&gt;'Reports', aValue=&gt;'AUTOReports', aOptionType=&gt;'DEFVIEW');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'539637c3-d2d1-4865-b1ad-794a7e151b2c', aName=&gt;'9181af0d-f0d0-4539-8cdb-67cdb500c41e', aValue=&gt;'GetFreeNumber', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e3fe5890-3545-490c-b1fc-418bd2b92ea9', aName=&gt;'2bb30818-90ed-4627-8abb-85b3fba46750', aValue=&gt;'VBNewPayOut', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'e7cec5c9-5192-4fb3-80c7-374eb7ec81fe', aName=&gt;'4fb59d1a-0123-47d3-9f4f-e12085c5d074', aValue=&gt;'VBUpdateItemName', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'57023316-b568-437e-946d-4ce073a6d8ff', aName=&gt;'477b8d25-4ff7-491a-a0b0-d3437ec16957', aValue=&gt;'MakeNewFolderEC', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'7dfde093-f450-4715-967a-f2ba9e9aedc3', aName=&gt;'42a1a436-8aa2-4f1f-999b-6680dff514de', aValue=&gt;'VBSaveHistory', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'0ad1c5e6-b6a5-4394-aeb6-a6f014c52907', aName=&gt;'6fb1873a-45a9-420f-90ce-cde34b5aee19', aValue=&gt;'AutoCloseSession', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'0899adbb-c6db-496d-913c-33d31fdf1d1c', aName=&gt;'61393545-abf7-46f7-82f3-9b7e610dd9c0', aValue=&gt;'VBUpdateObjName', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c7316abc-87f0-440a-be14-bc5800e9ca83', aName=&gt;'897d3b55-6599-42db-aa1c-54bab3d2f597', aValue=&gt;'GetNewNumber', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'24b0741e-8433-4c43-af17-ae1da675fe8d', aName=&gt;'2b0cee5c-7ffa-490d-9f5a-b5e8692551dd', aValue=&gt;'EraseNumber', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'5a77793b-21d6-4830-9311-eedb61476b95', aName=&gt;'73be205e-f7ea-4a5a-a41f-85e25ca6511e', aValue=&gt;'SessionCheckPoint', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'805584b4-71fc-46f3-bf43-46bcba8f0398', aName=&gt;'a87a3a65-ecd1-414f-8fdf-91e53aced1ba', aValue=&gt;'RowsToInstances', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'ea50a102-e7e5-494e-b10c-fccd5ad6eee0', aName=&gt;'a282dd68-9188-4c40-b0f2-be69caee3dea', aValue=&gt;'CheckVerbRight', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'1be6d1f0-73bf-40c7-adc6-d0103e148238', aName=&gt;'68bd7f75-ad54-4837-a6a7-a8dde3b2992a', aValue=&gt;'MTZLogin', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'213ab545-4c74-46af-9a55-b2e227517cfb', aName=&gt;'a2eee876-54d8-4aed-b124-775f5da2d911', aValue=&gt;'VBAddObjByRef', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'90e06cb3-8c51-4601-b737-2b7ccbafe161', aName=&gt;'73e7cf77-e6ba-42b4-a03b-4f67eedef4f1', aValue=&gt;'AdminUnlockAll', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'9a8960ad-3661-4e12-b070-cf86416d1273', aName=&gt;'8d492a94-7078-4b7d-9847-aefc27b4855d', aValue=&gt;'RowToInstance', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'98a3368c-1756-45b8-9e3b-26535557518b', aName=&gt;'7929d795-41c5-4a5c-bff2-a4e677a62143', aValue=&gt;'SessionTouch', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f278c815-fe38-4247-a36d-e537850813f5', aName=&gt;'6c6e6daa-5cd2-48c3-a2aa-a24539b45a49', aValue=&gt;'GetServerTime', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'9b051e18-b9d8-441c-80a9-cf19bee9218c', aName=&gt;'0c9985af-27ee-4ad5-a564-635e0bffc9d5', aValue=&gt;'TestNumber', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'f7798bbc-0bf3-4d0f-aa7e-a89dadc64370', aName=&gt;'8d3b38b4-c4f9-45ac-8ece-bf3be39d8100', aValue=&gt;'Logout', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'19f3107b-7e6f-432a-b13f-e56b5282a943', aName=&gt;'d8914fb4-6b5d-491a-a72f-985617727583', aValue=&gt;'WFFuncName', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'32e13266-9877-444c-9dfb-993836f87f5c', aName=&gt;'074e33b9-1ec9-4aa1-8300-e98c73d55fe2', aValue=&gt;'Login', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'54d9eb25-c688-43f0-88fd-a57a943377fe', aName=&gt;'d49a40b9-6174-4946-a81d-b7fe105c3546', aValue=&gt;'AdminUnlock', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'eae0ab6f-62e4-4445-aa63-826efa5ae219', aName=&gt;'5b8fb7b9-d8b1-4ca0-90af-55f83d1a6e5d', aValue=&gt;'VBMakeReport', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d3cc9ce8-febb-4f24-9687-c578ada0fc4d', aName=&gt;'94e8f6db-106a-44dc-9483-86c801798ff0', aValue=&gt;'VBOpenRef', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'336eac4a-b37e-4e40-ba4c-79e3fb7ed53e', aName=&gt;'069956dc-3305-45ef-9331-91ce323b5942', aValue=&gt;'WFDefName', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6b900fdf-afe6-4453-af47-541f49808c02', aName=&gt;'aa4085e6-745b-4a37-8ec4-65d99a653966', aValue=&gt;'VBRemoveSymmetricObjRef', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'6cbb6348-f835-4257-98cb-829b1493e6d3', aName=&gt;'49a49ae8-db4b-4329-80fb-801a24c9d7af', aValue=&gt;'ClearNumerators', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'a13b6fcf-5574-4b4f-9e28-c4eb6f066373', aName=&gt;'79e6bdeb-91d5-4b2e-81f7-3e091fb65e3a', aValue=&gt;'VBCheckDescrs', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'9f93ce56-5898-4780-b760-fdca4ed2dab4', aName=&gt;'0454d6f0-8624-4887-94b0-64fbc74775e6', aValue=&gt;'SessionVerify', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'d6337625-bc19-4696-b801-ac3c33c07535', aName=&gt;'5b376af5-339b-4365-ba80-785e28bcf4da', aValue=&gt;'VBUpdateSymmetricObjRef', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'c0fe1466-419c-49a0-9f8e-427edca46e48', aName=&gt;'31ec6cf7-8dbd-4efe-bf12-4d168f653d34', aValue=&gt;'VBApplySecurity', aOptionType=&gt;'METHODNAME');
MTZ.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'3ef02c5e-8a51-4a43-9d0c-8e75e00d2f79', aName=&gt;'79ded4fd-045c-45f8-ac79-2e5a3d956d97', aValue=&gt;'VBMigrateRight', aOptionType=&gt;'METHODNAME');
 --Logout  (acursession=&gt;asession);
end;
/
begin InitBase(); end;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
</root>